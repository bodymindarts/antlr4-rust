//package antlr
//
//import (
//  "fmt"
//  "strconv"
//)
//
////  atom, set, epsilon, action, predicate, rule transitions.
////
////  <p>This is a one way link.  It emanates from a state (usually via a list of
////  transitions) and has a target state.</p>
////
////  <p>Since we never have to change the ATN transitions once we construct it,
////  the states. We'll use the term Edge for the DFA to distinguish them from
////  ATN transitions.</p>
//
//pub trait Transition {
//  getTarget() ATNState
//  setTarget(ATNState)
//  getIsEpsilon() bool
//  getLabel() *IntervalSet
//  getSerializationType() i32
//  Matches(int, i32, i32) bool
//}
//
//pub struct BaseTransition {
//  target:            ATNState
//  isEpsilon:         bool
//  label:             i32
//  intervalSet:       *IntervalSet
//  serializationType: i32
//}
//
//impl BaseTransition {§//  pub fn new(&self, target: ATNState) -> *BaseTransition {
//
//  if target == nil {
//    panic("target cannot be nil.")
//  }
//
//  let t = new(BaseTransition);
//
//  t.target = target
//  // Are we epsilon, action, sempred?
//  t.isEpsilon = false
//  t.intervalSet = nil
//
//  return t
//}
//
//pub fn getTarget(&self, ) -> ATNState {
//  return t.target
//}
//
//pub fn setTarget(&self, s: ATNState) {
//  t.target = s
//}
//
//pub fn getIsEpsilon(&self, ) -> bool {
//  return t.isEpsilon
//}
//
//pub fn getLabel(&self, ) -> *IntervalSet {
//  return t.intervalSet
//}
//
//pub fn getSerializationType(&self, ) -> i32 {
//  return t.serializationType
//}
//
//pub fn Matches(&self, symbol,: minVocabSymbol, maxVocabSymbol: i32) -> bool {
//  panic("Not implemented")
//}
//
//const (
//  TransitionEPSILON    = 1
//  TransitionRANGE      = 2
//  TransitionRULE       = 3
//  TransitionPREDICATE  = 4 // e.g., {isType(input.LT(1))}?
//  TransitionATOM       = 5
//  TransitionACTION     = 6
//  TransitionSET        = 7 // ~(A|B) or ~atom, wildcard, which convert to next 2
//  TransitionNOTSET     = 8
//  TransitionWILDCARD   = 9
//  TransitionPRECEDENCE = 10
//)
//
//var TransitionserializationNames = []string{
//  "INVALID",
//  "EPSILON",
//  "RANGE",
//  "RULE",
//  "PREDICATE",
//  "ATOM",
//  "ACTION",
//  "SET",
//  "NOT_SET",
//  "WILDCARD",
//  "PRECEDENCE",
//}
//
////var TransitionserializationTypes struct {
////  EpsilonTransition: i32
////  RangeTransition: i32
////  RuleTransition: i32
////  PredicateTransition: i32
////  AtomTransition: i32
////  ActionTransition: i32
////  SetTransition: i32
////  NotSetTransition: i32
////  WildcardTransition: i32
////  PrecedencePredicateTransition: i32
////}{
////  TransitionEPSILON,
////  TransitionRANGE,
////  TransitionRULE,
////  TransitionPREDICATE,
////  TransitionATOM,
////  TransitionACTION,
////  TransitionSET,
////  TransitionNOTSET,
////  TransitionWILDCARD,
////  TransitionPRECEDENCE
////}
//
//// TODO: make all transitions sets? no, should remove set edges
//pub struct AtomTransition {
//  *BaseTransition
//}
//
//impl AtomTransition {§//  pub fn new(&self, target: ATNState, i32ervalSet: i32) -> *AtomTransition {
//
//  let t = new(AtomTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.label = i32ervalSet // The token type or character value or, signifies special i32ervalSet.
//  t.intervalSet = t.makeLabel()
//  t.serializationType = TransitionATOM
//
//  return t
//}
//
//pub fn makeLabel(&self, ) -> *IntervalSet {
//  let s = NewIntervalSet();
//  s.addOne(t.label)
//  return s
//}
//
//pub fn Matches(&self, symbol,: minVocabSymbol, maxVocabSymbol: i32) -> bool {
//  return t.label == symbol
//}
//
//pub fn String(&self, ) -> &str {
//  return strconv.Itoa(t.label)
//}
//
//pub struct RuleTransition {
//  *BaseTransition
//
//  followState:           ATNState
//  ruleIndex, precedence i32
//}
//
//impl RuleTransition {§//  pub fn new(&self, ruleStart ATNState, ruleIndex, precedence: i32, followState: ATNState) -> *RuleTransition {
//
//  let t = new(RuleTransition);
//  t.BaseTransition = NewBaseTransition(ruleStart)
//
//  t.ruleIndex = ruleIndex
//  t.precedence = precedence
//  t.followState = followState
//  t.serializationType = TransitionRULE
//  t.isEpsilon = true
//
//  return t
//}
//
//pub fn Matches(&self, symbol,: minVocabSymbol, maxVocabSymbol: i32) -> bool {
//  return false
//}
//
//pub struct EpsilonTransition {
//  *BaseTransition
//
//  outermostPrecedenceReturn: i32
//}
//
//impl EpsilonTransition {§//  pub fn new(&self, target: ATNState, outermostPrecedenceReturn: i32) -> *EpsilonTransition {
//
//  let t = new(EpsilonTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.serializationType = TransitionEPSILON
//  t.isEpsilon = true
//  t.outermostPrecedenceReturn = outermostPrecedenceReturn
//  return t
//}
//
//pub fn Matches(&self, symbol,: minVocabSymbol, maxVocabSymbol: i32) -> bool {
//  return false
//}
//
//pub fn String(&self, ) -> &str {
//  return "epsilon"
//}
//
//pub struct RangeTransition {
//  *BaseTransition
//
//  start, stop i32
//}
//
//impl RangeTransition {§//  pub fn new(&self, target ATNState,: start, stop: i32) -> *RangeTransition {
//
//  let t = new(RangeTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.serializationType = TransitionRANGE
//  t.start = start
//  t.stop = stop
//  t.intervalSet = t.makeLabel()
//  return t
//}
//
//pub fn makeLabel(&self, ) -> *IntervalSet {
//  let s = NewIntervalSet();
//  s.addRange(t.start, t.stop)
//  return s
//}
//
//pub fn Matches(&self, symbol,: minVocabSymbol, maxVocabSymbol: i32) -> bool {
//  return symbol >= t.start && symbol <= t.stop
//}
//
//pub fn String(&self, ) -> &str {
//  return "'" + &str(t.start) + "'..'" + &str(t.stop) + "'"
//}
//
//pub trait AbstractPredicateTransition {
//  Transition
//  IAbstractPredicateTransitionFoo()
//}
//
//pub struct BaseAbstractPredicateTransition {
//  *BaseTransition
//}
//
//impl BasePredicateTransition {§//  pub fn new(&self, target: ATNState) -> *BaseAbstractPredicateTransition {
//
//  let t = new(BaseAbstractPredicateTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  return t
//}
//
//pub fn IAbstractPredicateTransitionFoo() {}
//
//pub struct PredicateTransition {
//  *BaseAbstractPredicateTransition
//
//  isCtxDependent:       bool
//  ruleIndex, predIndex i32
//}
//
//impl PredicateTransition {§//  pub fn new(&self, target ATNState, ruleIndex, predIndex: i32, isCtxDependent: bool) -> *PredicateTransition {
//
//  let t = new(PredicateTransition);
//  t.BaseAbstractPredicateTransition = NewBasePredicateTransition(target)
//
//  t.serializationType = TransitionPREDICATE
//  t.ruleIndex = ruleIndex
//  t.predIndex = predIndex
//  t.isCtxDependent = isCtxDependent // e.g., $i ref in pred
//  t.isEpsilon = true
//  return t
//}
//
//pub fn Matches(&self, symbol,: minVocabSymbol, maxVocabSymbol: i32) -> bool {
//  return false
//}
//
//pub fn getPredicate(&self, ) -> *Predicate {
//  return NewPredicate(t.ruleIndex, t.predIndex, t.isCtxDependent)
//}
//
//pub fn String(&self, ) -> &str {
//  return "pred_" + strconv.Itoa(t.ruleIndex) + ":" + strconv.Itoa(t.predIndex)
//}
//
//pub struct ActionTransition {
//  *BaseTransition
//
//  isCtxDependent:                    bool
//  ruleIndex, actionIndex, predIndex i32
//}
//
//impl ActionTransition {§//  pub fn new(&self, target ATNState, ruleIndex, actionIndex: i32, isCtxDependent: bool) -> *ActionTransition {
//
//  let t = new(ActionTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.serializationType = TransitionACTION
//  t.ruleIndex = ruleIndex
//  t.actionIndex = actionIndex
//  t.isCtxDependent = isCtxDependent // e.g., $i ref in pred
//  t.isEpsilon = true
//  return t
//}
//
//pub fn Matches(&self, symbol,: minVocabSymbol, maxVocabSymbol: i32) -> bool {
//  return false
//}
//
//pub fn String(&self, ) -> &str {
//  return "action_" + strconv.Itoa(t.ruleIndex) + ":" + strconv.Itoa(t.actionIndex)
//}
//
//pub struct SetTransition {
//  *BaseTransition
//}
//
//impl SetTransition {§//  pub fn new(&self, target: ATNState, set *IntervalSet) -> *SetTransition {
//
//  let t = new(SetTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.serializationType = TransitionSET
//  if set != nil {
//    t.intervalSet = set
//  } else {
//    t.intervalSet = NewIntervalSet()
//    t.intervalSet.addOne(TokenInvalidType)
//  }
//
//  return t
//}
//
//pub fn Matches(&self, symbol,: minVocabSymbol, maxVocabSymbol: i32) -> bool {
//  return t.intervalSet.contains(symbol)
//}
//
//pub fn String(&self, ) -> &str {
//  return t.intervalSet.String()
//}
//
//pub struct NotSetTransition {
//  *SetTransition
//}
//
//impl NotSetTransition {§//  pub fn new(&self, target: ATNState, set *IntervalSet) -> *NotSetTransition {
//
//  let t = new(NotSetTransition);
//
//  t.SetTransition = NewSetTransition(target, set)
//
//  t.serializationType = TransitionNOTSET
//
//  return t
//}
//
//pub fn Matches(&self, symbol,: minVocabSymbol, maxVocabSymbol: i32) -> bool {
//  return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !t.intervalSet.contains(symbol)
//}
//
//pub fn String(&self, ) -> &str {
//  return "~" + t.intervalSet.String()
//}
//
//pub struct WildcardTransition {
//  *BaseTransition
//}
//
//impl WildcardTransition {§//  pub fn new(&self, target: ATNState) -> *WildcardTransition {
//
//  let t = new(WildcardTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.serializationType = TransitionWILDCARD
//  return t
//}
//
//pub fn Matches(&self, symbol,: minVocabSymbol, maxVocabSymbol: i32) -> bool {
//  return symbol >= minVocabSymbol && symbol <= maxVocabSymbol
//}
//
//pub fn String(&self, ) -> &str {
//  return "."
//}
//
//pub struct PrecedencePredicateTransition {
//  *BaseAbstractPredicateTransition
//
//  precedence: i32
//}
//
//impl PrecedencePredicateTransition {§//  pub fn new(&self, target: ATNState, precedence: i32) -> *PrecedencePredicateTransition {
//
//  let t = new(PrecedencePredicateTransition);
//  t.BaseAbstractPredicateTransition = NewBasePredicateTransition(target)
//
//  t.serializationType = TransitionPRECEDENCE
//  t.precedence = precedence
//  t.isEpsilon = true
//
//  return t
//}
//
//pub fn Matches(&self, symbol,: minVocabSymbol, maxVocabSymbol: i32) -> bool {
//  return false
//}
//
//pub fn getPredicate(&self, ) -> *PrecedencePredicate {
//  return NewPrecedencePredicate(t.precedence)
//}
//
//pub fn String(&self, ) -> &str {
//  return fmt.Sprint(t.precedence) + " >= _p"
//}
