//package antlr
//
//import (
//  "fmt"
//  "strconv"
//)
//
////  atom, set, epsilon, action, predicate, rule transitions.
////
////  <p>This is a one way link.  It emanates from a state (usually via a list of
////  transitions) and has a target state.</p>
////
////  <p>Since we never have to change the ATN transitions once we construct it,
////  the states. We'll use the term Edge for the DFA to distinguish them from
////  ATN transitions.</p>
//
//pub trait Transition {
//  get_target() ATNState
//  set_target(ATNState)
//  get_is_epsilon() bool
//  get_label() *IntervalSet
//  get_serialization_type() i32
//  Matches(int, i32, i32) bool
//}
//
//pub struct BaseTransition {
//  target:            ATNState
//  is_epsilon:         bool
//  label:             i32
//  interval_set:       *IntervalSet
//  serialization_type: i32
//}
//
//impl BaseTransition {§//  pub fn new(&self, target: ATNState) -> *BaseTransition {
//
//  if target == nil {
//    panic("target cannot be nil.")
//  }
//
//  let t = new(BaseTransition);
//
//  t.target = target
//  // Are we epsilon, action, sempred?
//  t.is_epsilon = false
//  t.interval_set = nil
//
//  return t
//}
//
//pub fn get_target(&self, ) -> ATNState {
//  return t.target
//}
//
//pub fn set_target(&self, s: ATNState) {
//  t.target = s
//}
//
//pub fn get_is_epsilon(&self, ) -> bool {
//  return t.is_epsilon
//}
//
//pub fn get_label(&self, ) -> *IntervalSet {
//  return t.interval_set
//}
//
//pub fn get_serialization_type(&self, ) -> i32 {
//  return t.serialization_type
//}
//
//pub fn Matches(&self, symbol,: min_vocab_symbol, max_vocab_symbol: i32) -> bool {
//  panic("Not implemented")
//}
//
//const (
//  TransitionEPSILON    = 1
//  TransitionRANGE      = 2
//  TransitionRULE       = 3
//  TransitionPREDICATE  = 4 // e.g., {isType(input.LT(1))}?
//  TransitionATOM       = 5
//  TransitionACTION     = 6
//  TransitionSET        = 7 // ~(A|B) or ~atom, wildcard, which convert to next 2
//  TransitionNOTSET     = 8
//  TransitionWILDCARD   = 9
//  TransitionPRECEDENCE = 10
//)
//
//var TransitionserializationNames = []string{
//  "INVALID",
//  "EPSILON",
//  "RANGE",
//  "RULE",
//  "PREDICATE",
//  "ATOM",
//  "ACTION",
//  "SET",
//  "NOT_SET",
//  "WILDCARD",
//  "PRECEDENCE",
//}
//
////var TransitionserializationTypes struct {
////  EpsilonTransition: i32
////  RangeTransition: i32
////  RuleTransition: i32
////  PredicateTransition: i32
////  AtomTransition: i32
////  ActionTransition: i32
////  SetTransition: i32
////  NotSetTransition: i32
////  WildcardTransition: i32
////  PrecedencePredicateTransition: i32
////}{
////  TransitionEPSILON,
////  TransitionRANGE,
////  TransitionRULE,
////  TransitionPREDICATE,
////  TransitionATOM,
////  TransitionACTION,
////  TransitionSET,
////  TransitionNOTSET,
////  TransitionWILDCARD,
////  TransitionPRECEDENCE
////}
//
//// TODO: make all transitions sets? no, should remove set edges
//pub struct AtomTransition {
//  *BaseTransition
//}
//
//impl AtomTransition {§//  pub fn new(&self, target: ATNState, i32ervalSet: i32) -> *AtomTransition {
//
//  let t = new(AtomTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.label = i32ervalSet // The token type or character value or, signifies special i32ervalSet.
//  t.interval_set = t.make_label()
//  t.serialization_type = TransitionATOM
//
//  return t
//}
//
//pub fn make_label(&self, ) -> *IntervalSet {
//  let s = NewIntervalSet();
//  s.add_one(t.label)
//  return s
//}
//
//pub fn Matches(&self, symbol,: min_vocab_symbol, max_vocab_symbol: i32) -> bool {
//  return t.label == symbol
//}
//
//pub fn String(&self, ) -> &str {
//  return strconv.Itoa(t.label)
//}
//
//pub struct RuleTransition {
//  *BaseTransition
//
//  follow_state:           ATNState
//  rule_index, precedence i32
//}
//
//impl RuleTransition {§//  pub fn new(&self, rule_start ATNState, rule_index, precedence: i32, follow_state: ATNState) -> *RuleTransition {
//
//  let t = new(RuleTransition);
//  t.BaseTransition = NewBaseTransition(ruleStart)
//
//  t.rule_index = rule_index
//  t.precedence = precedence
//  t.follow_state = follow_state
//  t.serialization_type = TransitionRULE
//  t.is_epsilon = true
//
//  return t
//}
//
//pub fn Matches(&self, symbol,: min_vocab_symbol, max_vocab_symbol: i32) -> bool {
//  return false
//}
//
//pub struct EpsilonTransition {
//  *BaseTransition
//
//  outermost_precedence_return: i32
//}
//
//impl EpsilonTransition {§//  pub fn new(&self, target: ATNState, outermost_precedence_return: i32) -> *EpsilonTransition {
//
//  let t = new(EpsilonTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.serialization_type = TransitionEPSILON
//  t.is_epsilon = true
//  t.outermost_precedence_return = outermost_precedence_return
//  return t
//}
//
//pub fn Matches(&self, symbol,: min_vocab_symbol, max_vocab_symbol: i32) -> bool {
//  return false
//}
//
//pub fn String(&self, ) -> &str {
//  return "epsilon"
//}
//
//pub struct RangeTransition {
//  *BaseTransition
//
//  start, stop i32
//}
//
//impl RangeTransition {§//  pub fn new(&self, target ATNState,: start, stop: i32) -> *RangeTransition {
//
//  let t = new(RangeTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.serialization_type = TransitionRANGE
//  t.start = start
//  t.stop = stop
//  t.interval_set = t.make_label()
//  return t
//}
//
//pub fn make_label(&self, ) -> *IntervalSet {
//  let s = NewIntervalSet();
//  s.add_range(t.start, t.stop)
//  return s
//}
//
//pub fn Matches(&self, symbol,: min_vocab_symbol, max_vocab_symbol: i32) -> bool {
//  return symbol >= t.start && symbol <= t.stop
//}
//
//pub fn String(&self, ) -> &str {
//  return "'" + &str(t.start) + "'..'" + &str(t.stop) + "'"
//}
//
//pub trait AbstractPredicateTransition {
//  Transition
//  IAbstractPredicateTransitionFoo()
//}
//
//pub struct BaseAbstractPredicateTransition {
//  *BaseTransition
//}
//
//impl BasePredicateTransition {§//  pub fn new(&self, target: ATNState) -> *BaseAbstractPredicateTransition {
//
//  let t = new(BaseAbstractPredicateTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  return t
//}
//
//pub fn IAbstractPredicateTransitionFoo() {}
//
//pub struct PredicateTransition {
//  *BaseAbstractPredicateTransition
//
//  is_ctx_dependent:       bool
//  rule_index, pred_index i32
//}
//
//impl PredicateTransition {§//  pub fn new(&self, target ATNState, rule_index, pred_index: i32, is_ctx_dependent: bool) -> *PredicateTransition {
//
//  let t = new(PredicateTransition);
//  t.BaseAbstractPredicateTransition = NewBasePredicateTransition(target)
//
//  t.serialization_type = TransitionPREDICATE
//  t.rule_index = rule_index
//  t.pred_index = pred_index
//  t.is_ctx_dependent = is_ctx_dependent // e.g., $i ref in pred
//  t.is_epsilon = true
//  return t
//}
//
//pub fn Matches(&self, symbol,: min_vocab_symbol, max_vocab_symbol: i32) -> bool {
//  return false
//}
//
//pub fn get_predicate(&self, ) -> *Predicate {
//  return NewPredicate(t.rule_index, t.pred_index, t.is_ctx_dependent)
//}
//
//pub fn String(&self, ) -> &str {
//  return "pred_" + strconv.Itoa(t.rule_index) + ":" + strconv.Itoa(t.pred_index)
//}
//
//pub struct ActionTransition {
//  *BaseTransition
//
//  is_ctx_dependent:                    bool
//  rule_index, action_index, pred_index i32
//}
//
//impl ActionTransition {§//  pub fn new(&self, target ATNState, rule_index, action_index: i32, is_ctx_dependent: bool) -> *ActionTransition {
//
//  let t = new(ActionTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.serialization_type = TransitionACTION
//  t.rule_index = rule_index
//  t.action_index = action_index
//  t.is_ctx_dependent = is_ctx_dependent // e.g., $i ref in pred
//  t.is_epsilon = true
//  return t
//}
//
//pub fn Matches(&self, symbol,: min_vocab_symbol, max_vocab_symbol: i32) -> bool {
//  return false
//}
//
//pub fn String(&self, ) -> &str {
//  return "action_" + strconv.Itoa(t.rule_index) + ":" + strconv.Itoa(t.action_index)
//}
//
//pub struct SetTransition {
//  *BaseTransition
//}
//
//impl SetTransition {§//  pub fn new(&self, target: ATNState, set *IntervalSet) -> *SetTransition {
//
//  let t = new(SetTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.serialization_type = TransitionSET
//  if set != nil {
//    t.interval_set = set
//  } else {
//    t.interval_set = NewIntervalSet()
//    t.interval_set.add_one(TokenInvalidType)
//  }
//
//  return t
//}
//
//pub fn Matches(&self, symbol,: min_vocab_symbol, max_vocab_symbol: i32) -> bool {
//  return t.interval_set.contains(symbol)
//}
//
//pub fn String(&self, ) -> &str {
//  return t.interval_set.String()
//}
//
//pub struct NotSetTransition {
//  *SetTransition
//}
//
//impl NotSetTransition {§//  pub fn new(&self, target: ATNState, set *IntervalSet) -> *NotSetTransition {
//
//  let t = new(NotSetTransition);
//
//  t.SetTransition = NewSetTransition(target, set)
//
//  t.serialization_type = TransitionNOTSET
//
//  return t
//}
//
//pub fn Matches(&self, symbol,: min_vocab_symbol, max_vocab_symbol: i32) -> bool {
//  return symbol >= min_vocab_symbol && symbol <= max_vocab_symbol && !t.interval_set.contains(symbol)
//}
//
//pub fn String(&self, ) -> &str {
//  return "~" + t.interval_set.String()
//}
//
//pub struct WildcardTransition {
//  *BaseTransition
//}
//
//impl WildcardTransition {§//  pub fn new(&self, target: ATNState) -> *WildcardTransition {
//
//  let t = new(WildcardTransition);
//  t.BaseTransition = NewBaseTransition(target)
//
//  t.serialization_type = TransitionWILDCARD
//  return t
//}
//
//pub fn Matches(&self, symbol,: min_vocab_symbol, max_vocab_symbol: i32) -> bool {
//  return symbol >= min_vocab_symbol && symbol <= max_vocab_symbol
//}
//
//pub fn String(&self, ) -> &str {
//  return "."
//}
//
//pub struct PrecedencePredicateTransition {
//  *BaseAbstractPredicateTransition
//
//  precedence: i32
//}
//
//impl PrecedencePredicateTransition {§//  pub fn new(&self, target: ATNState, precedence: i32) -> *PrecedencePredicateTransition {
//
//  let t = new(PrecedencePredicateTransition);
//  t.BaseAbstractPredicateTransition = NewBasePredicateTransition(target)
//
//  t.serialization_type = TransitionPRECEDENCE
//  t.precedence = precedence
//  t.is_epsilon = true
//
//  return t
//}
//
//pub fn Matches(&self, symbol,: min_vocab_symbol, max_vocab_symbol: i32) -> bool {
//  return false
//}
//
//pub fn get_predicate(&self, ) -> *PrecedencePredicate {
//  return NewPrecedencePredicate(t.precedence)
//}
//
//pub fn String(&self, ) -> &str {
//  return fmt.Sprint(t.precedence) + " >= _p"
//}
