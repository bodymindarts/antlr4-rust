//package antlr
//
//import (
//	"fmt"
//	"strconv"
//)
//
////  atom, set, epsilon, action, predicate, rule transitions.
////
////  <p>This is a one way link.  It emanates from a state (usually via a list of
////  transitions) and has a target state.</p>
////
////  <p>Since we never have to change the ATN transitions once we construct it,
////  the states. We'll use the term Edge for the DFA to distinguish them from
////  ATN transitions.</p>
//
//pub trait Transition {
//	getTarget() ATNState
//	setTarget(ATNState)
//	getIsEpsilon() bool
//	getLabel() *IntervalSet
//	getSerializationType() int
//	Matches(int, int, int) bool
//}
//
//pub struct BaseTransition {
//	target:            ATNState
//	isEpsilon:         bool
//	label:             int
//	intervalSet:       *IntervalSet
//	serializationType: int
//}
//
//impl BaseTransition {§//  pub fn new(target ATNState) -> *BaseTransition {
//
//	if target == nil {
//		panic("target cannot be nil.")
//	}
//
//	t := new(BaseTransition)
//
//	t.target = target
//	// Are we epsilon, action, sempred?
//	t.isEpsilon = false
//	t.intervalSet = nil
//
//	return t
//}
//
//pub fn getTarget() -> ATNState {
//	return t.target
//}
//
//pub fn setTarget(s ATNState) -> {
//	t.target = s
//}
//
//pub fn getIsEpsilon() -> bool {
//	return t.isEpsilon
//}
//
//pub fn getLabel() -> *IntervalSet {
//	return t.intervalSet
//}
//
//pub fn getSerializationType() -> int {
//	return t.serializationType
//}
//
//pub fn Matches(symbol, minVocabSymbol, maxVocabSymbol int) -> bool {
//	panic("Not implemented")
//}
//
//const (
//	TransitionEPSILON    = 1
//	TransitionRANGE      = 2
//	TransitionRULE       = 3
//	TransitionPREDICATE  = 4 // e.g., {isType(input.LT(1))}?
//	TransitionATOM       = 5
//	TransitionACTION     = 6
//	TransitionSET        = 7 // ~(A|B) or ~atom, wildcard, which convert to next 2
//	TransitionNOTSET     = 8
//	TransitionWILDCARD   = 9
//	TransitionPRECEDENCE = 10
//)
//
//var TransitionserializationNames = []string{
//	"INVALID",
//	"EPSILON",
//	"RANGE",
//	"RULE",
//	"PREDICATE",
//	"ATOM",
//	"ACTION",
//	"SET",
//	"NOT_SET",
//	"WILDCARD",
//	"PRECEDENCE",
//}
//
////var TransitionserializationTypes struct {
////	EpsilonTransition: int
////	RangeTransition: int
////	RuleTransition: int
////	PredicateTransition: int
////	AtomTransition: int
////	ActionTransition: int
////	SetTransition: int
////	NotSetTransition: int
////	WildcardTransition: int
////	PrecedencePredicateTransition: int
////}{
////	TransitionEPSILON,
////	TransitionRANGE,
////	TransitionRULE,
////	TransitionPREDICATE,
////	TransitionATOM,
////	TransitionACTION,
////	TransitionSET,
////	TransitionNOTSET,
////	TransitionWILDCARD,
////	TransitionPRECEDENCE
////}
//
//// TODO: make all transitions sets? no, should remove set edges
//pub struct AtomTransition {
//	*BaseTransition
//}
//
//impl AtomTransition {§//  pub fn new(target ATNState, intervalSet int) -> *AtomTransition {
//
//	t := new(AtomTransition)
//	t.BaseTransition = NewBaseTransition(target)
//
//	t.label = intervalSet // The token type or character value or, signifies special intervalSet.
//	t.intervalSet = t.makeLabel()
//	t.serializationType = TransitionATOM
//
//	return t
//}
//
//pub fn makeLabel() -> *IntervalSet {
//	s := NewIntervalSet()
//	s.addOne(t.label)
//	return s
//}
//
//pub fn Matches(symbol, minVocabSymbol, maxVocabSymbol int) -> bool {
//	return t.label == symbol
//}
//
//pub fn String() -> string {
//	return strconv.Itoa(t.label)
//}
//
//pub struct RuleTransition {
//	*BaseTransition
//
//	followState:           ATNState
//	ruleIndex, precedence int
//}
//
//impl RuleTransition {§//  pub fn new(ruleStart ATNState, ruleIndex, precedence int, followState ATNState) -> *RuleTransition {
//
//	t := new(RuleTransition)
//	t.BaseTransition = NewBaseTransition(ruleStart)
//
//	t.ruleIndex = ruleIndex
//	t.precedence = precedence
//	t.followState = followState
//	t.serializationType = TransitionRULE
//	t.isEpsilon = true
//
//	return t
//}
//
//pub fn Matches(symbol, minVocabSymbol, maxVocabSymbol int) -> bool {
//	return false
//}
//
//pub struct EpsilonTransition {
//	*BaseTransition
//
//	outermostPrecedenceReturn: int
//}
//
//impl EpsilonTransition {§//  pub fn new(target ATNState, outermostPrecedenceReturn int) -> *EpsilonTransition {
//
//	t := new(EpsilonTransition)
//	t.BaseTransition = NewBaseTransition(target)
//
//	t.serializationType = TransitionEPSILON
//	t.isEpsilon = true
//	t.outermostPrecedenceReturn = outermostPrecedenceReturn
//	return t
//}
//
//pub fn Matches(symbol, minVocabSymbol, maxVocabSymbol int) -> bool {
//	return false
//}
//
//pub fn String() -> string {
//	return "epsilon"
//}
//
//pub struct RangeTransition {
//	*BaseTransition
//
//	start, stop int
//}
//
//impl RangeTransition {§//  pub fn new(target ATNState, start, stop int) -> *RangeTransition {
//
//	t := new(RangeTransition)
//	t.BaseTransition = NewBaseTransition(target)
//
//	t.serializationType = TransitionRANGE
//	t.start = start
//	t.stop = stop
//	t.intervalSet = t.makeLabel()
//	return t
//}
//
//pub fn makeLabel() -> *IntervalSet {
//	s := NewIntervalSet()
//	s.addRange(t.start, t.stop)
//	return s
//}
//
//pub fn Matches(symbol, minVocabSymbol, maxVocabSymbol int) -> bool {
//	return symbol >= t.start && symbol <= t.stop
//}
//
//pub fn String() -> string {
//	return "'" + string(t.start) + "'..'" + string(t.stop) + "'"
//}
//
//pub trait AbstractPredicateTransition {
//	Transition
//	IAbstractPredicateTransitionFoo()
//}
//
//pub struct BaseAbstractPredicateTransition {
//	*BaseTransition
//}
//
//impl BasePredicateTransition {§//  pub fn new(target ATNState) -> *BaseAbstractPredicateTransition {
//
//	t := new(BaseAbstractPredicateTransition)
//	t.BaseTransition = NewBaseTransition(target)
//
//	return t
//}
//
//pub fn IAbstractPredicateTransitionFoo() -> {}
//
//pub struct PredicateTransition {
//	*BaseAbstractPredicateTransition
//
//	isCtxDependent:       bool
//	ruleIndex, predIndex int
//}
//
//impl PredicateTransition {§//  pub fn new(target ATNState, ruleIndex, predIndex int, isCtxDependent bool) -> *PredicateTransition {
//
//	t := new(PredicateTransition)
//	t.BaseAbstractPredicateTransition = NewBasePredicateTransition(target)
//
//	t.serializationType = TransitionPREDICATE
//	t.ruleIndex = ruleIndex
//	t.predIndex = predIndex
//	t.isCtxDependent = isCtxDependent // e.g., $i ref in pred
//	t.isEpsilon = true
//	return t
//}
//
//pub fn Matches(symbol, minVocabSymbol, maxVocabSymbol int) -> bool {
//	return false
//}
//
//pub fn getPredicate() -> *Predicate {
//	return NewPredicate(t.ruleIndex, t.predIndex, t.isCtxDependent)
//}
//
//pub fn String() -> string {
//	return "pred_" + strconv.Itoa(t.ruleIndex) + ":" + strconv.Itoa(t.predIndex)
//}
//
//pub struct ActionTransition {
//	*BaseTransition
//
//	isCtxDependent:                    bool
//	ruleIndex, actionIndex, predIndex int
//}
//
//impl ActionTransition {§//  pub fn new(target ATNState, ruleIndex, actionIndex int, isCtxDependent bool) -> *ActionTransition {
//
//	t := new(ActionTransition)
//	t.BaseTransition = NewBaseTransition(target)
//
//	t.serializationType = TransitionACTION
//	t.ruleIndex = ruleIndex
//	t.actionIndex = actionIndex
//	t.isCtxDependent = isCtxDependent // e.g., $i ref in pred
//	t.isEpsilon = true
//	return t
//}
//
//pub fn Matches(symbol, minVocabSymbol, maxVocabSymbol int) -> bool {
//	return false
//}
//
//pub fn String() -> string {
//	return "action_" + strconv.Itoa(t.ruleIndex) + ":" + strconv.Itoa(t.actionIndex)
//}
//
//pub struct SetTransition {
//	*BaseTransition
//}
//
//impl SetTransition {§//  pub fn new(target ATNState, set *IntervalSet) -> *SetTransition {
//
//	t := new(SetTransition)
//	t.BaseTransition = NewBaseTransition(target)
//
//	t.serializationType = TransitionSET
//	if set != nil {
//		t.intervalSet = set
//	} else {
//		t.intervalSet = NewIntervalSet()
//		t.intervalSet.addOne(TokenInvalidType)
//	}
//
//	return t
//}
//
//pub fn Matches(symbol, minVocabSymbol, maxVocabSymbol int) -> bool {
//	return t.intervalSet.contains(symbol)
//}
//
//pub fn String() -> string {
//	return t.intervalSet.String()
//}
//
//pub struct NotSetTransition {
//	*SetTransition
//}
//
//impl NotSetTransition {§//  pub fn new(target ATNState, set *IntervalSet) -> *NotSetTransition {
//
//	t := new(NotSetTransition)
//
//	t.SetTransition = NewSetTransition(target, set)
//
//	t.serializationType = TransitionNOTSET
//
//	return t
//}
//
//pub fn Matches(symbol, minVocabSymbol, maxVocabSymbol int) -> bool {
//	return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !t.intervalSet.contains(symbol)
//}
//
//pub fn String() -> string {
//	return "~" + t.intervalSet.String()
//}
//
//pub struct WildcardTransition {
//	*BaseTransition
//}
//
//impl WildcardTransition {§//  pub fn new(target ATNState) -> *WildcardTransition {
//
//	t := new(WildcardTransition)
//	t.BaseTransition = NewBaseTransition(target)
//
//	t.serializationType = TransitionWILDCARD
//	return t
//}
//
//pub fn Matches(symbol, minVocabSymbol, maxVocabSymbol int) -> bool {
//	return symbol >= minVocabSymbol && symbol <= maxVocabSymbol
//}
//
//pub fn String() -> string {
//	return "."
//}
//
//pub struct PrecedencePredicateTransition {
//	*BaseAbstractPredicateTransition
//
//	precedence: int
//}
//
//impl PrecedencePredicateTransition {§//  pub fn new(target ATNState, precedence int) -> *PrecedencePredicateTransition {
//
//	t := new(PrecedencePredicateTransition)
//	t.BaseAbstractPredicateTransition = NewBasePredicateTransition(target)
//
//	t.serializationType = TransitionPRECEDENCE
//	t.precedence = precedence
//	t.isEpsilon = true
//
//	return t
//}
//
//pub fn Matches(symbol, minVocabSymbol, maxVocabSymbol int) -> bool {
//	return false
//}
//
//pub fn getPredicate() -> *PrecedencePredicate {
//	return NewPrecedencePredicate(t.precedence)
//}
//
//pub fn String() -> string {
//	return fmt.Sprint(t.precedence) + " >= _p"
//}
