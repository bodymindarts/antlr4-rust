//package antlr
//
//import (
//  "reflect"
//  "strconv"
//)
//
//pub trait ParserRuleContext {
//  RuleContext
//
//  SetException(RecognitionException)
//
//  AddTokenNode(token Token) *TerminalNodeImpl
//  AddErrorNode(badToken Token) *ErrorNodeImpl
//
//  EnterRule(listener ParseTreeListener)
//  ExitRule(listener ParseTreeListener)
//
//  SetStart(Token)
//  GetStart() Token
//
//  SetStop(Token)
//  GetStop() Token
//
//  AddChild(child RuleContext) RuleContext
//  RemoveLastChild()
//}
//
//pub struct BaseParserRuleContext {
//  *BaseRuleContext
//
//  start, stop Token
//  exception:   RecognitionException
//  children    []Tree
//}
//
//impl BaseParserRuleContext {ยง//  pub fn new(&self, parent: ParserRuleContext, invokingStateNumber: i32) -> *BaseParserRuleContext {
//  prc := new(BaseParserRuleContext)
//
//  prc.BaseRuleContext = NewBaseRuleContext(parent, invokingStateNumber)
//
//  prc.RuleIndex = -1
//  // * If we are debugging or building a parse tree for a Visitor,
//  // we need to track all of the tokens and rule invocations associated
//  // with prc rule's context. This is empty for parsing w/o tree constr.
//  // operation because we don't the need to track the details about
//  // how we parse prc rule.
//  // /
//  prc.children = nil
//  prc.start = nil
//  prc.stop = nil
//  // The exception that forced prc rule to return. If the rule successfully
//  // completed, prc is {@code nil}.
//  prc.exception = nil
//
//  return prc
//}
//
//pub fn SetException(&self, e: RecognitionException) {
//  prc.exception = e
//}
//
//pub fn GetChildren(&self, ) -> []Tree {
//  return prc.children
//}
//
//pub fn CopyFrom(&self, ctx *BaseParserRuleContext) {
//  // from RuleContext
//  prc.parentCtx = ctx.parentCtx
//  prc.invokingState = ctx.invokingState
//  prc.children = nil
//  prc.start = ctx.start
//  prc.stop = ctx.stop
//}
//
//pub fn GetText(&self, ) -> &str {
//  if prc.GetChildCount() == 0 {
//    return ""
//  }
//
//  var s &str
//  for _, child := range prc.children {
//    s += child.(ParseTree).GetText()
//  }
//
//  return s
//}
//
//// Double dispatch methods for listeners
//pub fn EnterRule(&self, listener: ParseTreeListener) {
//}
//
//pub fn ExitRule(&self, listener: ParseTreeListener) {
//}
//
//// * Does not set parent link other add methods do that///
//pub fn addTerminalNodeChild(&self, child: TerminalNode) -> TerminalNode {
//  if prc.children == nil {
//    prc.children = make([]Tree, 0)
//  }
//  if child == nil {
//    panic("Child may not be null")
//  }
//  prc.children = append(prc.children, child)
//  return child
//}
//
//pub fn AddChild(&self, child: RuleContext) -> RuleContext {
//  if prc.children == nil {
//    prc.children = make([]Tree, 0)
//  }
//  if child == nil {
//    panic("Child may not be null")
//  }
//  prc.children = append(prc.children, child)
//  return child
//}
//
//// * Used by EnterOuterAlt to toss out a RuleContext previously added as
//// we entered a rule. If we have // label, we will need to remove
//// generic ruleContext object.
//// /
//pub fn RemoveLastChild(&self, ) {
//  if prc.children != nil && len(prc.children) > 0 {
//    prc.children = prc.children[0 : len(prc.children)-1]
//  }
//}
//
//pub fn AddTokenNode(&self, token: Token) -> *TerminalNodeImpl {
//
//  node := NewTerminalNodeImpl(token)
//  prc.addTerminalNodeChild(node)
//  node.parentCtx = prc
//  return node
//
//}
//
//pub fn AddErrorNode(&self, badToken: Token) -> *ErrorNodeImpl {
//  node := NewErrorNodeImpl(badToken)
//  prc.addTerminalNodeChild(node)
//  node.parentCtx = prc
//  return node
//}
//
//pub fn GetChild(&self, i: i32) -> Tree {
//  if prc.children != nil && len(prc.children) >= i {
//    return prc.children[i]
//  }
//
//  return nil
//}
//
//pub fn GetChildOfType(&self, i: i32, childType reflect.Type) -> RuleContext {
//  if childType == nil {
//    return prc.GetChild(i).(RuleContext)
//  }
//
//  for j := 0; j < len(prc.children); j++ {
//    child := prc.children[j]
//    if reflect.TypeOf(child) == childType {
//      if i == 0 {
//        return child.(RuleContext)
//      }
//
//      i--
//    }
//  }
//
//  return nil
//}
//
//pub fn ToStringTree(&self, ruleNames []string, recog: Recognizer) -> &str {
//  return TreesStringTree(prc, ruleNames, recog)
//}
//
//pub fn GetRuleContext(&self, ) -> RuleContext {
//  return prc
//}
//
//pub fn Accept(&self, visitor: ParseTreeVisitor) -> i32erface{} {
//  return visitor.VisitChildren(prc)
//}
//
//pub fn SetStart(&self, t: Token) {
//  prc.start = t
//}
//
//pub fn GetStart(&self, ) -> Token {
//  return prc.start
//}
//
//pub fn SetStop(&self, t: Token) {
//  prc.stop = t
//}
//
//pub fn GetStop(&self, ) -> Token {
//  return prc.stop
//}
//
//pub fn GetToken(&self, ttype: i32, i: i32) -> TerminalNode {
//
//  for j := 0; j < len(prc.children); j++ {
//    child := prc.children[j]
//    if c2, ok := child.(TerminalNode); ok {
//      if c2.GetSymbol().GetTokenType() == ttype {
//        if i == 0 {
//          return c2
//        }
//
//        i--
//      }
//    }
//  }
//  return nil
//}
//
//pub fn GetTokens(&self, ttype: i32) -> []TerminalNode {
//  if prc.children == nil {
//    return make([]TerminalNode, 0)
//  }
//
//  tokens := make([]TerminalNode, 0)
//
//  for j := 0; j < len(prc.children); j++ {
//    child := prc.children[j]
//    if tchild, ok := child.(TerminalNode); ok {
//      if tchild.GetSymbol().GetTokenType() == ttype {
//        tokens = append(tokens, tchild)
//      }
//    }
//  }
//
//  return tokens
//}
//
//pub fn GetPayload(&self, ) -> i32erface{} {
//  return prc
//}
//
//pub fn getChild(&self, ctxType reflect.Type, i: i32) -> RuleContext {
//  if prc.children == nil || i < 0 || i >= len(prc.children) {
//    return nil
//  }
//
//  j := -1 // what element have we found with ctxType?
//  for _, o := range prc.children {
//
//    childType := reflect.TypeOf(o)
//
//    if childType.Implements(ctxType) {
//      j++
//      if j == i {
//        return o.(RuleContext)
//      }
//    }
//  }
//  return nil
//}
//
//// Go lacks generics, so it's not possible for us to return the child with the correct type, but we do
//// check for convertibility
//
//pub fn GetTypedRuleContext(&self, ctxType reflect.Type, i: i32) -> RuleContext {
//  return prc.getChild(ctxType, i)
//}
//
//pub fn GetTypedRuleContexts(&self, ctxType reflect.Type) -> []RuleContext {
//  if prc.children == nil {
//    return make([]RuleContext, 0)
//  }
//
//  contexts := make([]RuleContext, 0)
//
//  for _, child := range prc.children {
//    childType := reflect.TypeOf(child)
//
//    if childType.ConvertibleTo(ctxType) {
//      contexts = append(contexts, child.(RuleContext))
//    }
//  }
//  return contexts
//}
//
//pub fn GetChildCount(&self, ) -> i32 {
//  if prc.children == nil {
//    return 0
//  }
//
//  return len(prc.children)
//}
//
//pub fn GetSourceInterval(&self, ) -> *Interval {
//  if prc.start == nil || prc.stop == nil {
//    return TreeInvalidInterval
//  }
//
//  return NewInterval(prc.start.GetTokenIndex(), prc.stop.GetTokenIndex())
//}
//
////need to manage circular dependencies, so export now
//
//// Print out a whole tree, not just a node, in LISP format
//// (root child1 .. childN). Print just a node if b is a leaf.
////
//
//pub fn String(&self, ruleNames []string, stop: RuleContext) -> &str {
//
//  var p ParserRuleContext = prc
//  s := "["
//  for p != nil && p != stop {
//    if ruleNames == nil {
//      if !p.IsEmpty() {
//        s += strconv.Itoa(p.GetInvokingState())
//      }
//    } else {
//      ri := p.GetRuleIndex()
//      var ruleName &str
//      if ri >= 0 && ri < len(ruleNames) {
//        ruleName = ruleNames[ri]
//      } else {
//        ruleName = strconv.Itoa(ri)
//      }
//      s += ruleName
//    }
//    if p.GetParent() != nil && (ruleNames != nil || !p.GetParent().(ParserRuleContext).IsEmpty()) {
//      s += " "
//    }
//    pi := p.GetParent()
//    if pi != nil {
//      p = pi.(ParserRuleContext)
//    } else {
//      p = nil
//    }
//  }
//  s += "]"
//  return s
//}
//
//var RuleContextEmpty = NewBaseParserRuleContext(nil, -1)
//
//pub trait InterpreterRuleContext {
//  ParserRuleContext
//}
//
//pub struct BaseInterpreterRuleContext {
//  *BaseParserRuleContext
//}
//
//impl BaseInterpreterRuleContext {ยง//  pub fn new(&self, parent BaseInterpreterRuleContext,: invokingStateNumber, ruleIndex: i32) -> *BaseInterpreterRuleContext {
//
//  prc := new(BaseInterpreterRuleContext)
//
//  prc.BaseParserRuleContext = NewBaseParserRuleContext(parent, invokingStateNumber)
//
//  prc.RuleIndex = ruleIndex
//
//  return prc
//}
