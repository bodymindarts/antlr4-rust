//package antlr
//
//import (
//	"reflect"
//	"strconv"
//)
//
//pub trait ParserRuleContext {
//	RuleContext
//
//	SetException(RecognitionException)
//
//	AddTokenNode(token Token) *TerminalNodeImpl
//	AddErrorNode(badToken Token) *ErrorNodeImpl
//
//	EnterRule(listener ParseTreeListener)
//	ExitRule(listener ParseTreeListener)
//
//	SetStart(Token)
//	GetStart() Token
//
//	SetStop(Token)
//	GetStop() Token
//
//	AddChild(child RuleContext) RuleContext
//	RemoveLastChild()
//}
//
//pub struct BaseParserRuleContext {
//	*BaseRuleContext
//
//	start, stop Token
//	exception   RecognitionException
//	children    []Tree
//}
//
//impl BaseParserRuleContext {ยง//  pub fn new(parent ParserRuleContext, invokingStateNumber int) *BaseParserRuleContext {
//	prc := new(BaseParserRuleContext)
//
//	prc.BaseRuleContext = NewBaseRuleContext(parent, invokingStateNumber)
//
//	prc.RuleIndex = -1
//	// * If we are debugging or building a parse tree for a Visitor,
//	// we need to track all of the tokens and rule invocations associated
//	// with prc rule's context. This is empty for parsing w/o tree constr.
//	// operation because we don't the need to track the details about
//	// how we parse prc rule.
//	// /
//	prc.children = nil
//	prc.start = nil
//	prc.stop = nil
//	// The exception that forced prc rule to return. If the rule successfully
//	// completed, prc is {@code nil}.
//	prc.exception = nil
//
//	return prc
//}
//
//pub fn SetException(e RecognitionException) -> {
//	prc.exception = e
//}
//
//pub fn GetChildren() -> []Tree {
//	return prc.children
//}
//
//pub fn CopyFrom(ctx *BaseParserRuleContext) -> {
//	// from RuleContext
//	prc.parentCtx = ctx.parentCtx
//	prc.invokingState = ctx.invokingState
//	prc.children = nil
//	prc.start = ctx.start
//	prc.stop = ctx.stop
//}
//
//pub fn GetText() -> string {
//	if prc.GetChildCount() == 0 {
//		return ""
//	}
//
//	var s string
//	for _, child := range prc.children {
//		s += child.(ParseTree).GetText()
//	}
//
//	return s
//}
//
//// Double dispatch methods for listeners
//pub fn EnterRule(listener ParseTreeListener) -> {
//}
//
//pub fn ExitRule(listener ParseTreeListener) -> {
//}
//
//// * Does not set parent link other add methods do that///
//pub fn addTerminalNodeChild(child TerminalNode) -> TerminalNode {
//	if prc.children == nil {
//		prc.children = make([]Tree, 0)
//	}
//	if child == nil {
//		panic("Child may not be null")
//	}
//	prc.children = append(prc.children, child)
//	return child
//}
//
//pub fn AddChild(child RuleContext) -> RuleContext {
//	if prc.children == nil {
//		prc.children = make([]Tree, 0)
//	}
//	if child == nil {
//		panic("Child may not be null")
//	}
//	prc.children = append(prc.children, child)
//	return child
//}
//
//// * Used by EnterOuterAlt to toss out a RuleContext previously added as
//// we entered a rule. If we have // label, we will need to remove
//// generic ruleContext object.
//// /
//pub fn RemoveLastChild() -> {
//	if prc.children != nil && len(prc.children) > 0 {
//		prc.children = prc.children[0 : len(prc.children)-1]
//	}
//}
//
//pub fn AddTokenNode(token Token) -> *TerminalNodeImpl {
//
//	node := NewTerminalNodeImpl(token)
//	prc.addTerminalNodeChild(node)
//	node.parentCtx = prc
//	return node
//
//}
//
//pub fn AddErrorNode(badToken Token) -> *ErrorNodeImpl {
//	node := NewErrorNodeImpl(badToken)
//	prc.addTerminalNodeChild(node)
//	node.parentCtx = prc
//	return node
//}
//
//pub fn GetChild(i int) -> Tree {
//	if prc.children != nil && len(prc.children) >= i {
//		return prc.children[i]
//	}
//
//	return nil
//}
//
//pub fn GetChildOfType(i int, childType reflect.Type) -> RuleContext {
//	if childType == nil {
//		return prc.GetChild(i).(RuleContext)
//	}
//
//	for j := 0; j < len(prc.children); j++ {
//		child := prc.children[j]
//		if reflect.TypeOf(child) == childType {
//			if i == 0 {
//				return child.(RuleContext)
//			}
//
//			i--
//		}
//	}
//
//	return nil
//}
//
//pub fn ToStringTree(ruleNames []string, recog Recognizer) -> string {
//	return TreesStringTree(prc, ruleNames, recog)
//}
//
//pub fn GetRuleContext() -> RuleContext {
//	return prc
//}
//
//pub fn Accept(visitor ParseTreeVisitor) -> interface{} {
//	return visitor.VisitChildren(prc)
//}
//
//pub fn SetStart(t Token) -> {
//	prc.start = t
//}
//
//pub fn GetStart() -> Token {
//	return prc.start
//}
//
//pub fn SetStop(t Token) -> {
//	prc.stop = t
//}
//
//pub fn GetStop() -> Token {
//	return prc.stop
//}
//
//pub fn GetToken(ttype int, i int) -> TerminalNode {
//
//	for j := 0; j < len(prc.children); j++ {
//		child := prc.children[j]
//		if c2, ok := child.(TerminalNode); ok {
//			if c2.GetSymbol().GetTokenType() == ttype {
//				if i == 0 {
//					return c2
//				}
//
//				i--
//			}
//		}
//	}
//	return nil
//}
//
//pub fn GetTokens(ttype int) -> []TerminalNode {
//	if prc.children == nil {
//		return make([]TerminalNode, 0)
//	}
//
//	tokens := make([]TerminalNode, 0)
//
//	for j := 0; j < len(prc.children); j++ {
//		child := prc.children[j]
//		if tchild, ok := child.(TerminalNode); ok {
//			if tchild.GetSymbol().GetTokenType() == ttype {
//				tokens = append(tokens, tchild)
//			}
//		}
//	}
//
//	return tokens
//}
//
//pub fn GetPayload() -> interface{} {
//	return prc
//}
//
//pub fn getChild(ctxType reflect.Type, i int) -> RuleContext {
//	if prc.children == nil || i < 0 || i >= len(prc.children) {
//		return nil
//	}
//
//	j := -1 // what element have we found with ctxType?
//	for _, o := range prc.children {
//
//		childType := reflect.TypeOf(o)
//
//		if childType.Implements(ctxType) {
//			j++
//			if j == i {
//				return o.(RuleContext)
//			}
//		}
//	}
//	return nil
//}
//
//// Go lacks generics, so it's not possible for us to return the child with the correct type, but we do
//// check for convertibility
//
//pub fn GetTypedRuleContext(ctxType reflect.Type, i int) -> RuleContext {
//	return prc.getChild(ctxType, i)
//}
//
//pub fn GetTypedRuleContexts(ctxType reflect.Type) -> []RuleContext {
//	if prc.children == nil {
//		return make([]RuleContext, 0)
//	}
//
//	contexts := make([]RuleContext, 0)
//
//	for _, child := range prc.children {
//		childType := reflect.TypeOf(child)
//
//		if childType.ConvertibleTo(ctxType) {
//			contexts = append(contexts, child.(RuleContext))
//		}
//	}
//	return contexts
//}
//
//pub fn GetChildCount() -> int {
//	if prc.children == nil {
//		return 0
//	}
//
//	return len(prc.children)
//}
//
//pub fn GetSourceInterval() -> *Interval {
//	if prc.start == nil || prc.stop == nil {
//		return TreeInvalidInterval
//	}
//
//	return NewInterval(prc.start.GetTokenIndex(), prc.stop.GetTokenIndex())
//}
//
////need to manage circular dependencies, so export now
//
//// Print out a whole tree, not just a node, in LISP format
//// (root child1 .. childN). Print just a node if b is a leaf.
////
//
//pub fn String(ruleNames []string, stop RuleContext) -> string {
//
//	var p ParserRuleContext = prc
//	s := "["
//	for p != nil && p != stop {
//		if ruleNames == nil {
//			if !p.IsEmpty() {
//				s += strconv.Itoa(p.GetInvokingState())
//			}
//		} else {
//			ri := p.GetRuleIndex()
//			var ruleName string
//			if ri >= 0 && ri < len(ruleNames) {
//				ruleName = ruleNames[ri]
//			} else {
//				ruleName = strconv.Itoa(ri)
//			}
//			s += ruleName
//		}
//		if p.GetParent() != nil && (ruleNames != nil || !p.GetParent().(ParserRuleContext).IsEmpty()) {
//			s += " "
//		}
//		pi := p.GetParent()
//		if pi != nil {
//			p = pi.(ParserRuleContext)
//		} else {
//			p = nil
//		}
//	}
//	s += "]"
//	return s
//}
//
//var RuleContextEmpty = NewBaseParserRuleContext(nil, -1)
//
//pub trait InterpreterRuleContext {
//	ParserRuleContext
//}
//
//pub struct BaseInterpreterRuleContext {
//	*BaseParserRuleContext
//}
//
//impl BaseInterpreterRuleContext {ยง//  pub fn new(parent BaseInterpreterRuleContext, invokingStateNumber, ruleIndex int) *BaseInterpreterRuleContext {
//
//	prc := new(BaseInterpreterRuleContext)
//
//	prc.BaseParserRuleContext = NewBaseParserRuleContext(parent, invokingStateNumber)
//
//	prc.RuleIndex = ruleIndex
//
//	return prc
//}
