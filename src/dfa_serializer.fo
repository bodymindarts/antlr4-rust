//package antlr
//
//import (
//  "fmt"
//  "strconv"
//)
//
//// DFASerializer is a DFA walker that knows how to dump them to serialized
//// &strs.
//pub struct DFASerializer {
//  dfa:           *DFA
//  literalNames  []string
//  symbolicNames []string
//}
//
//impl DFASerializer {ยง//  pub fn new(&self, dfa *DFA,: literalNames, symbolicNames []string) -> *DFASerializer {
//  if literalNames == nil {
//    literalNames = make([]string, 0)
//  }
//
//  if symbolicNames == nil {
//    symbolicNames = make([]string, 0)
//  }
//
//  return &DFASerializer{
//    dfa:           dfa,
//    literalNames:  literalNames,
//    symbolicNames: symbolicNames,
//  }
//}
//
//pub fn String(&self, ) -> &str {
//  if d.dfa.s0 == nil {
//    return ""
//  }
//
//  buf := ""
//  states := d.dfa.sortedStates()
//
//  for _, s := range states {
//    if s.edges != nil {
//      n := len(s.edges)
//
//      for j := 0; j < n; j++ {
//        t := s.edges[j]
//
//        if t != nil && t.stateNumber != 0x7FFFFFFF {
//          buf += d.GetStateString(s)
//          buf += "-"
//          buf += d.getEdgeLabel(j)
//          buf += "->"
//          buf += d.GetStateString(t)
//          buf += "\n"
//        }
//      }
//    }
//  }
//
//  if len(buf) == 0 {
//    return ""
//  }
//
//  return buf
//}
//
//pub fn getEdgeLabel(&self, i: i32) -> &str {
//  if i == 0 {
//    return "EOF"
//  } else if d.literalNames != nil && i-1 < len(d.literalNames) {
//    return d.literalNames[i-1]
//  } else if d.symbolicNames != nil && i-1 < len(d.symbolicNames) {
//    return d.symbolicNames[i-1]
//  }
//
//  return strconv.Itoa(i - 1)
//}
//
//pub fn GetStateString(&self, s *DFAState) -> &str {
//  var a, b &str
//
//  if s.isAcceptState {
//    a = ":"
//  }
//
//  if s.requiresFullContext {
//    b = "^"
//  }
//
//  baseStateStr := a + "s" + strconv.Itoa(s.stateNumber) + b
//
//  if s.isAcceptState {
//    if s.predicates != nil {
//      return baseStateStr + "=>" + fmt.Sprint(s.predicates)
//    }
//
//    return baseStateStr + "=>" + fmt.Sprint(s.prediction)
//  }
//
//  return baseStateStr
//}
//
//pub struct LexerDFASerializer {
//  *DFASerializer
//}
//
//impl LexerDFASerializer {ยง//  pub fn new(&self, dfa *DFA) -> *LexerDFASerializer {
//  return &LexerDFASerializer{DFASerializer: NewDFASerializer(dfa, nil, nil)}
//}
//
//pub fn getEdgeLabel(&self, i: i32) -> &str {
//  return "'" + &str(i) + "'"
//}
//
//pub fn String(&self, ) -> &str {
//  if l.dfa.s0 == nil {
//    return ""
//  }
//
//  buf := ""
//  states := l.dfa.sortedStates()
//
//  for i := 0; i < len(states); i++ {
//    s := states[i]
//
//    if s.edges != nil {
//      n := len(s.edges)
//
//      for j := 0; j < n; j++ {
//        t := s.edges[j]
//
//        if t != nil && t.stateNumber != 0x7FFFFFFF {
//          buf += l.GetStateString(s)
//          buf += "-"
//          buf += l.getEdgeLabel(j)
//          buf += "->"
//          buf += l.GetStateString(t)
//          buf += "\n"
//        }
//      }
//    }
//  }
//
//  if len(buf) == 0 {
//    return ""
//  }
//
//  return buf
//}
