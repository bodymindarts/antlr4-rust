//package antlr
//
//import (
//  "fmt"
//  "strconv"
//)
//
//// DFASerializer is a DFA walker that knows how to dump them to serialized
//// &strs.
//pub struct DFASerializer {
//  dfa:           *DFA
//  literal_names  []string
//  symbolic_names []string
//}
//
//impl DFASerializer {ยง//  pub fn new(&self, dfa *DFA,: literal_names, symbolic_names []string) -> *DFASerializer {
//  if literal_names == nil {
//    literal_names = make([]string, 0)
//  }
//
//  if symbolic_names == nil {
//    symbolic_names = make([]string, 0)
//  }
//
//  return &DFASerializer{
//    dfa:           dfa,
//    literal_names:  literal_names,
//    symbolic_names: symbolic_names,
//  }
//}
//
//pub fn String(&self, ) -> &str {
//  if d.dfa.s0 == nil {
//    return ""
//  }
//
//  let buf = "";
//  let states = d.dfa.sorted_states();
//
//  for _, let s = range states {;
//    if s.edges != nil {
//      let n = len(s.edges);
//
//      for let j = 0; j < n; j++ {;
//        let t = s.edges[j];
//
//        if t != nil && t.state_number != 0x7FFFFFFF {
//          buf += d.GetStateString(s)
//          buf += "-"
//          buf += d.get_edge_label(j)
//          buf += "->"
//          buf += d.GetStateString(t)
//          buf += "\n"
//        }
//      }
//    }
//  }
//
//  if len(buf) == 0 {
//    return ""
//  }
//
//  return buf
//}
//
//pub fn get_edge_label(&self, i: i32) -> &str {
//  if i == 0 {
//    return "EOF"
//  } else if d.literal_names != nil && i-1 < len(d.literal_names) {
//    return d.literal_names[i-1]
//  } else if d.symbolic_names != nil && i-1 < len(d.symbolic_names) {
//    return d.symbolic_names[i-1]
//  }
//
//  return strconv.Itoa(i - 1)
//}
//
//pub fn GetStateString(&self, s *DFAState) -> &str {
//  var a, b &str
//
//  if s.is_accept_state {
//    a = ":"
//  }
//
//  if s.requires_full_context {
//    b = "^"
//  }
//
//  let base_state_str = a + "s" + strconv.Itoa(s.state_number) + b;
//
//  if s.is_accept_state {
//    if s.predicates != nil {
//      return base_state_str + "=>" + fmt.Sprint(s.predicates)
//    }
//
//    return base_state_str + "=>" + fmt.Sprint(s.prediction)
//  }
//
//  return base_state_str
//}
//
//pub struct LexerDFASerializer {
//  *DFASerializer
//}
//
//impl LexerDFASerializer {ยง//  pub fn new(&self, dfa *DFA) -> *LexerDFASerializer {
//  return &LexerDFASerializer{DFASerializer: NewDFASerializer(dfa, nil, nil)}
//}
//
//pub fn get_edge_label(&self, i: i32) -> &str {
//  return "'" + &str(i) + "'"
//}
//
//pub fn String(&self, ) -> &str {
//  if l.dfa.s0 == nil {
//    return ""
//  }
//
//  let buf = "";
//  let states = l.dfa.sorted_states();
//
//  for let i = 0; i < len(states); i++ {;
//    let s = states[i];
//
//    if s.edges != nil {
//      let n = len(s.edges);
//
//      for let j = 0; j < n; j++ {;
//        let t = s.edges[j];
//
//        if t != nil && t.state_number != 0x7FFFFFFF {
//          buf += l.GetStateString(s)
//          buf += "-"
//          buf += l.get_edge_label(j)
//          buf += "->"
//          buf += l.GetStateString(t)
//          buf += "\n"
//        }
//      }
//    }
//  }
//
//  if len(buf) == 0 {
//    return ""
//  }
//
//  return buf
//}
