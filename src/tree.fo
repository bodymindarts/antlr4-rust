//package antlr
//
//// The basic notion of a tree has a parent, a payload, and a list of children.
////  It is the most abstract interface for all the trees used by ANTLR.
/////
//
//var TreeInvalidInterval = NewInterval(-1, -2)
//
//pub trait Tree {
//	GetParent() Tree
//	SetParent(Tree)
//	GetPayload() interface{}
//	GetChild(i int) Tree
//	GetChildCount() int
//	GetChildren() []Tree
//}
//
//pub trait SyntaxTree {
//	Tree
//
//	GetSourceInterval() *Interval
//}
//
//pub trait ParseTree {
//	SyntaxTree
//
//	Accept(Visitor ParseTreeVisitor) interface{}
//	GetText() string
//
//	ToStringTree([]string, Recognizer) string
//}
//
//pub trait RuleNode {
//	ParseTree
//
//	GetRuleContext() RuleContext
//	GetBaseRuleContext() *BaseRuleContext
//}
//
//pub trait TerminalNode {
//	ParseTree
//
//	GetSymbol() Token
//}
//
//pub trait ErrorNode {
//	TerminalNode
//
//	errorNode()
//}
//
//pub trait ParseTreeVisitor {
//	Visit(tree ParseTree) interface{}
//	VisitChildren(node RuleNode) interface{}
//	VisitTerminal(node TerminalNode) interface{}
//	VisitErrorNode(node ErrorNode) interface{}
//}
//
//pub struct BaseParseTreeVisitor{}
//
//var _ ParseTreeVisitor = &BaseParseTreeVisitor{}
//
//pub fn Visit(tree ParseTree) -> interface{}            { return nil }
//pub fn VisitChildren(node RuleNode) -> interface{}     { return nil }
//pub fn VisitTerminal(node TerminalNode) -> interface{} { return nil }
//pub fn VisitErrorNode(node ErrorNode) -> interface{}   { return nil }
//
//// TODO
////pub fn Visit(ctx) -> {
////	if (Utils.isArray(ctx)) {
////		self := this
////		return ctx.map(function(child) { return VisitAtom(self, child)})
////	} else {
////		return VisitAtom(this, ctx)
////	}
////}
////
////func VisitAtom(Visitor, ctx) {
////	if (ctx.parser == nil) { //is terminal
////		return
////	}
////
////	name := ctx.parser.ruleNames[ctx.ruleIndex]
////	funcName := "Visit" + Utils.titleCase(name)
////
////	return Visitor[funcName](ctx)
////}
//
//pub trait ParseTreeListener {
//	VisitTerminal(node TerminalNode)
//	VisitErrorNode(node ErrorNode)
//	EnterEveryRule(ctx ParserRuleContext)
//	ExitEveryRule(ctx ParserRuleContext)
//}
//
//pub struct BaseParseTreeListener{}
//
//var _ ParseTreeListener = &BaseParseTreeListener{}
//
//pub fn VisitTerminal(node TerminalNode) ->      {}
//pub fn VisitErrorNode(node ErrorNode) ->        {}
//pub fn EnterEveryRule(ctx ParserRuleContext) -> {}
//pub fn ExitEveryRule(ctx ParserRuleContext) ->  {}
//
//pub struct TerminalNodeImpl {
//	parentCtx RuleContext
//
//	symbol Token
//}
//
//var _ TerminalNode = &TerminalNodeImpl{}
//
//impl TerminalNodeImpl {ยง//  pub fn new(symbol Token) *TerminalNodeImpl {
//	tn := new(TerminalNodeImpl)
//
//	tn.parentCtx = nil
//	tn.symbol = symbol
//
//	return tn
//}
//
//pub fn GetChild(i int) -> Tree {
//	return nil
//}
//
//pub fn GetChildren() -> []Tree {
//	return nil
//}
//
//pub fn SetChildren(tree []Tree) -> {
//	panic("Cannot set children on terminal node")
//}
//
//pub fn GetSymbol() -> Token {
//	return t.symbol
//}
//
//pub fn GetParent() -> Tree {
//	return t.parentCtx
//}
//
//pub fn SetParent(tree Tree) -> {
//	t.parentCtx = tree.(RuleContext)
//}
//
//pub fn GetPayload() -> interface{} {
//	return t.symbol
//}
//
//pub fn GetSourceInterval() -> *Interval {
//	if t.symbol == nil {
//		return TreeInvalidInterval
//	}
//	tokenIndex := t.symbol.GetTokenIndex()
//	return NewInterval(tokenIndex, tokenIndex)
//}
//
//pub fn GetChildCount() -> int {
//	return 0
//}
//
//pub fn Accept(v ParseTreeVisitor) -> interface{} {
//	return v.VisitTerminal(t)
//}
//
//pub fn GetText() -> string {
//	return t.symbol.GetText()
//}
//
//pub fn String() -> string {
//	if t.symbol.GetTokenType() == TokenEOF {
//		return "<EOF>"
//	}
//
//	return t.symbol.GetText()
//}
//
//pub fn ToStringTree(s []string, r Recognizer) -> string {
//	return t.String()
//}
//
//// Represents a token that was consumed during reSynchronization
//// rather than during a valid Match operation. For example,
//// we will create this kind of a node during single token insertion
//// and deletion as well as during "consume until error recovery set"
//// upon no viable alternative exceptions.
//
//pub struct ErrorNodeImpl {
//	*TerminalNodeImpl
//}
//
//var _ ErrorNode = &ErrorNodeImpl{}
//
//impl ErrorNodeImpl {ยง//  pub fn new(token Token) *ErrorNodeImpl {
//	en := new(ErrorNodeImpl)
//	en.TerminalNodeImpl = NewTerminalNodeImpl(token)
//	return en
//}
//
//pub fn errorNode() -> {}
//
//pub fn Accept(v ParseTreeVisitor) -> interface{} {
//	return v.VisitErrorNode(e)
//}
//
//pub struct ParseTreeWalker {
//}
//
//impl ParseTreeWalker {ยง//  pub fn new() *ParseTreeWalker {
//	return new(ParseTreeWalker)
//}
//
//pub fn Walk(listener ParseTreeListener, t Tree) -> {
//	switch tt := t.(type) {
//	case ErrorNode:
//		listener.VisitErrorNode(tt)
//	case TerminalNode:
//		listener.VisitTerminal(tt)
//	default:
//		p.EnterRule(listener, t.(RuleNode))
//		for i := 0; i < t.GetChildCount(); i++ {
//			child := t.GetChild(i)
//			p.Walk(listener, child)
//		}
//		p.ExitRule(listener, t.(RuleNode))
//	}
//}
//
////
//// The discovery of a rule node, involves sending two events: the generic
//// {@link ParseTreeListener//EnterEveryRule} and a
//// {@link RuleContext}-specific event. First we trigger the generic and then
//// the rule specific. We to them in reverse order upon finishing the node.
////
//pub fn EnterRule(listener ParseTreeListener, r RuleNode) -> {
//	ctx := r.GetRuleContext().(ParserRuleContext)
//	listener.EnterEveryRule(ctx)
//	ctx.EnterRule(listener)
//}
//
//pub fn ExitRule(listener ParseTreeListener, r RuleNode) -> {
//	ctx := r.GetRuleContext().(ParserRuleContext)
//	ctx.ExitRule(listener)
//	listener.ExitEveryRule(ctx)
//}
//
//var ParseTreeWalkerDefault = NewParseTreeWalker()
