//package antlr
//
//import (
//  "fmt"
//  "strconv"
//)
//
//pub trait Parser {
//  Recognizer
//
//  GetInterpreter() *ParserATNSimulator
//
//  GetTokenStream() TokenStream
//  GetTokenFactory() TokenFactory
//  GetParserRuleContext() ParserRuleContext
//  SetParserRuleContext(ParserRuleContext)
//  Consume() Token
//  GetParseListeners() []ParseTreeListener
//
//  GetErrorHandler() ErrorStrategy
//  SetErrorHandler(ErrorStrategy)
//  GetInputStream() IntStream
//  GetCurrentToken() Token
//  GetExpectedTokens() *IntervalSet
//  NotifyErrorListeners(string, Token, RecognitionException)
//  IsExpectedToken(int) bool
//  GetPrecedence() i32
//  GetRuleInvocationStack(ParserRuleContext) []string
//}
//
//pub struct BaseParser {
//  *BaseRecognizer
//
//  Interpreter:     *ParserATNSimulator
//  BuildParseTrees: bool
//
//  input:           TokenStream
//  err_handler:      ErrorStrategy
//  precedence_stack: IntStack
//  ctx:             ParserRuleContext
//
//  tracer:         *TraceListener
//  parse_listeners []ParseTreeListener
//  _SyntaxErrors  i32
//}
//
//// p.is all the parsing support code essentially most of it is error
//// recovery stuff.//
//impl BaseParser {ยง//  pub fn new(&self, input: TokenStream) -> *BaseParser {
//
//  let p = new(BaseParser);
//
//  p.BaseRecognizer = NewBaseRecognizer()
//
//  // The input stream.
//  p.input = nil
//  // The error handling strategy for the parser. The default value is a new
//  // instance of {@link DefaultErrorStrategy}.
//  p.err_handler = NewDefaultErrorStrategy()
//  p.precedence_stack = make([]int, 0)
//  p.precedence_stack.Push(0)
//  // The {@link ParserRuleContext} object for the currently executing rule.
//  // p.is always non-nil during the parsing process.
//  p.ctx = nil
//  // Specifies whether or not the parser should construct a parse tree during
//  // the parsing process. The default value is {@code true}.
//  p.BuildParseTrees = true
//  // When {@link //setTrace}{@code (true)} is called, a reference to the
//  // {@link TraceListener} is stored here so it can be easily removed in a
//  // later call to {@link //setTrace}{@code (false)}. The listener itself is
//  // implemented as a parser listener so p.field is not directly used by
//  // other parser methods.
//  p.tracer = nil
//  // The list of {@link ParseTreeListener} listeners registered to receive
//  // events during the parse.
//  p.parse_listeners = nil
//  // The number of syntax errors Reported during parsing. p.value is
//  // incremented each time {@link //NotifyErrorListeners} is called.
//  p._SyntaxErrors = 0
//  p.SetInputStream(input)
//
//  return p
//}
//
//// p.field maps from the serialized ATN &str to the deserialized {@link
//// ATN} with
//// bypass alternatives.
////
//// @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()
////
//var bypass_alts_atn_cache = make(map[string]int)
//
//// reset the parser's state//
//pub fn reset(&self, ) {
//  if p.input != nil {
//    p.input.Seek(0)
//  }
//  p.err_handler.reset(p)
//  p.ctx = nil
//  p._SyntaxErrors = 0
//  p.SetTrace(nil)
//  p.precedence_stack = make([]int, 0)
//  p.precedence_stack.Push(0)
//  if p.Interpreter != nil {
//    p.Interpreter.reset()
//  }
//}
//
//pub fn GetErrorHandler(&self, ) -> ErrorStrategy {
//  return p.err_handler
//}
//
//pub fn SetErrorHandler(&self, e: ErrorStrategy) {
//  p.err_handler = e
//}
//
//// Match current input symbol against {@code ttype}. If the symbol type
//// Matches, {@link ANTLRErrorStrategy//ReportMatch} and {@link //consume} are
//// called to complete the Match process.
////
//// <p>If the symbol type does not Match,
//// {@link ANTLRErrorStrategy//recoverInline} is called on the current error
//// strategy to attempt recovery. If {@link //getBuildParseTree} is
//// {@code true} and the token index of the symbol returned by
//// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
//// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
////
//// @param ttype the token type to Match
//// @return the Matched symbol
//// @panics RecognitionException if the current input symbol did not Match
//// {@code ttype} and the error strategy could not recover from the
//// mismatched symbol
//
//pub fn Match(&self, ttype: i32) -> Token {
//
//  let t = p.GetCurrentToken();
//
//  if t.GetTokenType() == ttype {
//    p.err_handler.ReportMatch(p)
//    p.Consume()
//  } else {
//    t = p.err_handler.RecoverInline(p)
//    if p.BuildParseTrees && t.GetTokenIndex() == -1 {
//      // we must have conjured up a Newtoken during single token
//      // insertion
//      // if it's not the current symbol
//      p.ctx.AddErrorNode(t)
//    }
//  }
//
//  return t
//}
//
//// Match current input symbol as a wildcard. If the symbol type Matches
//// (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//ReportMatch}
//// and {@link //consume} are called to complete the Match process.
////
//// <p>If the symbol type does not Match,
//// {@link ANTLRErrorStrategy//recoverInline} is called on the current error
//// strategy to attempt recovery. If {@link //getBuildParseTree} is
//// {@code true} and the token index of the symbol returned by
//// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
//// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
////
//// @return the Matched symbol
//// @panics RecognitionException if the current input symbol did not Match
//// a wildcard and the error strategy could not recover from the mismatched
//// symbol
//
//pub fn MatchWildcard(&self, ) -> Token {
//  let t = p.GetCurrentToken();
//  if t.GetTokenType() > 0 {
//    p.err_handler.ReportMatch(p)
//    p.Consume()
//  } else {
//    t = p.err_handler.RecoverInline(p)
//    if p.BuildParseTrees && t.GetTokenIndex() == -1 {
//      // we must have conjured up a Newtoken during single token
//      // insertion
//      // if it's not the current symbol
//      p.ctx.AddErrorNode(t)
//    }
//  }
//  return t
//}
//
//pub fn GetParserRuleContext(&self, ) -> ParserRuleContext {
//  return p.ctx
//}
//
//pub fn SetParserRuleContext(&self, v: ParserRuleContext) {
//  p.ctx = v
//}
//
//pub fn GetParseListeners(&self, ) -> []ParseTreeListener {
//  if p.parse_listeners == nil {
//    return make([]ParseTreeListener, 0)
//  }
//  return p.parse_listeners
//}
//
//// Registers {@code listener} to receive events during the parsing process.
////
//// <p>To support output-preserving grammar transformations (including but not
//// limited to left-recursion removal, automated left-factoring, and
//// optimized code generation), calls to listener methods during the parse
//// may differ substantially from calls made by
//// {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
//// particular, rule entry and exit events may occur in a different order
//// during the parse than after the parser. In addition, calls to certain
//// rule entry methods may be omitted.</p>
////
//// <p>With the following specific exceptions, calls to listener events are
//// <em>deterministic</em>, i.e. for identical input the calls to listener
//// methods will be the same.</p>
////
//// <ul>
//// <li>Alterations to the grammar used to generate code may change the
//// behavior of the listener calls.</li>
//// <li>Alterations to the command line options passed to ANTLR 4 when
//// generating the parser may change the behavior of the listener calls.</li>
//// <li>Changing the version of the ANTLR Tool used to generate the parser
//// may change the behavior of the listener calls.</li>
//// </ul>
////
//// @param listener the listener to add
////
//// @panics nil_pointer_exception if {@code} listener is {@code nil}
////
//pub fn AddParseListener(&self, listener: ParseTreeListener) {
//  if listener == nil {
//    panic("listener")
//  }
//  if p.parse_listeners == nil {
//    p.parse_listeners = make([]ParseTreeListener, 0)
//  }
//  p.parse_listeners = append(p.parse_listeners, listener)
//}
//
////
//// Remove {@code listener} from the list of parse listeners.
////
//// <p>If {@code listener} is {@code nil} or has not been added as a parse
//// listener, p.method does nothing.</p>
//// @param listener the listener to remove
////
//pub fn RemoveParseListener(&self, listener: ParseTreeListener) {
//
//  if p.parse_listeners != nil {
//
//    let idx = -1;
//    for i, let v = range p.parse_listeners {;
//      if v == listener {
//        idx = i
//        break
//      }
//    }
//
//    if idx == -1 {
//      return
//    }
//
//    // remove the listener from the slice
//    p.parse_listeners = append(p.parse_listeners[0:idx], p.parse_listeners[idx+1:]...)
//
//    if len(p.parse_listeners) == 0 {
//      p.parse_listeners = nil
//    }
//  }
//}
//
//// Remove all parse listeners.
//pub fn remove_parse_listeners(&self, ) {
//  p.parse_listeners = nil
//}
//
//// Notify any parse listeners of an enter rule event.
//pub fn TriggerEnterRuleEvent(&self, ) {
//  if p.parse_listeners != nil {
//    let ctx = p.ctx;
//    for _, let listener = range p.parse_listeners {;
//      listener.EnterEveryRule(ctx)
//      ctx.EnterRule(listener)
//    }
//  }
//}
//
////
//// Notify any parse listeners of an exit rule event.
////
//// @see //addParseListener
////
//pub fn TriggerExitRuleEvent(&self, ) {
//  if p.parse_listeners != nil {
//    // reverse order walk of listeners
//    let ctx = p.ctx;
//    let l = len(p.parse_listeners) - 1;
//
//    for let i = range p.parse_listeners {;
//      let listener = p.parse_listeners[l-i];
//      ctx.ExitRule(listener)
//      listener.ExitEveryRule(ctx)
//    }
//  }
//}
//
//pub fn GetInterpreter(&self, ) -> *ParserATNSimulator {
//  return p.Interpreter
//}
//
//pub fn GetATN(&self, ) -> *ATN {
//  return p.Interpreter.atn
//}
//
//pub fn GetTokenFactory(&self, ) -> TokenFactory {
//  return p.input.GetTokenSource().GetTokenFactory()
//}
//
//// Tell our token source and error strategy about a Newway to create tokens.//
//pub fn set_token_factory(&self, factory: TokenFactory) {
//  p.input.GetTokenSource().set_token_factory(factory)
//}
//
//// The ATN with bypass alternatives is expensive to create so we create it
//// lazily.
////
//// @panics UnsupportedOperationException if the current parser does not
//// implement the {@link //getSerializedATN()} method.
////
//pub fn GetATNWithBypassAlts(&self, ) {
//
//  // TODO
//  panic("Not implemented!")
//
//  //  let serialized_atn = p.get_serialized_a_t_n();
//  //  if (serializedAtn == nil) {
//  //    panic("The current parser does not support an ATN with bypass alternatives.")
//  //  }
//  //  let result = p.bypass_alts_atn_cache[serializedAtn];
//  //  if (result == nil) {
//  //    let deserialization_options = NewATNDeserializationOptions(nil);
//  //    deserialization_options.generate_rule_bypass_transitions = true
//  //    result = NewATNDeserializer(deserializationOptions).deserialize(serializedAtn)
//  //    p.bypass_alts_atn_cache[serializedAtn] = result
//  //  }
//  //  return result
//}
//
//// The preferred method of getting a tree pattern. For example, here's a
//// sample use:
////
//// <pre>
//// ParseTree t = parser.expr()
//// ParseTreePattern p = parser.compile_parse_tree_pattern("&ltID&gt+0",
//// MyParser.RULE_expr)
//// ParseTreeMatch m = p.Match(t)
//// String id = m.Get("ID")
//// </pre>
//
//pub fn compile_parse_tree_pattern(&self, pattern,: pattern_rule_index, lexer: Lexer) {
//
//  panic("NewParseTreePatternMatcher not implemented!")
//  //
//  //  if (lexer == nil) {
//  //    if (p.GetTokenStream() != nil) {
//  //      let token_source = p.GetTokenStream().GetTokenSource();
//  //      if _, let ok = token_source.(ILexer); ok {;
//  //        lexer = token_source
//  //      }
//  //    }
//  //  }
//  //  if (lexer == nil) {
//  //    panic("Parser can't discover a lexer to use")
//  //  }
//
//  //  let m = NewParseTreePatternMatcher(lexer, p);
//  //  return m.compile(pattern, pattern_rule_index)
//}
//
//pub fn GetInputStream(&self, ) -> IntStream {
//  return p.GetTokenStream()
//}
//
//pub fn SetInputStream(&self, input: TokenStream) {
//  p.SetTokenStream(input)
//}
//
//pub fn GetTokenStream(&self, ) -> TokenStream {
//  return p.input
//}
//
//// Set the token stream and reset the parser.//
//pub fn SetTokenStream(&self, input: TokenStream) {
//  p.input = nil
//  p.reset()
//  p.input = input
//}
//
//// Match needs to return the current input symbol, which gets put
//// i32o the label for the associated token ref e.g., x=ID.
////
//pub fn GetCurrentToken(&self, ) -> Token {
//  return p.input.LT(1)
//}
//
//pub fn NotifyErrorListeners(&self, msg &str, offending_token: Token, err: RecognitionException) {
//  if offending_token == nil {
//    offending_token = p.GetCurrentToken()
//  }
//  p._SyntaxErrors++
//  let line = offending_token.GetLine();
//  let column = offending_token.GetColumn();
//  let listener = p.GetErrorListenerDispatch();
//  listener.SyntaxError(p, offending_token, line, column, msg, err)
//}
//
//pub fn Consume(&self, ) -> Token {
//  let o = p.GetCurrentToken();
//  if o.GetTokenType() != TokenEOF {
//    p.GetInputStream().Consume()
//  }
//  let has_listener = p.parse_listeners != nil && len(p.parse_listeners) > 0;
//  if p.BuildParseTrees || has_listener {
//    if p.err_handler.in_error_recovery_mode(p) {
//      let node = p.ctx.AddErrorNode(o);
//      if p.parse_listeners != nil {
//        for _, let l = range p.parse_listeners {;
//          l.VisitErrorNode(node)
//        }
//      }
//
//    } else {
//      let node = p.ctx.AddTokenNode(o);
//      if p.parse_listeners != nil {
//        for _, let l = range p.parse_listeners {;
//          l.VisitTerminal(node)
//        }
//      }
//    }
//    //        node.invoking_state = p.state
//  }
//
//  return o
//}
//
//pub fn add_context_to_parse_tree(&self, ) {
//  // add current context to parent if we have a parent
//  if p.ctx.GetParent() != nil {
//    p.ctx.GetParent().(ParserRuleContext).AddChild(p.ctx)
//  }
//}
//
//pub fn EnterRule(&self, localctx ParserRuleContext,: state, rule_index: i32) {
//  p.SetState(state)
//  p.ctx = localctx
//  p.ctx.SetStart(p.input.LT(1))
//  if p.BuildParseTrees {
//    p.add_context_to_parse_tree()
//  }
//  if p.parse_listeners != nil {
//    p.TriggerEnterRuleEvent()
//  }
//}
//
//pub fn ExitRule(&self, ) {
//  p.ctx.SetStop(p.input.LT(-1))
//  // trigger event on ctx, before it reverts to parent
//  if p.parse_listeners != nil {
//    p.TriggerExitRuleEvent()
//  }
//  p.SetState(p.ctx.GetInvokingState())
//  if p.ctx.GetParent() != nil {
//    p.ctx = p.ctx.GetParent().(ParserRuleContext)
//  } else {
//    p.ctx = nil
//  }
//}
//
//pub fn EnterOuterAlt(&self, localctx: ParserRuleContext, alt_num: i32) {
//  localctx.SetAltNumber(altNum)
//  // if we have Newlocalctx, make sure we replace existing ctx
//  // that is previous child of parse tree
//  if p.BuildParseTrees && p.ctx != localctx {
//    if p.ctx.GetParent() != nil {
//      p.ctx.GetParent().(ParserRuleContext).RemoveLastChild()
//      p.ctx.GetParent().(ParserRuleContext).AddChild(localctx)
//    }
//  }
//  p.ctx = localctx
//}
//
//// Get the precedence level for the top-most precedence rule.
////
//// @return The precedence level for the top-most precedence rule, or -1 if
//// the parser context is not nested within a precedence rule.
//
//pub fn GetPrecedence(&self, ) -> i32 {
//  if len(p.precedence_stack) == 0 {
//    return -1
//  }
//
//  return p.precedence_stack[len(p.precedence_stack)-1]
//}
//
//pub fn EnterRecursionRule(&self, localctx ParserRuleContext, state,: rule_index, precedence: i32) {
//  p.SetState(state)
//  p.precedence_stack.Push(precedence)
//  p.ctx = localctx
//  p.ctx.SetStart(p.input.LT(1))
//  if p.parse_listeners != nil {
//    p.TriggerEnterRuleEvent() // simulates rule entry for
//    // left-recursive rules
//  }
//}
//
////
//// Like {@link //EnterRule} but for recursive rules.
//
//pub fn PushNewRecursionContext(&self, localctx ParserRuleContext,: state, rule_index: i32) {
//  let previous = p.ctx;
//  previous.SetParent(localctx)
//  previous.SetInvokingState(state)
//  previous.SetStop(p.input.LT(-1))
//
//  p.ctx = localctx
//  p.ctx.SetStart(previous.GetStart())
//  if p.BuildParseTrees {
//    p.ctx.AddChild(previous)
//  }
//  if p.parse_listeners != nil {
//    p.TriggerEnterRuleEvent() // simulates rule entry for
//    // left-recursive rules
//  }
//}
//
//pub fn UnrollRecursionContexts(&self, parent_ctx: ParserRuleContext) {
//  p.precedence_stack.Pop()
//  p.ctx.SetStop(p.input.LT(-1))
//  let ret_ctx = p.ctx // save current ctx (return value);
//  // unroll so ctx is as it was before call to recursive method
//  if p.parse_listeners != nil {
//    for p.ctx != parent_ctx {
//      p.TriggerExitRuleEvent()
//      p.ctx = p.ctx.GetParent().(ParserRuleContext)
//    }
//  } else {
//    p.ctx = parent_ctx
//  }
//  // hook i32o tree
//  ret_ctx.SetParent(parentCtx)
//  if p.BuildParseTrees && parent_ctx != nil {
//    // add return ctx i32o invoking rule's tree
//    parent_ctx.AddChild(retCtx)
//  }
//}
//
//pub fn GetInvokingContext(&self, rule_index: i32) -> ParserRuleContext {
//  let ctx = p.ctx;
//  for ctx != nil {
//    if ctx.GetRuleIndex() == rule_index {
//      return ctx
//    }
//    ctx = ctx.GetParent().(ParserRuleContext)
//  }
//  return nil
//}
//
//pub fn Precpred(&self, localctx: RuleContext, precedence: i32) -> bool {
//  return precedence >= p.precedence_stack[len(p.precedence_stack)-1]
//}
//
//pub fn in_context(&self, context: ParserRuleContext) -> bool {
//  // TODO: useful in parser?
//  return false
//}
//
////
//// Checks whether or not {@code symbol} can follow the current state in the
//// ATN. The behavior of p.method is equivalent to the following, but is
//// implemented such that the complete context-sensitive follow set does not
//// need to be explicitly constructed.
////
//// <pre>
//// return get_expected_tokens().contains(symbol)
//// </pre>
////
//// @param symbol the symbol type to check
//// @return {@code true} if {@code symbol} can follow the current state in
//// the ATN, otherwise {@code false}.
//
//pub fn IsExpectedToken(&self, symbol: i32) -> bool {
//  let atn = p.Interpreter.atn;
//  let ctx = p.ctx;
//  let s = atn.states[p.state];
//  let following = atn.NextTokens(s, nil);
//  if following.contains(symbol) {
//    return true
//  }
//  if !following.contains(TokenEpsilon) {
//    return false
//  }
//  for ctx != nil && ctx.GetInvokingState() >= 0 && following.contains(TokenEpsilon) {
//    let invoking_state = atn.states[ctx.GetInvokingState()];
//    let rt = invoking_state.GetTransitions()[0];
//    following = atn.NextTokens(rt.(*RuleTransition).follow_state, nil)
//    if following.contains(symbol) {
//      return true
//    }
//    ctx = ctx.GetParent().(ParserRuleContext)
//  }
//  if following.contains(TokenEpsilon) && symbol == TokenEOF {
//    return true
//  }
//
//  return false
//}
//
//// Computes the set of input symbols which could follow the current parser
//// state and context, as given by {@link //GetState} and {@link //GetContext},
//// respectively.
////
//// @see ATN//getExpectedTokens(int, RuleContext)
////
//pub fn GetExpectedTokens(&self, ) -> *IntervalSet {
//  return p.Interpreter.atn.get_expected_tokens(p.state, p.ctx)
//}
//
//pub fn GetExpectedTokensWithinCurrentRule(&self, ) -> *IntervalSet {
//  let atn = p.Interpreter.atn;
//  let s = atn.states[p.state];
//  return atn.NextTokens(s, nil)
//}
//
//// Get a rule's index (i.e., {@code RULE_rule_name} field) or -1 if not found.//
//pub fn GetRuleIndex(&self, rule_name: &str) -> i32 {
//  var rule_index, ok = p.GetRuleIndexMap()[ruleName]
//  if ok {
//    return rule_index
//  }
//
//  return -1
//}
//
//// Return List&ltString&gt of the rule names in your parser instance
//// leading up to a call to the current rule. You could override if
//// you want more details such as the file/line info of where
//// in the ATN a rule is invoked.
////
//// this very useful for error messages.
//
//pub fn GetRuleInvocationStack(&self, c: ParserRuleContext) -> []string {
//  if c == nil {
//    c = p.ctx
//  }
//  let stack = make([]string, 0);
//  for c != nil {
//    // compute what follows who invoked us
//    let rule_index = c.GetRuleIndex();
//    if rule_index < 0 {
//      stack = append(stack, "n/a")
//    } else {
//      stack = append(stack, p.GetRuleNames()[ruleIndex])
//    }
//
//    let vp = c.GetParent();
//
//    if vp == nil {
//      break
//    }
//
//    c = vp.(ParserRuleContext)
//  }
//  return stack
//}
//
//// For debugging and other purposes.//
//pub fn GetDFAStrings(&self, ) -> &str {
//  return fmt.Sprint(p.Interpreter.decision_to_d_f_a)
//}
//
//// For debugging and other purposes.//
//pub fn DumpDFA(&self, ) {
//  let seen_one = false;
//  for _, let dfa = range p.Interpreter.decision_to_d_f_a {;
//    if len(dfa.GetStates()) > 0 {
//      if seen_one {
//        fmt.Println()
//      }
//      fmt.Println("Decision " + strconv.Itoa(dfa.decision) + ":")
//      fmt.Print(dfa.String(p.LiteralNames, p.SymbolicNames))
//      seen_one = true
//    }
//  }
//}
//
//pub fn GetSourceName(&self, ) -> &str {
//  return p.GrammarFileName
//}
//
//// During a parse is sometimes useful to listen in on the rule entry and exit
//// events as well as token Matches. p.is for quick and dirty debugging.
////
//pub fn SetTrace(&self, trace *TraceListener) {
//  if trace == nil {
//    p.RemoveParseListener(p.tracer)
//    p.tracer = nil
//  } else {
//    if p.tracer != nil {
//      p.RemoveParseListener(p.tracer)
//    }
//    p.tracer = NewTraceListener(p)
//    p.AddParseListener(p.tracer)
//  }
//}
