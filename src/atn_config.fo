//package antlr
//
//import (
//  "fmt"
//  "strconv"
//)
//
//pub trait Comparable {
//  equals(other i32erface{}) bool
//}
//
//// ATNConfig is a tuple: (ATN state, predicted alt, syntactic, semantic
//// context). The syntactic context is a graph-structured stack node whose
//// path(s) to the root is the rule invocation(s) chain used to arrive at the
//// state. The semantic context is the tree of semantic predicates encountered
//// before reaching an ATN state.
//pub trait ATNConfig {
//  Hasher
//  Comparable
//
//  GetState() ATNState
//  GetAlt() i32
//  GetSemanticContext() SemanticContext
//
//  GetContext() PredictionContext
//  SetContext(PredictionContext)
//
//  GetReachesIntoOuterContext() i32
//  SetReachesIntoOuterContext(int)
//
//  String() &str
//
//  getPrecedenceFilterSuppressed() bool
//  setPrecedenceFilterSuppressed(bool)
//
//  shortHash() &str
//}
//
//pub struct BaseATNConfig {
//  precedenceFilterSuppressed: bool
//  state:                      ATNState
//  alt:                        i32
//  context:                    PredictionContext
//  semanticContext:            SemanticContext
//  reachesIntoOuterContext:    i32
//}
//
//impl BaseATNConfig {§//  pub fn new7(old *BaseATNConfig) -> *BaseATNConfig { // TODO: Dup
//  return &BaseATNConfig{
//    state:                   old.state,
//    alt:                     old.alt,
//    context:                 old.context,
//    semanticContext:         old.semanticContext,
//    reachesIntoOuterContext: old.reachesIntoOuterContext,
//  }
//}
//
//impl BaseATNConfig {§//  pub fn new6(&self, state ATNState, alt: i32, context: PredictionContext) -> *BaseATNConfig {
//  return NewBaseATNConfig5(state, alt, context, SemanticContextNone)
//}
//
//impl BaseATNConfig {§//  pub fn new5(&self, state ATNState, alt i32, context: PredictionContext, semanticContext: SemanticContext) -> *BaseATNConfig {
//  if semanticContext == nil {
//    panic("semanticContext cannot be nil") // TODO: Necessary?
//  }
//
//  return &BaseATNConfig{state: state, alt: alt, context: context, semanticContext: semanticContext}
//}
//
//impl BaseATNConfig {§//  pub fn new4(&self, c: ATNConfig, state: ATNState) -> *BaseATNConfig {
//  return NewBaseATNConfig(c, state, c.GetContext(), c.GetSemanticContext())
//}
//
//impl BaseATNConfig {§//  pub fn new3(&self, c ATNConfig, state: ATNState, semanticContext: SemanticContext) -> *BaseATNConfig {
//  return NewBaseATNConfig(c, state, c.GetContext(), semanticContext)
//}
//
//impl BaseATNConfig {§//  pub fn new2(&self, c: ATNConfig, semanticContext: SemanticContext) -> *BaseATNConfig {
//  return NewBaseATNConfig(c, c.GetState(), c.GetContext(), semanticContext)
//}
//
//impl BaseATNConfig {§//  pub fn new1(&self, c ATNConfig, state: ATNState, context: PredictionContext) -> *BaseATNConfig {
//  return NewBaseATNConfig(c, state, context, c.GetSemanticContext())
//}
//
//impl BaseATNConfig {§//  pub fn new(&self, c ATNConfig, state ATNState, context: PredictionContext, semanticContext: SemanticContext) -> *BaseATNConfig {
//  if semanticContext == nil {
//    panic("semanticContext cannot be nil")
//  }
//
//  return &BaseATNConfig{
//    state:                   state,
//    alt:                     c.GetAlt(),
//    context:                 context,
//    semanticContext:         semanticContext,
//    reachesIntoOuterContext: c.GetReachesIntoOuterContext(),
//    precedenceFilterSuppressed: c.getPrecedenceFilterSuppressed(),
//  }
//}
//
//pub fn getPrecedenceFilterSuppressed(&self, ) -> bool {
//  return b.precedenceFilterSuppressed
//}
//
//pub fn setPrecedenceFilterSuppressed(&self, v: bool) {
//  b.precedenceFilterSuppressed = v
//}
//
//pub fn GetState(&self, ) -> ATNState {
//  return b.state
//}
//
//pub fn GetAlt(&self, ) -> i32 {
//  return b.alt
//}
//
//pub fn SetContext(&self, v: PredictionContext) {
//  b.context = v
//}
//pub fn GetContext(&self, ) -> PredictionContext {
//  return b.context
//}
//
//pub fn GetSemanticContext(&self, ) -> SemanticContext {
//  return b.semanticContext
//}
//
//pub fn GetReachesIntoOuterContext(&self, ) -> i32 {
//  return b.reachesIntoOuterContext
//}
//
//pub fn SetReachesIntoOuterContext(&self, v: i32) {
//  b.reachesIntoOuterContext = v
//}
//
//// An ATN configuration is equal to another if both have the same state, they
//// predict the same alternative, and syntactic/semantic contexts are the same.
//pub fn equals(&self, o i32erface{}) -> bool {
//  if b == o {
//    return true
//  }
//
//  var other, ok = o.(*BaseATNConfig)
//
//  if !ok {
//    return false
//  }
//
//  var equal bool
//
//  if b.context == nil {
//    equal = other.context == nil
//  } else {
//    equal = b.context.equals(other.context)
//  }
//
//  var (
//    nums = b.state.GetStateNumber() == other.state.GetStateNumber()
//    alts = b.alt == other.alt
//    cons = b.semanticContext.equals(other.semanticContext)
//    sups = b.precedenceFilterSuppressed == other.precedenceFilterSuppressed
//  )
//
//  return nums && alts && cons && sups && equal
//}
//
//pub fn shortHash(&self, ) -> &str {
//  return strconv.Itoa(b.state.GetStateNumber()) + "/" + strconv.Itoa(b.alt) + "/" + b.semanticContext.String()
//}
//
//pub fn Hash(&self, ) -> &str {
//  var c &str
//
//  if b.context == nil {
//    c = ""
//  } else {
//    c = b.context.Hash()
//  }
//
//  return strconv.Itoa(b.state.GetStateNumber()) + "/" + strconv.Itoa(b.alt) + "/" + c + "/" + b.semanticContext.String()
//}
//
//pub fn String(&self, ) -> &str {
//  var s1, s2, s3 &str
//
//  if b.context != nil {
//    s1 = ",[" + fmt.Sprint(b.context) + "]"
//  }
//
//  if b.semanticContext != SemanticContextNone {
//    s2 = "," + fmt.Sprint(b.semanticContext)
//  }
//
//  if b.reachesIntoOuterContext > 0 {
//    s3 = ",up=" + fmt.Sprint(b.reachesIntoOuterContext)
//  }
//
//  return fmt.Sprintf("(%v,%v%v%v%v)", b.state, b.alt, s1, s2, s3)
//}
//
//
//
//pub struct LexerATNConfig {
//  *BaseATNConfig
//  lexerActionExecutor:            *LexerActionExecutor
//  passedThroughNonGreedyDecision: bool
//}
//
//impl LexerATNConfig {§//  pub fn new6(&self, state ATNState, alt: i32, context: PredictionContext) -> *LexerATNConfig {
//  return &LexerATNConfig{BaseATNConfig: NewBaseATNConfig5(state, alt, context, SemanticContextNone)}
//}
//
//impl LexerATNConfig {§//  pub fn new5(&self, state ATNState, alt i32, context: PredictionContext, lexerActionExecutor *LexerActionExecutor) -> *LexerATNConfig {
//  return &LexerATNConfig{
//    BaseATNConfig:       NewBaseATNConfig5(state, alt, context, SemanticContextNone),
//    lexerActionExecutor: lexerActionExecutor,
//  }
//}
//
//impl LexerATNConfig {§//  pub fn new4(&self, c *LexerATNConfig, state: ATNState) -> *LexerATNConfig {
//  return &LexerATNConfig{
//    BaseATNConfig:                  NewBaseATNConfig(c, state, c.GetContext(), c.GetSemanticContext()),
//    lexerActionExecutor:            c.lexerActionExecutor,
//    passedThroughNonGreedyDecision: checkNonGreedyDecision(c, state),
//  }
//}
//
//impl LexerATNConfig {§//  pub fn new3(&self, c *LexerATNConfig, state: ATNState, lexerActionExecutor *LexerActionExecutor) -> *LexerATNConfig {
//  return &LexerATNConfig{
//    BaseATNConfig:                  NewBaseATNConfig(c, state, c.GetContext(), c.GetSemanticContext()),
//    lexerActionExecutor:            lexerActionExecutor,
//    passedThroughNonGreedyDecision: checkNonGreedyDecision(c, state),
//  }
//}
//
//impl LexerATNConfig {§//  pub fn new2(&self, c *LexerATNConfig, state: ATNState, context: PredictionContext) -> *LexerATNConfig {
//  return &LexerATNConfig{
//    BaseATNConfig:                  NewBaseATNConfig(c, state, context, c.GetSemanticContext()),
//    lexerActionExecutor:            c.lexerActionExecutor,
//    passedThroughNonGreedyDecision: checkNonGreedyDecision(c, state),
//  }
//}
//
//impl LexerATNConfig {§//  pub fn new1(&self, state ATNState, alt: i32, context: PredictionContext) -> *LexerATNConfig {
//  return &LexerATNConfig{BaseATNConfig: NewBaseATNConfig5(state, alt, context, SemanticContextNone)}
//}
//
//pub fn Hash(&self, ) -> &str {
//  var f &str
//
//  if l.passedThroughNonGreedyDecision {
//    f = "1"
//  } else {
//    f = "0"
//  }
//
//  return fmt.Sprintf("%v%v%v%v%v%v", l.state.GetStateNumber(), l.alt, l.context, l.semanticContext, f, l.lexerActionExecutor)
//}
//
//pub fn equals(&self, other i32erface{}) -> bool {
//  var othert, ok = other.(*LexerATNConfig)
//
//  if l == other {
//    return true
//  } else if !ok {
//    return false
//  } else if l.passedThroughNonGreedyDecision != othert.passedThroughNonGreedyDecision {
//    return false
//  }
//
//  var b bool
//
//  if l.lexerActionExecutor != nil {
//    b = !l.lexerActionExecutor.equals(othert.lexerActionExecutor)
//  } else {
//    b = othert.lexerActionExecutor != nil
//  }
//
//  if b {
//    return false
//  }
//
//  return l.BaseATNConfig.equals(othert.BaseATNConfig)
//}
//
//pub fn checkNonGreedyDecision(source *LexerATNConfig, target: ATNState) -> bool { // non-member
//  var ds, ok = target.(DecisionState)
//
//  return source.passedThroughNonGreedyDecision || (ok && ds.getNonGreedy())
//}
