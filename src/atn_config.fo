//package antlr
//
//import (
//  "fmt"
//  "strconv"
//)
//
//pub trait Comparable {
//  equals(other i32erface{}) bool
//}
//
//// ATNConfig is a tuple: (ATN state, predicted alt, syntactic, semantic
//// context). The syntactic context is a graph-structured stack node whose
//// path(s) to the root is the rule invocation(s) chain used to arrive at the
//// state. The semantic context is the tree of semantic predicates encountered
//// before reaching an ATN state.
//pub trait ATNConfig {
//  Hasher
//  Comparable
//
//  GetState() ATNState
//  GetAlt() i32
//  GetSemanticContext() SemanticContext
//
//  GetContext() PredictionContext
//  SetContext(PredictionContext)
//
//  GetReachesIntoOuterContext() i32
//  SetReachesIntoOuterContext(int)
//
//  String() &str
//
//  get_precedence_filter_suppressed() bool
//  set_precedence_filter_suppressed(bool)
//
//  short_hash() &str
//}
//
//pub struct BaseATNConfig {
//  precedence_filter_suppressed: bool
//  state:                      ATNState
//  alt:                        i32
//  context:                    PredictionContext
//  semantic_context:            SemanticContext
//  reaches_into_outer_context:    i32
//}
//
//impl BaseATNConfig {§//  pub fn new7(old *BaseATNConfig) -> *BaseATNConfig { // TODO: Dup
//  return &BaseATNConfig{
//    state:                   old.state,
//    alt:                     old.alt,
//    context:                 old.context,
//    semantic_context:         old.semantic_context,
//    reaches_into_outer_context: old.reaches_into_outer_context,
//  }
//}
//
//impl BaseATNConfig {§//  pub fn new6(&self, state ATNState, alt: i32, context: PredictionContext) -> *BaseATNConfig {
//  return BaseATNConfig5::new(state, alt, context, SemanticContextNone)
//}
//
//impl BaseATNConfig {§//  pub fn new5(&self, state ATNState, alt i32, context: PredictionContext, semantic_context: SemanticContext) -> *BaseATNConfig {
//  if semantic_context == nil {
//    panic("semanticContext cannot be nil") // TODO: Necessary?
//  }
//
//  return &BaseATNConfig{state: state, alt: alt, context: context, semantic_context: semantic_context}
//}
//
//impl BaseATNConfig {§//  pub fn new4(&self, c: ATNConfig, state: ATNState) -> *BaseATNConfig {
//  return BaseATNConfig::new(c, state, c.GetContext(), c.GetSemanticContext())
//}
//
//impl BaseATNConfig {§//  pub fn new3(&self, c ATNConfig, state: ATNState, semantic_context: SemanticContext) -> *BaseATNConfig {
//  return BaseATNConfig::new(c, state, c.GetContext(), semantic_context)
//}
//
//impl BaseATNConfig {§//  pub fn new2(&self, c: ATNConfig, semantic_context: SemanticContext) -> *BaseATNConfig {
//  return BaseATNConfig::new(c, c.GetState(), c.GetContext(), semantic_context)
//}
//
//impl BaseATNConfig {§//  pub fn new1(&self, c ATNConfig, state: ATNState, context: PredictionContext) -> *BaseATNConfig {
//  return BaseATNConfig::new(c, state, context, c.GetSemanticContext())
//}
//
//impl BaseATNConfig {§//  pub fn new(&self, c ATNConfig, state ATNState, context: PredictionContext, semantic_context: SemanticContext) -> *BaseATNConfig {
//  if semantic_context == nil {
//    panic("semanticContext cannot be nil")
//  }
//
//  return &BaseATNConfig{
//    state:                   state,
//    alt:                     c.GetAlt(),
//    context:                 context,
//    semantic_context:         semantic_context,
//    reaches_into_outer_context: c.GetReachesIntoOuterContext(),
//    precedence_filter_suppressed: c.get_precedence_filter_suppressed(),
//  }
//}
//
//pub fn get_precedence_filter_suppressed(&self, ) -> bool {
//  return b.precedence_filter_suppressed
//}
//
//pub fn set_precedence_filter_suppressed(&self, v: bool) {
//  b.precedence_filter_suppressed = v
//}
//
//pub fn GetState(&self, ) -> ATNState {
//  return b.state
//}
//
//pub fn GetAlt(&self, ) -> i32 {
//  return b.alt
//}
//
//pub fn SetContext(&self, v: PredictionContext) {
//  b.context = v
//}
//pub fn GetContext(&self, ) -> PredictionContext {
//  return b.context
//}
//
//pub fn GetSemanticContext(&self, ) -> SemanticContext {
//  return b.semantic_context
//}
//
//pub fn GetReachesIntoOuterContext(&self, ) -> i32 {
//  return b.reaches_into_outer_context
//}
//
//pub fn SetReachesIntoOuterContext(&self, v: i32) {
//  b.reaches_into_outer_context = v
//}
//
//// An ATN configuration is equal to another if both have the same state, they
//// predict the same alternative, and syntactic/semantic contexts are the same.
//pub fn equals(&self, o i32erface{}) -> bool {
//  if b == o {
//    return true
//  }
//
//  var other, ok = o.(*BaseATNConfig)
//
//  if !ok {
//    return false
//  }
//
//  var equal bool
//
//  if b.context == nil {
//    equal = other.context == nil
//  } else {
//    equal = b.context.equals(other.context)
//  }
//
//  var (
//    nums = b.state.GetStateNumber() == other.state.GetStateNumber()
//    alts = b.alt == other.alt
//    cons = b.semantic_context.equals(other.semantic_context)
//    sups = b.precedence_filter_suppressed == other.precedence_filter_suppressed
//  )
//
//  return nums && alts && cons && sups && equal
//}
//
//pub fn short_hash(&self, ) -> &str {
//  return strconv.Itoa(b.state.GetStateNumber()) + "/" + strconv.Itoa(b.alt) + "/" + b.semantic_context.String()
//}
//
//pub fn Hash(&self, ) -> &str {
//  var c &str
//
//  if b.context == nil {
//    c = ""
//  } else {
//    c = b.context.Hash()
//  }
//
//  return strconv.Itoa(b.state.GetStateNumber()) + "/" + strconv.Itoa(b.alt) + "/" + c + "/" + b.semantic_context.String()
//}
//
//pub fn String(&self, ) -> &str {
//  var s1, s2, s3 &str
//
//  if b.context != nil {
//    s1 = ",[" + fmt.Sprint(b.context) + "]"
//  }
//
//  if b.semantic_context != SemanticContextNone {
//    s2 = "," + fmt.Sprint(b.semantic_context)
//  }
//
//  if b.reaches_into_outer_context > 0 {
//    s3 = ",up=" + fmt.Sprint(b.reaches_into_outer_context)
//  }
//
//  return fmt.Sprintf("(%v,%v%v%v%v)", b.state, b.alt, s1, s2, s3)
//}
//
//
//
//pub struct LexerATNConfig {
//  *BaseATNConfig
//  lexer_action_executor:            *LexerActionExecutor
//  passed_through_non_greedy_decision: bool
//}
//
//impl LexerATNConfig {§//  pub fn new6(&self, state ATNState, alt: i32, context: PredictionContext) -> *LexerATNConfig {
//  return &LexerATNConfig{BaseATNConfig: NewBaseATNConfig5(state, alt, context, SemanticContextNone)}
//}
//
//impl LexerATNConfig {§//  pub fn new5(&self, state ATNState, alt i32, context: PredictionContext, lexer_action_executor *LexerActionExecutor) -> *LexerATNConfig {
//  return &LexerATNConfig{
//    BaseATNConfig:       NewBaseATNConfig5(state, alt, context, SemanticContextNone),
//    lexer_action_executor: lexer_action_executor,
//  }
//}
//
//impl LexerATNConfig {§//  pub fn new4(&self, c *LexerATNConfig, state: ATNState) -> *LexerATNConfig {
//  return &LexerATNConfig{
//    BaseATNConfig:                  NewBaseATNConfig(c, state, c.GetContext(), c.GetSemanticContext()),
//    lexer_action_executor:            c.lexer_action_executor,
//    passed_through_non_greedy_decision: check_non_greedy_decision(c, state),
//  }
//}
//
//impl LexerATNConfig {§//  pub fn new3(&self, c *LexerATNConfig, state: ATNState, lexer_action_executor *LexerActionExecutor) -> *LexerATNConfig {
//  return &LexerATNConfig{
//    BaseATNConfig:                  NewBaseATNConfig(c, state, c.GetContext(), c.GetSemanticContext()),
//    lexer_action_executor:            lexer_action_executor,
//    passed_through_non_greedy_decision: check_non_greedy_decision(c, state),
//  }
//}
//
//impl LexerATNConfig {§//  pub fn new2(&self, c *LexerATNConfig, state: ATNState, context: PredictionContext) -> *LexerATNConfig {
//  return &LexerATNConfig{
//    BaseATNConfig:                  NewBaseATNConfig(c, state, context, c.GetSemanticContext()),
//    lexer_action_executor:            c.lexer_action_executor,
//    passed_through_non_greedy_decision: check_non_greedy_decision(c, state),
//  }
//}
//
//impl LexerATNConfig {§//  pub fn new1(&self, state ATNState, alt: i32, context: PredictionContext) -> *LexerATNConfig {
//  return &LexerATNConfig{BaseATNConfig: NewBaseATNConfig5(state, alt, context, SemanticContextNone)}
//}
//
//pub fn Hash(&self, ) -> &str {
//  var f &str
//
//  if l.passed_through_non_greedy_decision {
//    f = "1"
//  } else {
//    f = "0"
//  }
//
//  return fmt.Sprintf("%v%v%v%v%v%v", l.state.GetStateNumber(), l.alt, l.context, l.semantic_context, f, l.lexer_action_executor)
//}
//
//pub fn equals(&self, other i32erface{}) -> bool {
//  var othert, ok = other.(*LexerATNConfig)
//
//  if l == other {
//    return true
//  } else if !ok {
//    return false
//  } else if l.passed_through_non_greedy_decision != othert.passed_through_non_greedy_decision {
//    return false
//  }
//
//  var b bool
//
//  if l.lexer_action_executor != nil {
//    b = !l.lexer_action_executor.equals(othert.lexer_action_executor)
//  } else {
//    b = othert.lexer_action_executor != nil
//  }
//
//  if b {
//    return false
//  }
//
//  return l.BaseATNConfig.equals(othert.BaseATNConfig)
//}
//
//pub fn check_non_greedy_decision(source *LexerATNConfig, target: ATNState) -> bool { // non-member
//  var ds, ok = target.(DecisionState)
//
//  return source.passed_through_non_greedy_decision || (ok && ds.get_non_greedy())
//}
