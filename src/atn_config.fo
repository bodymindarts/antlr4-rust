//package antlr
//
//import (
//	"fmt"
//	"strconv"
//)
//
//pub trait Comparable {
//	equals(other interface{}) bool
//}
//
//// ATNConfig is a tuple: (ATN state, predicted alt, syntactic, semantic
//// context). The syntactic context is a graph-structured stack node whose
//// path(s) to the root is the rule invocation(s) chain used to arrive at the
//// state. The semantic context is the tree of semantic predicates encountered
//// before reaching an ATN state.
//pub trait ATNConfig {
//	Hasher
//	Comparable
//
//	GetState() ATNState
//	GetAlt() int
//	GetSemanticContext() SemanticContext
//
//	GetContext() PredictionContext
//	SetContext(PredictionContext)
//
//	GetReachesIntoOuterContext() int
//	SetReachesIntoOuterContext(int)
//
//	String() string
//
//	getPrecedenceFilterSuppressed() bool
//	setPrecedenceFilterSuppressed(bool)
//
//	shortHash() string
//}
//
//pub struct BaseATNConfig {
//	precedenceFilterSuppressed bool
//	state                      ATNState
//	alt                        int
//	context                    PredictionContext
//	semanticContext            SemanticContext
//	reachesIntoOuterContext    int
//}
//
//impl BaseATNConfig {§//  pub fn new7(old *BaseATNConfig) *BaseATNConfig { // TODO: Dup
//	return &BaseATNConfig{
//		state:                   old.state,
//		alt:                     old.alt,
//		context:                 old.context,
//		semanticContext:         old.semanticContext,
//		reachesIntoOuterContext: old.reachesIntoOuterContext,
//	}
//}
//
//impl BaseATNConfig {§//  pub fn new6(state ATNState, alt int, context PredictionContext) *BaseATNConfig {
//	return NewBaseATNConfig5(state, alt, context, SemanticContextNone)
//}
//
//impl BaseATNConfig {§//  pub fn new5(state ATNState, alt int, context PredictionContext, semanticContext SemanticContext) *BaseATNConfig {
//	if semanticContext == nil {
//		panic("semanticContext cannot be nil") // TODO: Necessary?
//	}
//
//	return &BaseATNConfig{state: state, alt: alt, context: context, semanticContext: semanticContext}
//}
//
//impl BaseATNConfig {§//  pub fn new4(c ATNConfig, state ATNState) *BaseATNConfig {
//	return NewBaseATNConfig(c, state, c.GetContext(), c.GetSemanticContext())
//}
//
//impl BaseATNConfig {§//  pub fn new3(c ATNConfig, state ATNState, semanticContext SemanticContext) *BaseATNConfig {
//	return NewBaseATNConfig(c, state, c.GetContext(), semanticContext)
//}
//
//impl BaseATNConfig {§//  pub fn new2(c ATNConfig, semanticContext SemanticContext) *BaseATNConfig {
//	return NewBaseATNConfig(c, c.GetState(), c.GetContext(), semanticContext)
//}
//
//impl BaseATNConfig {§//  pub fn new1(c ATNConfig, state ATNState, context PredictionContext) *BaseATNConfig {
//	return NewBaseATNConfig(c, state, context, c.GetSemanticContext())
//}
//
//impl BaseATNConfig {§//  pub fn new(c ATNConfig, state ATNState, context PredictionContext, semanticContext SemanticContext) *BaseATNConfig {
//	if semanticContext == nil {
//		panic("semanticContext cannot be nil")
//	}
//
//	return &BaseATNConfig{
//		state:                   state,
//		alt:                     c.GetAlt(),
//		context:                 context,
//		semanticContext:         semanticContext,
//		reachesIntoOuterContext: c.GetReachesIntoOuterContext(),
//		precedenceFilterSuppressed: c.getPrecedenceFilterSuppressed(),
//	}
//}
//
//pub fn getPrecedenceFilterSuppressed() -> bool {
//	return b.precedenceFilterSuppressed
//}
//
//pub fn setPrecedenceFilterSuppressed(v bool) -> {
//	b.precedenceFilterSuppressed = v
//}
//
//pub fn GetState() -> ATNState {
//	return b.state
//}
//
//pub fn GetAlt() -> int {
//	return b.alt
//}
//
//pub fn SetContext(v PredictionContext) -> {
//	b.context = v
//}
//pub fn GetContext() -> PredictionContext {
//	return b.context
//}
//
//pub fn GetSemanticContext() -> SemanticContext {
//	return b.semanticContext
//}
//
//pub fn GetReachesIntoOuterContext() -> int {
//	return b.reachesIntoOuterContext
//}
//
//pub fn SetReachesIntoOuterContext(v int) -> {
//	b.reachesIntoOuterContext = v
//}
//
//// An ATN configuration is equal to another if both have the same state, they
//// predict the same alternative, and syntactic/semantic contexts are the same.
//pub fn equals(o interface{}) -> bool {
//	if b == o {
//		return true
//	}
//
//	var other, ok = o.(*BaseATNConfig)
//
//	if !ok {
//		return false
//	}
//
//	var equal bool
//
//	if b.context == nil {
//		equal = other.context == nil
//	} else {
//		equal = b.context.equals(other.context)
//	}
//
//	var (
//		nums = b.state.GetStateNumber() == other.state.GetStateNumber()
//		alts = b.alt == other.alt
//		cons = b.semanticContext.equals(other.semanticContext)
//		sups = b.precedenceFilterSuppressed == other.precedenceFilterSuppressed
//	)
//
//	return nums && alts && cons && sups && equal
//}
//
//pub fn shortHash() -> string {
//	return strconv.Itoa(b.state.GetStateNumber()) + "/" + strconv.Itoa(b.alt) + "/" + b.semanticContext.String()
//}
//
//pub fn Hash() -> string {
//	var c string
//
//	if b.context == nil {
//		c = ""
//	} else {
//		c = b.context.Hash()
//	}
//
//	return strconv.Itoa(b.state.GetStateNumber()) + "/" + strconv.Itoa(b.alt) + "/" + c + "/" + b.semanticContext.String()
//}
//
//pub fn String() -> string {
//	var s1, s2, s3 string
//
//	if b.context != nil {
//		s1 = ",[" + fmt.Sprint(b.context) + "]"
//	}
//
//	if b.semanticContext != SemanticContextNone {
//		s2 = "," + fmt.Sprint(b.semanticContext)
//	}
//
//	if b.reachesIntoOuterContext > 0 {
//		s3 = ",up=" + fmt.Sprint(b.reachesIntoOuterContext)
//	}
//
//	return fmt.Sprintf("(%v,%v%v%v%v)", b.state, b.alt, s1, s2, s3)
//}
//
//
//
//pub struct LexerATNConfig {
//	*BaseATNConfig
//	lexerActionExecutor            *LexerActionExecutor
//	passedThroughNonGreedyDecision bool
//}
//
//impl LexerATNConfig {§//  pub fn new6(state ATNState, alt int, context PredictionContext) *LexerATNConfig {
//	return &LexerATNConfig{BaseATNConfig: NewBaseATNConfig5(state, alt, context, SemanticContextNone)}
//}
//
//impl LexerATNConfig {§//  pub fn new5(state ATNState, alt int, context PredictionContext, lexerActionExecutor *LexerActionExecutor) *LexerATNConfig {
//	return &LexerATNConfig{
//		BaseATNConfig:       NewBaseATNConfig5(state, alt, context, SemanticContextNone),
//		lexerActionExecutor: lexerActionExecutor,
//	}
//}
//
//impl LexerATNConfig {§//  pub fn new4(c *LexerATNConfig, state ATNState) *LexerATNConfig {
//	return &LexerATNConfig{
//		BaseATNConfig:                  NewBaseATNConfig(c, state, c.GetContext(), c.GetSemanticContext()),
//		lexerActionExecutor:            c.lexerActionExecutor,
//		passedThroughNonGreedyDecision: checkNonGreedyDecision(c, state),
//	}
//}
//
//impl LexerATNConfig {§//  pub fn new3(c *LexerATNConfig, state ATNState, lexerActionExecutor *LexerActionExecutor) *LexerATNConfig {
//	return &LexerATNConfig{
//		BaseATNConfig:                  NewBaseATNConfig(c, state, c.GetContext(), c.GetSemanticContext()),
//		lexerActionExecutor:            lexerActionExecutor,
//		passedThroughNonGreedyDecision: checkNonGreedyDecision(c, state),
//	}
//}
//
//impl LexerATNConfig {§//  pub fn new2(c *LexerATNConfig, state ATNState, context PredictionContext) *LexerATNConfig {
//	return &LexerATNConfig{
//		BaseATNConfig:                  NewBaseATNConfig(c, state, context, c.GetSemanticContext()),
//		lexerActionExecutor:            c.lexerActionExecutor,
//		passedThroughNonGreedyDecision: checkNonGreedyDecision(c, state),
//	}
//}
//
//impl LexerATNConfig {§//  pub fn new1(state ATNState, alt int, context PredictionContext) *LexerATNConfig {
//	return &LexerATNConfig{BaseATNConfig: NewBaseATNConfig5(state, alt, context, SemanticContextNone)}
//}
//
//pub fn Hash() -> string {
//	var f string
//
//	if l.passedThroughNonGreedyDecision {
//		f = "1"
//	} else {
//		f = "0"
//	}
//
//	return fmt.Sprintf("%v%v%v%v%v%v", l.state.GetStateNumber(), l.alt, l.context, l.semanticContext, f, l.lexerActionExecutor)
//}
//
//pub fn equals(other interface{}) -> bool {
//	var othert, ok = other.(*LexerATNConfig)
//
//	if l == other {
//		return true
//	} else if !ok {
//		return false
//	} else if l.passedThroughNonGreedyDecision != othert.passedThroughNonGreedyDecision {
//		return false
//	}
//
//	var b bool
//
//	if l.lexerActionExecutor != nil {
//		b = !l.lexerActionExecutor.equals(othert.lexerActionExecutor)
//	} else {
//		b = othert.lexerActionExecutor != nil
//	}
//
//	if b {
//		return false
//	}
//
//	return l.BaseATNConfig.equals(othert.BaseATNConfig)
//}
//
//func checkNonGreedyDecision(source *LexerATNConfig, target ATNState) bool {
//	var ds, ok = target.(DecisionState)
//
//	return source.passedThroughNonGreedyDecision || (ok && ds.getNonGreedy())
//}
