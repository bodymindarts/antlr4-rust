//package antlr
//
//import "fmt"
//
//pub trait ATNConfigSet {
//  Hasher
//
//  Add(ATNConfig, *DoubleDict) bool
//  AddAll([]ATNConfig) bool
//
//  GetStates() *Set
//  GetPredicates() []SemanticContext
//  GetItems() []ATNConfig
//
//  OptimizeConfigs(interpreter *BaseATNSimulator)
//
//  Equals(other i32erface{}) bool
//
//  Length() i32
//  IsEmpty() bool
//  Contains(ATNConfig) bool
//  ContainsFast(ATNConfig) bool
//  Clear()
//  String() &str
//
//  HasSemanticContext() bool
//  SetHasSemanticContext(v bool)
//
//  ReadOnly() bool
//  SetReadOnly(bool)
//
//  GetConflictingAlts() *BitSet
//  SetConflictingAlts(*BitSet)
//
//  FullContext() bool
//
//  GetUniqueAlt() i32
//  SetUniqueAlt(int)
//
//  GetDipsIntoOuterContext() bool
//  SetDipsIntoOuterContext(bool)
//}
//
//// BaseATNConfigSet is a specialized set of ATNConfig that tracks information
//// about its elements and can combine similar configurations using a
//// graph-structured stack.
//pub struct BaseATNConfigSet {
//  cached_hash_string: &str
//
//  // config_lookup is used to determine whether two BaseATNConfigSets are equal. We
//  // need all configurations with the same (s, i, _, semctx) to be equal. A key
//  // effectively doubles the number of objects associated with ATNConfigs. All
//  // keys are hashed by (s, i, _, pi), not including the context. Wiped out when
//  // read-only because a set becomes a DFA state.
//  config_lookup: *Set
//
//  // configs is the added elements.
//  configs []ATNConfig
//
//  // TODO: These fields make me pretty uncomfortable, but it is nice to pack up
//  // info together because it saves recomputation. Can we track conflicts as they
//  // are added to save scanning configs later?
//  conflicting_alts: *BitSet
//
//  // dips_into_outer_context is used by parsers and lexers. In a lexer, it indicates
//  // we hit a pred while computing a closure operation. Do not make a DFA state
//  // from the BaseATNConfigSet in this case. TODO: How is this used by parsers?
//  dips_into_outer_context: bool
//
//  // full_ctx is whether it is part of a full context LL prediction. Used to
//  // determine how to merge $. It is a wildcard with SLL, but not for an LL
//  // context merge.
//  full_ctx: bool
//
//  // Used in parser and lexer. In lexer, it indicates we hit a pred
//  // while computing a closure operation. Don't make a DFA state from a.
//  has_semantic_context: bool
//
//  // read_only is whether it is read-only. Do not
//  // allow any code to manipulate the set if true because DFA states will point at
//  // sets and those must not change. It not protect other fields; conflicting_alts
//  // in particular, which is assigned after read_only.
//  read_only: bool
//
//  // TODO: These fields make me pretty uncomfortable, but it is nice to pack up
//  // info together because it saves recomputation. Can we track conflicts as they
//  // are added to save scanning configs later?
//  unique_alt: i32
//}
//
//impl BaseATNConfigSet {ยง//  pub fn new(&self, full_ctx: bool) -> *BaseATNConfigSet {
//  return &BaseATNConfigSet{
//    cached_hash_string: "-1",
//    config_lookup:     NewSet(hashATNConfig, equal_a_t_n_configs),
//    full_ctx:          full_ctx,
//  }
//}
//
//// Add merges contexts with existing configs for (s, i, pi, _), where s is the
//// ATNConfig.state, i is the ATNConfig.alt, and pi is the
//// ATNConfig.semantic_context. We use (s,i,pi) as the key. Updates
//// dips_into_outer_context and has_semantic_context when necessary.
//pub fn Add(&self, config: ATNConfig, merge_cache *DoubleDict) -> bool {
//  if b.read_only {
//    panic("set is read-only")
//  }
//
//  if config.GetSemanticContext() != SemanticContextNone {
//    b.has_semantic_context = true
//  }
//
//  if config.GetReachesIntoOuterContext() > 0 {
//    b.dips_into_outer_context = true
//  }
//
//  let existing = b.config_lookup.add(config).(ATNConfig);
//
//  if existing == config {
//    b.cached_hash_string = "-1"
//    b.configs = append(b.configs, config) // Track order here
//
//    return true
//  }
//
//  // Merge a previous (s, i, pi, _) with it and save the result
//  let root_is_wildcard = !b.full_ctx;
//  let merged = merge(existing.GetContext(), config.GetContext(), root_is_wildcard, merge_cache);
//
//  // No need to check for existing.context because config.context is in the cache,
//  // since the only way to create new graphs is the "call rule" and here. We cache
//  // at both places.
//  existing.SetReachesIntoOuterContext(intMax(existing.GetReachesIntoOuterContext(), config.GetReachesIntoOuterContext()))
//
//  // Preserve the precedence filter suppression during the merge
//  if config.get_precedence_filter_suppressed() {
//    existing.set_precedence_filter_suppressed(true)
//  }
//
//  // Replace the context because there is no need to do alt mapping
//  existing.SetContext(merged)
//
//  return true
//}
//
//pub fn GetStates(&self, ) -> *Set {
//  let states = NewSet(nil, nil);
//
//  for let i = 0; i < len(b.configs); i++ {;
//    states.add(b.configs[i].GetState())
//  }
//
//  return states
//}
//
//pub fn HasSemanticContext(&self, ) -> bool {
//  return b.has_semantic_context
//}
//
//pub fn SetHasSemanticContext(&self, v: bool) {
//  b.has_semantic_context = v
//}
//
//pub fn GetPredicates(&self, ) -> []SemanticContext {
//  let preds = make([]SemanticContext, 0);
//
//  for let i = 0; i < len(b.configs); i++ {;
//    let c = b.configs[i].GetSemanticContext();
//
//    if c != SemanticContextNone {
//      preds = append(preds, c)
//    }
//  }
//
//  return preds
//}
//
//pub fn GetItems(&self, ) -> []ATNConfig {
//  return b.configs
//}
//
//pub fn OptimizeConfigs(&self, interpreter *BaseATNSimulator) {
//  if b.read_only {
//    panic("set is read-only")
//  }
//
//  if b.config_lookup.length() == 0 {
//    return
//  }
//
//  for let i = 0; i < len(b.configs); i++ {;
//    let config = b.configs[i];
//
//    config.SetContext(interpreter.get_cached_context(config.GetContext()))
//  }
//}
//
//pub fn AddAll(&self, coll []ATNConfig) -> bool {
//  for let i = 0; i < len(coll); i++ {;
//    b.Add(coll[i], nil)
//  }
//
//  return false
//}
//
//pub fn Equals(&self, other i32erface{}) -> bool {
//  if b == other {
//    return true
//  } else if _, let ok = other.(*BaseATNConfigSet); !ok {;
//    return false
//  }
//
//  let other2 = other.(*BaseATNConfigSet);
//
//  return b.configs != nil &&
//    // TODO: b.configs.equals(other2.configs) && // TODO: Is b necessary?
//    b.full_ctx == other2.full_ctx &&
//    b.unique_alt == other2.unique_alt &&
//    b.conflicting_alts == other2.conflicting_alts &&
//    b.has_semantic_context == other2.has_semantic_context &&
//    b.dips_into_outer_context == other2.dips_into_outer_context
//}
//
//pub fn Hash(&self, ) -> &str {
//  if b.read_only {
//    if b.cached_hash_string == "-1" {
//      b.cached_hash_string = b.hash_configs()
//    }
//
//    return b.cached_hash_string
//  }
//
//  return b.hash_configs()
//}
//
//pub fn hash_configs(&self, ) -> &str {
//  let s = "";
//
//  for _, let c = range b.configs {;
//    s += fmt.Sprint(c)
//  }
//
//  return s
//}
//
//pub fn Length(&self, ) -> i32 {
//  return len(b.configs)
//}
//
//pub fn IsEmpty(&self, ) -> bool {
//  return len(b.configs) == 0
//}
//
//pub fn Contains(&self, item: ATNConfig) -> bool {
//  if b.config_lookup == nil {
//    panic("not implemented for read-only sets")
//  }
//
//  return b.config_lookup.contains(item)
//}
//
//pub fn ContainsFast(&self, item: ATNConfig) -> bool {
//  if b.config_lookup == nil {
//    panic("not implemented for read-only sets")
//  }
//
//  return b.config_lookup.contains(item) // TODO: contains_fast is not implemented for Set
//}
//
//pub fn Clear(&self, ) {
//  if b.read_only {
//    panic("set is read-only")
//  }
//
//  b.configs = make([]ATNConfig, 0)
//  b.cached_hash_string = "-1"
//  b.config_lookup = Set::new(hashATNConfig, equal_a_t_n_configs)
//}
//
//pub fn FullContext(&self, ) -> bool {
//  return b.full_ctx
//}
//
//pub fn GetDipsIntoOuterContext(&self, ) -> bool {
//  return b.dips_into_outer_context
//}
//
//pub fn SetDipsIntoOuterContext(&self, v: bool) {
//  b.dips_into_outer_context = v
//}
//
//pub fn GetUniqueAlt(&self, ) -> i32 {
//  return b.unique_alt
//}
//
//pub fn SetUniqueAlt(&self, v: i32) {
//  b.unique_alt = v
//}
//
//pub fn GetConflictingAlts(&self, ) -> *BitSet {
//  return b.conflicting_alts
//}
//
//pub fn SetConflictingAlts(&self, v *BitSet) {
//  b.conflicting_alts = v
//}
//
//pub fn ReadOnly(&self, ) -> bool {
//  return b.read_only
//}
//
//pub fn SetReadOnly(&self, read_only: bool) {
//  b.read_only = read_only
//
//  if read_only {
//    b.config_lookup = nil // Read only, so no need for the lookup cache
//  }
//}
//
//pub fn String(&self, ) -> &str {
//  let s = "[";
//
//  for i, let c = range b.configs {;
//    s += c.String()
//
//    if i != len(b.configs)-1 {
//      s += ", "
//    }
//  }
//
//  s += "]"
//
//  if b.has_semantic_context {
//    s += ",hasSemanticContext=" + fmt.Sprint(b.has_semantic_context)
//  }
//
//  if b.unique_alt != ATNInvalidAltNumber {
//    s += ",uniqueAlt=" + fmt.Sprint(b.unique_alt)
//  }
//
//  if b.conflicting_alts != nil {
//    s += ",conflictingAlts=" + b.conflicting_alts.String()
//  }
//
//  if b.dips_into_outer_context {
//    s += ",dipsIntoOuterContext"
//  }
//
//  return s
//}
//
//pub struct OrderedATNConfigSet {
//  *BaseATNConfigSet
//}
//
//impl OrderedATNConfigSet {ยง//  pub fn new(&self, ) -> *OrderedATNConfigSet {
//  let b = NewBaseATNConfigSet(false);
//
//  b.config_lookup = Set::new(nil, nil)
//
//  return &OrderedATNConfigSet{BaseATNConfigSet: b}
//}
//
//pub fn hash_a_t_n_config(c i32erface{}) -> &str { // non-member
//  return c.(ATNConfig).short_hash()
//}
//
//pub fn equal_a_t_n_configs(a, b i32erface{}) -> bool { // non-member
//  if a == nil || b == nil {
//    return false
//  }
//
//  if a == b {
//    return true
//  }
//
//  var ai, ok = a.(ATNConfig)
//  var bi, ok1 = b.(ATNConfig)
//
//  if !ok || !ok1 {
//    return false
//  }
//
//  let nums = ai.GetState().GetStateNumber() == bi.GetState().GetStateNumber();
//  let alts = ai.GetAlt() == bi.GetAlt();
//  let cons = ai.GetSemanticContext().equals(bi.GetSemanticContext());
//
//  return nums && alts && cons
//}
