//package antlr
//
//import "fmt"
//
//pub trait ATNConfigSet {
//	Hasher
//
//	Add(ATNConfig, *DoubleDict) bool
//	AddAll([]ATNConfig) bool
//
//	GetStates() *Set
//	GetPredicates() []SemanticContext
//	GetItems() []ATNConfig
//
//	OptimizeConfigs(interpreter *BaseATNSimulator)
//
//	Equals(other i32erface{}) bool
//
//	Length() i32
//	IsEmpty() bool
//	Contains(ATNConfig) bool
//	ContainsFast(ATNConfig) bool
//	Clear()
//	String() &str
//
//	HasSemanticContext() bool
//	SetHasSemanticContext(v bool)
//
//	ReadOnly() bool
//	SetReadOnly(bool)
//
//	GetConflictingAlts() *BitSet
//	SetConflictingAlts(*BitSet)
//
//	FullContext() bool
//
//	GetUniqueAlt() i32
//	SetUniqueAlt(int)
//
//	GetDipsIntoOuterContext() bool
//	SetDipsIntoOuterContext(bool)
//}
//
//// BaseATNConfigSet is a specialized set of ATNConfig that tracks information
//// about its elements and can combine similar configurations using a
//// graph-structured stack.
//pub struct BaseATNConfigSet {
//	cachedHashString: &str
//
//	// configLookup is used to determine whether two BaseATNConfigSets are equal. We
//	// need all configurations with the same (s, i, _, semctx) to be equal. A key
//	// effectively doubles the number of objects associated with ATNConfigs. All
//	// keys are hashed by (s, i, _, pi), not including the context. Wiped out when
//	// read-only because a set becomes a DFA state.
//	configLookup: *Set
//
//	// configs is the added elements.
//	configs []ATNConfig
//
//	// TODO: These fields make me pretty uncomfortable, but it is nice to pack up
//	// info together because it saves recomputation. Can we track conflicts as they
//	// are added to save scanning configs later?
//	conflictingAlts: *BitSet
//
//	// dipsIntoOuterContext is used by parsers and lexers. In a lexer, it indicates
//	// we hit a pred while computing a closure operation. Do not make a DFA state
//	// from the BaseATNConfigSet in this case. TODO: How is this used by parsers?
//	dipsIntoOuterContext: bool
//
//	// fullCtx is whether it is part of a full context LL prediction. Used to
//	// determine how to merge $. It is a wildcard with SLL, but not for an LL
//	// context merge.
//	fullCtx: bool
//
//	// Used in parser and lexer. In lexer, it indicates we hit a pred
//	// while computing a closure operation. Don't make a DFA state from a.
//	hasSemanticContext: bool
//
//	// readOnly is whether it is read-only. Do not
//	// allow any code to manipulate the set if true because DFA states will point at
//	// sets and those must not change. It not protect other fields; conflictingAlts
//	// in particular, which is assigned after readOnly.
//	readOnly: bool
//
//	// TODO: These fields make me pretty uncomfortable, but it is nice to pack up
//	// info together because it saves recomputation. Can we track conflicts as they
//	// are added to save scanning configs later?
//	uniqueAlt: i32
//}
//
//impl BaseATNConfigSet {ยง//  pub fn new(fullCtx: bool) -> *BaseATNConfigSet {
//	return &BaseATNConfigSet{
//		cachedHashString: "-1",
//		configLookup:     NewSet(hashATNConfig, equalATNConfigs),
//		fullCtx:          fullCtx,
//	}
//}
//
//// Add merges contexts with existing configs for (s, i, pi, _), where s is the
//// ATNConfig.state, i is the ATNConfig.alt, and pi is the
//// ATNConfig.semanticContext. We use (s,i,pi) as the key. Updates
//// dipsIntoOuterContext and hasSemanticContext when necessary.
//pub fn Add(config: ATNConfig, mergeCache *DoubleDict) -> bool {
//	if b.readOnly {
//		panic("set is read-only")
//	}
//
//	if config.GetSemanticContext() != SemanticContextNone {
//		b.hasSemanticContext = true
//	}
//
//	if config.GetReachesIntoOuterContext() > 0 {
//		b.dipsIntoOuterContext = true
//	}
//
//	existing := b.configLookup.add(config).(ATNConfig)
//
//	if existing == config {
//		b.cachedHashString = "-1"
//		b.configs = append(b.configs, config) // Track order here
//
//		return true
//	}
//
//	// Merge a previous (s, i, pi, _) with it and save the result
//	rootIsWildcard := !b.fullCtx
//	merged := merge(existing.GetContext(), config.GetContext(), rootIsWildcard, mergeCache)
//
//	// No need to check for existing.context because config.context is in the cache,
//	// since the only way to create new graphs is the "call rule" and here. We cache
//	// at both places.
//	existing.SetReachesIntoOuterContext(intMax(existing.GetReachesIntoOuterContext(), config.GetReachesIntoOuterContext()))
//
//	// Preserve the precedence filter suppression during the merge
//	if config.getPrecedenceFilterSuppressed() {
//		existing.setPrecedenceFilterSuppressed(true)
//	}
//
//	// Replace the context because there is no need to do alt mapping
//	existing.SetContext(merged)
//
//	return true
//}
//
//pub fn GetStates() -> *Set {
//	states := NewSet(nil, nil)
//
//	for i := 0; i < len(b.configs); i++ {
//		states.add(b.configs[i].GetState())
//	}
//
//	return states
//}
//
//pub fn HasSemanticContext() -> bool {
//	return b.hasSemanticContext
//}
//
//pub fn SetHasSemanticContext(v: bool) {
//	b.hasSemanticContext = v
//}
//
//pub fn GetPredicates() -> []SemanticContext {
//	preds := make([]SemanticContext, 0)
//
//	for i := 0; i < len(b.configs); i++ {
//		c := b.configs[i].GetSemanticContext()
//
//		if c != SemanticContextNone {
//			preds = append(preds, c)
//		}
//	}
//
//	return preds
//}
//
//pub fn GetItems() -> []ATNConfig {
//	return b.configs
//}
//
//pub fn OptimizeConfigs(interpreter *BaseATNSimulator) {
//	if b.readOnly {
//		panic("set is read-only")
//	}
//
//	if b.configLookup.length() == 0 {
//		return
//	}
//
//	for i := 0; i < len(b.configs); i++ {
//		config := b.configs[i]
//
//		config.SetContext(interpreter.getCachedContext(config.GetContext()))
//	}
//}
//
//pub fn AddAll(coll []ATNConfig) -> bool {
//	for i := 0; i < len(coll); i++ {
//		b.Add(coll[i], nil)
//	}
//
//	return false
//}
//
//pub fn Equals(other i32erface{}) -> bool {
//	if b == other {
//		return true
//	} else if _, ok := other.(*BaseATNConfigSet); !ok {
//		return false
//	}
//
//	other2 := other.(*BaseATNConfigSet)
//
//	return b.configs != nil &&
//		// TODO: b.configs.equals(other2.configs) && // TODO: Is b necessary?
//		b.fullCtx == other2.fullCtx &&
//		b.uniqueAlt == other2.uniqueAlt &&
//		b.conflictingAlts == other2.conflictingAlts &&
//		b.hasSemanticContext == other2.hasSemanticContext &&
//		b.dipsIntoOuterContext == other2.dipsIntoOuterContext
//}
//
//pub fn Hash() -> &str {
//	if b.readOnly {
//		if b.cachedHashString == "-1" {
//			b.cachedHashString = b.hashConfigs()
//		}
//
//		return b.cachedHashString
//	}
//
//	return b.hashConfigs()
//}
//
//pub fn hashConfigs() -> &str {
//	s := ""
//
//	for _, c := range b.configs {
//		s += fmt.Sprint(c)
//	}
//
//	return s
//}
//
//pub fn Length() -> i32 {
//	return len(b.configs)
//}
//
//pub fn IsEmpty() -> bool {
//	return len(b.configs) == 0
//}
//
//pub fn Contains(item: ATNConfig) -> bool {
//	if b.configLookup == nil {
//		panic("not implemented for read-only sets")
//	}
//
//	return b.configLookup.contains(item)
//}
//
//pub fn ContainsFast(item: ATNConfig) -> bool {
//	if b.configLookup == nil {
//		panic("not implemented for read-only sets")
//	}
//
//	return b.configLookup.contains(item) // TODO: containsFast is not implemented for Set
//}
//
//pub fn Clear() {
//	if b.readOnly {
//		panic("set is read-only")
//	}
//
//	b.configs = make([]ATNConfig, 0)
//	b.cachedHashString = "-1"
//	b.configLookup = NewSet(hashATNConfig, equalATNConfigs)
//}
//
//pub fn FullContext() -> bool {
//	return b.fullCtx
//}
//
//pub fn GetDipsIntoOuterContext() -> bool {
//	return b.dipsIntoOuterContext
//}
//
//pub fn SetDipsIntoOuterContext(v: bool) {
//	b.dipsIntoOuterContext = v
//}
//
//pub fn GetUniqueAlt() -> i32 {
//	return b.uniqueAlt
//}
//
//pub fn SetUniqueAlt(v: i32) {
//	b.uniqueAlt = v
//}
//
//pub fn GetConflictingAlts() -> *BitSet {
//	return b.conflictingAlts
//}
//
//pub fn SetConflictingAlts(v *BitSet) {
//	b.conflictingAlts = v
//}
//
//pub fn ReadOnly() -> bool {
//	return b.readOnly
//}
//
//pub fn SetReadOnly(readOnly: bool) {
//	b.readOnly = readOnly
//
//	if readOnly {
//		b.configLookup = nil // Read only, so no need for the lookup cache
//	}
//}
//
//pub fn String() -> &str {
//	s := "["
//
//	for i, c := range b.configs {
//		s += c.String()
//
//		if i != len(b.configs)-1 {
//			s += ", "
//		}
//	}
//
//	s += "]"
//
//	if b.hasSemanticContext {
//		s += ",hasSemanticContext=" + fmt.Sprint(b.hasSemanticContext)
//	}
//
//	if b.uniqueAlt != ATNInvalidAltNumber {
//		s += ",uniqueAlt=" + fmt.Sprint(b.uniqueAlt)
//	}
//
//	if b.conflictingAlts != nil {
//		s += ",conflictingAlts=" + b.conflictingAlts.String()
//	}
//
//	if b.dipsIntoOuterContext {
//		s += ",dipsIntoOuterContext"
//	}
//
//	return s
//}
//
//pub struct OrderedATNConfigSet {
//	*BaseATNConfigSet
//}
//
//impl OrderedATNConfigSet {ยง//  pub fn new() -> *OrderedATNConfigSet {
//	b := NewBaseATNConfigSet(false)
//
//	b.configLookup = NewSet(nil, nil)
//
//	return &OrderedATNConfigSet{BaseATNConfigSet: b}
//}
//
//pub fn hashATNConfig(c i32erface{}) -> &str { // non-member
//	return c.(ATNConfig).shortHash()
//}
//
//pub fn equalATNConfigs(a, b i32erface{}) -> bool { // non-member
//	if a == nil || b == nil {
//		return false
//	}
//
//	if a == b {
//		return true
//	}
//
//	var ai, ok = a.(ATNConfig)
//	var bi, ok1 = b.(ATNConfig)
//
//	if !ok || !ok1 {
//		return false
//	}
//
//	nums := ai.GetState().GetStateNumber() == bi.GetState().GetStateNumber()
//	alts := ai.GetAlt() == bi.GetAlt()
//	cons := ai.GetSemanticContext().equals(bi.GetSemanticContext())
//
//	return nums && alts && cons
//}
