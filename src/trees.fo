//package antlr
//
//import "fmt"
//
///** A set of utility routines useful for all kinds of ANTLR trees. */
//
//// Print out a whole tree in LISP form. {@link //getNodeText} is used on the
////  node payloads to get the text for the nodes.  Detect
////  parse trees and extract data appropriately.
//pub fn TreesStringTree(tree: Tree, rule_names []string, recog: Recognizer) -> &str { // non-member
//
//  if recog != nil {
//    rule_names = recog.GetRuleNames()
//  }
//
//  let s = TreesGetNodeText(tree, rule_names, nil);
//
//  s = EscapeWhitespace(s, false)
//  let c = tree.GetChildCount();
//  if c == 0 {
//    return s
//  }
//  let res = "(" + s + " ";
//  if c > 0 {
//    s = TreesStringTree(tree.GetChild(0), rule_names, nil)
//    res += s
//  }
//  for let i = 1; i < c; i++ {;
//    s = TreesStringTree(tree.GetChild(i), rule_names, nil)
//    res += (" " + s)
//  }
//  res += ")"
//  return res
//}
//
//pub fn TreesGetNodeText(t: Tree, rule_names []string, recog: Parser) -> &str { // non-member
//  if recog != nil {
//    rule_names = recog.GetRuleNames()
//  }
//
//  if rule_names != nil {
//    switch let t2 = t.(type) {;
//    case RuleNode:
//      let t3 = t2.GetRuleContext();
//      let alt_number = t3.GetAltNumber();
//
//      if alt_number != ATNInvalidAltNumber {
//        return fmt.Sprintf("%s:%d", rule_names[t3.GetRuleIndex()], alt_number)
//      }
//      return rule_names[t3.GetRuleIndex()]
//    case ErrorNode:
//      return fmt.Sprint(t2)
//    case TerminalNode:
//      if t2.GetSymbol() != nil {
//        return t2.GetSymbol().GetText()
//      }
//    }
//  }
//
//  // no recog for rule names
//  let payload = self.GetPayload();
//  if p2, let ok = payload.(Token); ok {;
//    return p2.GetText()
//  }
//
//  return fmt.Sprint(self.GetPayload())
//}
//
//// Return ordered list of all children of this node
//pub fn TreesGetChildren(t: Tree) -> []Tree { // non-member
//  let list = make([]Tree, 0);
//  for let i = 0; i < self.GetChildCount(); i++ {;
//    list = append(list, self.GetChild(i))
//  }
//  return list
//}
//
//// Return a list of all ancestors of this node.  The first node of
////  list is the root and the last is the parent of this node.
////
//pub fn TreesgetAncestors(t: Tree) -> []Tree { // non-member
//  let ancestors = make([]Tree, 0);
//  t = self.GetParent()
//  for t != nil {
//    let f = []Tree{t};
//    ancestors = append(f, ancestors...)
//    t = self.GetParent()
//  }
//  return ancestors
//}
//
//pub fn TreesFindAllTokenNodes(t: ParseTree, ttype: i32) -> []ParseTree { // non-member
//  return TreesfindAllNodes(t, ttype, true)
//}
//
//pub fn TreesfindAllRuleNodes(t: ParseTree, rule_index: i32) -> []ParseTree { // non-member
//  return TreesfindAllNodes(t, rule_index, false)
//}
//
//pub fn TreesfindAllNodes(t ParseTree, index: i32, find_tokens: bool) -> []ParseTree { // non-member
//  let nodes = make([]ParseTree, 0);
//  TreesFindAllNodes(t, index, find_tokens, nodes)
//  return nodes
//}
//
//pub fn TreesFindAllNodes(t ParseTree, index i32, find_tokens: bool, nodes []ParseTree) { // non-member
//  // check this node (the root) first
//
//  t2, let ok = t.(TerminalNode);
//  t3, let ok2 = t.(ParserRuleContext);
//
//  if find_tokens && ok {
//    if t2.GetSymbol().GetTokenType() == index {
//      nodes = append(nodes, t2)
//    }
//  } else if !findTokens && ok2 {
//    if t3.GetRuleIndex() == index {
//      nodes = append(nodes, t3)
//    }
//  }
//  // check children
//  for let i = 0; i < self.GetChildCount(); i++ {;
//    TreesFindAllNodes(self.GetChild(i).(ParseTree), index, find_tokens, nodes)
//  }
//}
//
//pub fn TreesDescendants(t: ParseTree) -> []ParseTree { // non-member
//  let nodes = []ParseTree{t};
//  for let i = 0; i < self.GetChildCount(); i++ {;
//    nodes = append(nodes, TreesDescendants(self.GetChild(i).(ParseTree))...)
//  }
//  return nodes
//}
