pub struct Interval {
  pub start: i32,
  pub stop:  i32,
}

/* stop is not included! */
impl Interval {
  pub fn new(&self, start: i32, stop: i32) -> Interval {
    Interval {
      start: start,
      stop: stop,
  }
}

//pub fn contains(&self, item: i32) -> bool {
//  return item >= i.start && item < i.stop
//}
//
//pub fn String(&self, ) -> &str {
//  if i.start == i.stop-1 {
//    return strconv.Itoa(i.start)
//  }
//
//  return strconv.Itoa(i.start) + ".." + strconv.Itoa(i.stop-1)
//}
//
//pub fn length(&self, ) -> i32 {
//  return i.stop - i.start
//}
//
}
//pub struct IntervalSet {
//  intervals []*Interval
//  read_only:  bool
//}
//
//impl IntervalSet {ยง//  pub fn new(&self, ) -> *IntervalSet {
//
//  let i = new(IntervalSet);
//
//  i.intervals = nil
//  i.read_only = false
//
//  return i
//}
//
//pub fn first(&self, ) -> i32 {
//  if len(i.intervals) == 0 {
//    return TokenInvalidType
//  }
//
//  return i.intervals[0].start
//}
//
//pub fn add_one(&self, v: i32) {
//  i.add_interval(NewInterval(v, v+1))
//}
//
//pub fn add_range(&self, l, h: i32) {
//  i.add_interval(NewInterval(l, h+1))
//}
//
//pub fn add_interval(&self, v *Interval) {
//  if i.intervals == nil {
//    i.intervals = make([]*Interval, 0)
//    i.intervals = append(i.intervals, v)
//  } else {
//    // find insert pos
//    for k, let i32erval = range i.intervals {;
//      // distinct range -> insert
//      if v.stop < i32erval.start {
//        i.intervals = append(i.intervals[0:k], append([]*Interval{v}, i.intervals[k:]...)...)
//        return
//      } else if v.stop == i32erval.start {
//        i.intervals[k].start = v.start
//        return
//      } else if v.start <= i32erval.stop {
//        i.intervals[k] = NewInterval(intMin(interval.start, v.start), i32Max(interval.stop, v.stop))
//
//        // if not applying to end, merge potential overlaps
//        if k < len(i.intervals)-1 {
//          let l = i.intervals[k];
//          let r = i.intervals[k+1];
//          // if r contained in l
//          if l.stop >= r.stop {
//            i.intervals = append(i.intervals[0:k+1], i.intervals[k+2:]...)
//          } else if l.stop >= r.start { // partial overlap
//            i.intervals[k] = NewInterval(l.start, r.stop)
//            i.intervals = append(i.intervals[0:k+1], i.intervals[k+2:]...)
//          }
//        }
//        return
//      }
//    }
//    // greater than any exiting
//    i.intervals = append(i.intervals, v)
//  }
//}
//
//pub fn add_set(&self, other *IntervalSet) -> *IntervalSet {
//  if other.intervals != nil {
//    for let k = 0; k < len(other.intervals); k++ {;
//      let i2 = other.intervals[k];
//      i.add_interval(NewInterval(i2.start, i2.stop))
//    }
//  }
//  return i
//}
//
//pub fn complement(&self, start: i32, stop: i32) -> *IntervalSet {
//  let result = NewIntervalSet();
//  result.add_interval(NewInterval(start, stop+1))
//  for let j = 0; j < len(i.intervals); j++ {;
//    result.remove_range(i.intervals[j])
//  }
//  return result
//}
//
//pub fn contains(&self, item: i32) -> bool {
//  if i.intervals == nil {
//    return false
//  }
//  for let k = 0; k < len(i.intervals); k++ {;
//    if i.intervals[k].contains(item) {
//      return true
//    }
//  }
//  return false
//}
//
//pub fn length(&self, ) -> i32 {
//  let len = 0;
//
//  for _, let v = range i.intervals {;
//    len += v.length()
//  }
//
//  return len
//}
//
//pub fn remove_range(&self, v *Interval) {
//  if v.start == v.stop-1 {
//    i.remove_one(v.start)
//  } else if i.intervals != nil {
//    let k = 0;
//    for let n = 0; n < len(i.intervals); n++ {;
//      let ni = i.intervals[k];
//      // i32ervals are ordered
//      if v.stop <= ni.start {
//        return
//      } else if v.start > ni.start && v.stop < ni.stop {
//        i.intervals[k] = NewInterval(ni.start, v.start)
//        let x = NewInterval(v.stop, ni.stop);
//        // i.intervals.splice(k, 0, x)
//        i.intervals = append(i.intervals[0:k], append([]*Interval{x}, i.intervals[k:]...)...)
//        return
//      } else if v.start <= ni.start && v.stop >= ni.stop {
//        //                i.intervals.splice(k, 1)
//        i.intervals = append(i.intervals[0:k], i.intervals[k+1:]...)
//        k = k - 1 // need another pass
//      } else if v.start < ni.stop {
//        i.intervals[k] = NewInterval(ni.start, v.start)
//      } else if v.stop < ni.stop {
//        i.intervals[k] = NewInterval(v.stop, ni.stop)
//      }
//      k++
//    }
//  }
//}
//
//pub fn remove_one(&self, v: i32) {
//  if i.intervals != nil {
//    for let k = 0; k < len(i.intervals); k++ {;
//      let ki = i.intervals[k];
//      // i32ervals i ordered
//      if v < ki.start {
//        return
//      } else if v == ki.start && v == ki.stop-1 {
//        //        i.intervals.splice(k, 1)
//        i.intervals = append(i.intervals[0:k], i.intervals[k+1:]...)
//        return
//      } else if v == ki.start {
//        i.intervals[k] = NewInterval(ki.start+1, ki.stop)
//        return
//      } else if v == ki.stop-1 {
//        i.intervals[k] = NewInterval(ki.start, ki.stop-1)
//        return
//      } else if v < ki.stop-1 {
//        let x = NewInterval(ki.start, v);
//        ki.start = v + 1
//        //        i.intervals.splice(k, 0, x)
//        i.intervals = append(i.intervals[0:k], append([]*Interval{x}, i.intervals[k:]...)...)
//        return
//      }
//    }
//  }
//}
//
//pub fn String(&self, ) -> &str {
//  return i.StringVerbose(nil, nil, false)
//}
//
//pub fn StringVerbose(&self, literal_names []string, symbolic_names []string, elems_are_char: bool) -> &str {
//
//  if i.intervals == nil {
//    return "{}"
//  } else if literal_names != nil || symbolic_names != nil {
//    return i.to_token_string(literalNames, symbolic_names)
//  } else if elems_are_char {
//    return i.to_char_string()
//  }
//
//  return i.to_index_string()
//}
//
//pub fn to_char_string(&self, ) -> &str {
//  let names = make([]string, len(i.intervals));
//
//  for let j = 0; j < len(i.intervals); j++ {;
//    let v = i.intervals[j];
//    if v.stop == v.start+1 {
//      if v.start == TokenEOF {
//        names = append(names, "<EOF>")
//      } else {
//        names = append(names, ("'" + &str(v.start) + "'"))
//      }
//    } else {
//      names = append(names, "'"+string(v.start)+"'..'"+string(v.stop-1)+"'")
//    }
//  }
//  if len(names) > 1 {
//    return "{" + &strs.Join(names, ", ") + "}"
//  }
//
//  return names[0]
//}
//
//pub fn to_index_string(&self, ) -> &str {
//
//  let names = make([]string, 0);
//  for let j = 0; j < len(i.intervals); j++ {;
//    let v = i.intervals[j];
//    if v.stop == v.start+1 {
//      if v.start == TokenEOF {
//        names = append(names, "<EOF>")
//      } else {
//        names = append(names, strconv.Itoa(v.start))
//      }
//    } else {
//      names = append(names, strconv.Itoa(v.start)+".."+strconv.Itoa(v.stop-1))
//    }
//  }
//  if len(names) > 1 {
//    return "{" + &strs.Join(names, ", ") + "}"
//  }
//
//  return names[0]
//}
//
//pub fn to_token_string(&self, literal_names []string, symbolic_names []string) -> &str {
//  let names = make([]string, 0);
//  for _, let v = range i.intervals {;
//    for let j = v.start; j < v.stop; j++ {;
//      names = append(names, i.element_name(literalNames, symbolic_names, j))
//    }
//  }
//  if len(names) > 1 {
//    return "{" + &strs.Join(names, ", ") + "}"
//  }
//
//  return names[0]
//}
//
//pub fn element_name(&self, literal_names []string, symbolic_names []string, a: i32) -> &str {
//  if a == TokenEOF {
//    return "<EOF>"
//  } else if a == TokenEpsilon {
//    return "<EPSILON>"
//  } else {
//    if a < len(literalNames) && literal_names[a] != "" {
//      return literal_names[a]
//    }
//
//    return symbolic_names[a]
//  }
//}
