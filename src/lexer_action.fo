//package antlr
//
//import "strconv"
//
//const (
//  LexerActionTypeChannel  = 0 //The type of a {@link LexerChannelAction} action.
//  LexerActionTypeCustom   = 1 //The type of a {@link LexerCustomAction} action.
//  LexerActionTypeMode     = 2 //The type of a {@link LexerModeAction} action.
//  LexerActionTypeMore     = 3 //The type of a {@link LexerMoreAction} action.
//  LexerActionTypePopMode  = 4 //The type of a {@link LexerPopModeAction} action.
//  LexerActionTypePushMode = 5 //The type of a {@link LexerPushModeAction} action.
//  LexerActionTypeSkip     = 6 //The type of a {@link LexerSkipAction} action.
//  LexerActionTypeType     = 7 //The type of a {@link LexerTypeAction} action.
//)
//
//pub trait LexerAction {
//  getActionType() i32
//  getIsPositionDependent() bool
//  execute(lexer Lexer)
//  Hash() &str
//  equals(other LexerAction) bool
//}
//
//pub struct BaseLexerAction {
//  actionType:          i32
//  isPositionDependent: bool
//}
//
//impl BaseLexerAction {§//  pub fn new(&self, action: i32) -> *BaseLexerAction {
//  let la = new(BaseLexerAction);
//
//  la.actionType = action
//  la.isPositionDependent = false
//
//  return la
//}
//
//pub fn execute(&self, lexer: Lexer) {
//  panic("Not implemented")
//}
//
//pub fn getActionType(&self, ) -> i32 {
//  return b.actionType
//}
//
//pub fn getIsPositionDependent(&self, ) -> bool {
//  return b.isPositionDependent
//}
//
//pub fn Hash(&self, ) -> &str {
//  return strconv.Itoa(b.actionType)
//}
//
//pub fn equals(&self, other: LexerAction) -> bool {
//  return b == other
//}
//
////
//// Implements the {@code Skip} lexer action by calling {@link Lexer//Skip}.
////
//// <p>The {@code Skip} command does not have any parameters, so l action is
//// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
//pub struct LexerSkipAction {
//  *BaseLexerAction
//}
//
//impl LexerSkipAction {§//  pub fn new(&self, ) -> *LexerSkipAction {
//  let la = new(LexerSkipAction);
//  la.BaseLexerAction = NewBaseLexerAction(LexerActionTypeSkip)
//  return la
//}
//
//// Provides a singleton instance of l parameterless lexer action.
//var LexerSkipActionINSTANCE = NewLexerSkipAction()
//
//pub fn execute(&self, lexer: Lexer) {
//  lexer.Skip()
//}
//
//pub fn String(&self, ) -> &str {
//  return "skip"
//}
//
////  Implements the {@code type} lexer action by calling {@link Lexer//setType}
//// with the assigned type.
//pub struct LexerTypeAction {
//  *BaseLexerAction
//
//  thetype: i32
//}
//
//impl LexerTypeAction {§//  pub fn new(&self, thetype: i32) -> *LexerTypeAction {
//  let l = new(LexerTypeAction);
//  l.BaseLexerAction = NewBaseLexerAction(LexerActionTypeType)
//  l.thetype = thetype
//  return l
//}
//
//pub fn execute(&self, lexer: Lexer) {
//  lexer.setType(l.thetype)
//}
//
//pub fn Hash(&self, ) -> &str {
//  return strconv.Itoa(l.actionType) + strconv.Itoa(l.thetype)
//}
//
//pub fn equals(&self, other: LexerAction) -> bool {
//  if l == other {
//    return true
//  } else if _, let ok = other.(*LexerTypeAction); !ok {;
//    return false
//  } else {
//    return l.thetype == other.(*LexerTypeAction).thetype
//  }
//}
//
//pub fn String(&self, ) -> &str {
//  return "actionType(" + strconv.Itoa(l.thetype) + ")"
//}
//
//// Implements the {@code pushMode} lexer action by calling
//// {@link Lexer//pushMode} with the assigned mode.
//pub struct LexerPushModeAction {
//  *BaseLexerAction
//
//  mode: i32
//}
//
//impl LexerPushModeAction {§//  pub fn new(&self, mode: i32) -> *LexerPushModeAction {
//
//  let l = new(LexerPushModeAction);
//  l.BaseLexerAction = NewBaseLexerAction(LexerActionTypePushMode)
//
//  l.mode = mode
//  return l
//}
//
//// <p>This action is implemented by calling {@link Lexer//pushMode} with the
//// value provided by {@link //getMode}.</p>
//pub fn execute(&self, lexer: Lexer) {
//  lexer.pushMode(l.mode)
//}
//
//pub fn Hash(&self, ) -> &str {
//  return strconv.Itoa(l.actionType) + strconv.Itoa(l.mode)
//}
//
//pub fn equals(&self, other: LexerAction) -> bool {
//  if l == other {
//    return true
//  } else if _, let ok = other.(*LexerPushModeAction); !ok {;
//    return false
//  } else {
//    return l.mode == other.(*LexerPushModeAction).mode
//  }
//}
//
//pub fn String(&self, ) -> &str {
//  return "pushMode(" + strconv.Itoa(l.mode) + ")"
//}
//
//// Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.
////
//// <p>The {@code popMode} command does not have any parameters, so l action is
//// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
//pub struct LexerPopModeAction {
//  *BaseLexerAction
//}
//
//impl LexerPopModeAction {§//  pub fn new(&self, ) -> *LexerPopModeAction {
//
//  let l = new(LexerPopModeAction);
//
//  l.BaseLexerAction = NewBaseLexerAction(LexerActionTypePopMode)
//
//  return l
//}
//
//var LexerPopModeActionINSTANCE = NewLexerPopModeAction()
//
//// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
//pub fn execute(&self, lexer: Lexer) {
//  lexer.popMode()
//}
//
//pub fn String(&self, ) -> &str {
//  return "popMode"
//}
//
//// Implements the {@code more} lexer action by calling {@link Lexer//more}.
////
//// <p>The {@code more} command does not have any parameters, so l action is
//// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
//
//pub struct LexerMoreAction {
//  *BaseLexerAction
//}
//
//impl LexerMoreAction {§//  pub fn new(&self, ) -> *LexerMoreAction {
//  let l = new(LexerMoreAction);
//  l.BaseLexerAction = NewBaseLexerAction(LexerActionTypeMore)
//
//  return l
//}
//
//var LexerMoreActionINSTANCE = NewLexerMoreAction()
//
//// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
//pub fn execute(&self, lexer: Lexer) {
//  lexer.More()
//}
//
//pub fn String(&self, ) -> &str {
//  return "more"
//}
//
//// Implements the {@code mode} lexer action by calling {@link Lexer//mode} with
//// the assigned mode.
//pub struct LexerModeAction {
//  *BaseLexerAction
//
//  mode: i32
//}
//
//impl LexerModeAction {§//  pub fn new(&self, mode: i32) -> *LexerModeAction {
//  let l = new(LexerModeAction);
//  l.BaseLexerAction = NewBaseLexerAction(LexerActionTypeMode)
//  l.mode = mode
//  return l
//}
//
//// <p>This action is implemented by calling {@link Lexer//mode} with the
//// value provided by {@link //getMode}.</p>
//pub fn execute(&self, lexer: Lexer) {
//  lexer.setMode(l.mode)
//}
//
//pub fn Hash(&self, ) -> &str {
//  return strconv.Itoa(l.actionType) + strconv.Itoa(l.mode)
//}
//
//pub fn equals(&self, other: LexerAction) -> bool {
//  if l == other {
//    return true
//  } else if _, let ok = other.(*LexerModeAction); !ok {;
//    return false
//  } else {
//    return l.mode == other.(*LexerModeAction).mode
//  }
//}
//
//pub fn String(&self, ) -> &str {
//  return "mode(" + strconv.Itoa(l.mode) + ")"
//}
//
//// Executes a custom lexer action by calling {@link Recognizer//action} with the
//// rule and action indexes assigned to the custom action. The implementation of
//// a custom action is added to the generated code for the lexer in an override
//// of {@link Recognizer//action} when the grammar is compiled.
////
//// <p>This class may represent embedded actions created with the <code>{...}</code>
//// syntax in ANTLR 4, as well as actions created for lexer commands where the
//// command argument could not be evaluated when the grammar was compiled.</p>
//
//// Constructs a custom lexer action with the specified rule and action
//// indexes.
////
//// @param ruleIndex The rule index to use for calls to
//// {@link Recognizer//action}.
//// @param actionIndex The action index to use for calls to
//// {@link Recognizer//action}.
//
//pub struct LexerCustomAction {
//  *BaseLexerAction
//  ruleIndex, actionIndex i32
//}
//
//impl LexerCustomAction {§//  pub fn new(&self, ruleIndex, actionIndex: i32) -> *LexerCustomAction {
//  let l = new(LexerCustomAction);
//  l.BaseLexerAction = NewBaseLexerAction(LexerActionTypeCustom)
//  l.ruleIndex = ruleIndex
//  l.actionIndex = actionIndex
//  l.isPositionDependent = true
//  return l
//}
//
//// <p>Custom actions are implemented by calling {@link Lexer//action} with the
//// appropriate rule and action indexes.</p>
//pub fn execute(&self, lexer: Lexer) {
//  lexer.Action(nil, l.ruleIndex, l.actionIndex)
//}
//
//pub fn Hash(&self, ) -> &str {
//  return strconv.Itoa(l.actionType) + strconv.Itoa(l.ruleIndex) + strconv.Itoa(l.actionIndex)
//}
//
//pub fn equals(&self, other: LexerAction) -> bool {
//  if l == other {
//    return true
//  } else if _, let ok = other.(*LexerCustomAction); !ok {;
//    return false
//  } else {
//    return l.ruleIndex == other.(*LexerCustomAction).ruleIndex && l.actionIndex == other.(*LexerCustomAction).actionIndex
//  }
//}
//
//// Implements the {@code channel} lexer action by calling
//// {@link Lexer//setChannel} with the assigned channel.
//// Constructs a New{@code channel} action with the specified channel value.
//// @param channel The channel value to pass to {@link Lexer//setChannel}.
//pub struct LexerChannelAction {
//  *BaseLexerAction
//
//  channel: i32
//}
//
//impl LexerChannelAction {§//  pub fn new(&self, channel: i32) -> *LexerChannelAction {
//  let l = new(LexerChannelAction);
//  l.BaseLexerAction = NewBaseLexerAction(LexerActionTypeChannel)
//  l.channel = channel
//  return l
//}
//
//// <p>This action is implemented by calling {@link Lexer//setChannel} with the
//// value provided by {@link //getChannel}.</p>
//pub fn execute(&self, lexer: Lexer) {
//  lexer.setChannel(l.channel)
//}
//
//pub fn Hash(&self, ) -> &str {
//  return strconv.Itoa(l.actionType) + strconv.Itoa(l.channel)
//}
//
//pub fn equals(&self, other: LexerAction) -> bool {
//  if l == other {
//    return true
//  } else if _, let ok = other.(*LexerChannelAction); !ok {;
//    return false
//  } else {
//    return l.channel == other.(*LexerChannelAction).channel
//  }
//}
//
//pub fn String(&self, ) -> &str {
//  return "channel(" + strconv.Itoa(l.channel) + ")"
//}
//
//// This implementation of {@link LexerAction} is used for tracking input offsets
//// for position-dependent actions within a {@link LexerActionExecutor}.
////
//// <p>This action is not serialized as part of the ATN, and is only required for
//// position-dependent lexer actions which appear at a location other than the
//// end of a rule. For more information about DFA optimizations employed for
//// lexer actions, see {@link LexerActionExecutor//append} and
//// {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>
//
//// Constructs a Newindexed custom action by associating a character offset
//// with a {@link LexerAction}.
////
//// <p>Note: This class is only required for lexer actions for which
//// {@link LexerAction//isPositionDependent} returns {@code true}.</p>
////
//// @param offset The offset i32o the input {@link CharStream}, relative to
//// the token start index, at which the specified lexer action should be
//// executed.
//// @param action The lexer action to execute at a particular offset in the
//// input {@link CharStream}.
//pub struct LexerIndexedCustomAction {
//  *BaseLexerAction
//
//  offset:              i32
//  lexerAction:         LexerAction
//  isPositionDependent: bool
//}
//
//impl LexerIndexedCustomAction {§//  pub fn new(&self, offset: i32, lexerAction: LexerAction) -> *LexerIndexedCustomAction {
//
//  let l = new(LexerIndexedCustomAction);
//  l.BaseLexerAction = NewBaseLexerAction(lexerAction.getActionType())
//
//  l.offset = offset
//  l.lexerAction = lexerAction
//  l.isPositionDependent = true
//
//  return l
//}
//
//// <p>This method calls {@link //execute} on the result of {@link //getAction}
//// using the provided {@code lexer}.</p>
//pub fn execute(&self, lexer: Lexer) {
//  // assume the input stream position was properly set by the calling code
//  l.lexerAction.execute(lexer)
//}
//
//pub fn Hash(&self, ) -> &str {
//  return strconv.Itoa(l.actionType) + strconv.Itoa(l.offset) + l.lexerAction.Hash()
//}
//
//pub fn equals(&self, other: LexerAction) -> bool {
//  if l == other {
//    return true
//  } else if _, let ok = other.(*LexerIndexedCustomAction); !ok {;
//    return false
//  } else {
//    return l.offset == other.(*LexerIndexedCustomAction).offset && l.lexerAction == other.(*LexerIndexedCustomAction).lexerAction
//  }
//}
