//package antlr
//
//import "strconv"
//
//const (
//	LexerActionTypeChannel  = 0 //The type of a {@link LexerChannelAction} action.
//	LexerActionTypeCustom   = 1 //The type of a {@link LexerCustomAction} action.
//	LexerActionTypeMode     = 2 //The type of a {@link LexerModeAction} action.
//	LexerActionTypeMore     = 3 //The type of a {@link LexerMoreAction} action.
//	LexerActionTypePopMode  = 4 //The type of a {@link LexerPopModeAction} action.
//	LexerActionTypePushMode = 5 //The type of a {@link LexerPushModeAction} action.
//	LexerActionTypeSkip     = 6 //The type of a {@link LexerSkipAction} action.
//	LexerActionTypeType     = 7 //The type of a {@link LexerTypeAction} action.
//)
//
//pub trait LexerAction {
//	getActionType() int
//	getIsPositionDependent() bool
//	execute(lexer Lexer)
//	Hash() string
//	equals(other LexerAction) bool
//}
//
//pub struct BaseLexerAction {
//	actionType          int
//	isPositionDependent bool
//}
//
//impl BaseLexerAction {§//  pub fn new(action int) -> *BaseLexerAction {
//	la := new(BaseLexerAction)
//
//	la.actionType = action
//	la.isPositionDependent = false
//
//	return la
//}
//
//pub fn execute(lexer Lexer) -> {
//	panic("Not implemented")
//}
//
//pub fn getActionType() -> int {
//	return b.actionType
//}
//
//pub fn getIsPositionDependent() -> bool {
//	return b.isPositionDependent
//}
//
//pub fn Hash() -> string {
//	return strconv.Itoa(b.actionType)
//}
//
//pub fn equals(other LexerAction) -> bool {
//	return b == other
//}
//
////
//// Implements the {@code Skip} lexer action by calling {@link Lexer//Skip}.
////
//// <p>The {@code Skip} command does not have any parameters, so l action is
//// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
//pub struct LexerSkipAction {
//	*BaseLexerAction
//}
//
//impl LexerSkipAction {§//  pub fn new() -> *LexerSkipAction {
//	la := new(LexerSkipAction)
//	la.BaseLexerAction = NewBaseLexerAction(LexerActionTypeSkip)
//	return la
//}
//
//// Provides a singleton instance of l parameterless lexer action.
//var LexerSkipActionINSTANCE = NewLexerSkipAction()
//
//pub fn execute(lexer Lexer) -> {
//	lexer.Skip()
//}
//
//pub fn String() -> string {
//	return "skip"
//}
//
////  Implements the {@code type} lexer action by calling {@link Lexer//setType}
//// with the assigned type.
//pub struct LexerTypeAction {
//	*BaseLexerAction
//
//	thetype int
//}
//
//impl LexerTypeAction {§//  pub fn new(thetype int) -> *LexerTypeAction {
//	l := new(LexerTypeAction)
//	l.BaseLexerAction = NewBaseLexerAction(LexerActionTypeType)
//	l.thetype = thetype
//	return l
//}
//
//pub fn execute(lexer Lexer) -> {
//	lexer.setType(l.thetype)
//}
//
//pub fn Hash() -> string {
//	return strconv.Itoa(l.actionType) + strconv.Itoa(l.thetype)
//}
//
//pub fn equals(other LexerAction) -> bool {
//	if l == other {
//		return true
//	} else if _, ok := other.(*LexerTypeAction); !ok {
//		return false
//	} else {
//		return l.thetype == other.(*LexerTypeAction).thetype
//	}
//}
//
//pub fn String() -> string {
//	return "actionType(" + strconv.Itoa(l.thetype) + ")"
//}
//
//// Implements the {@code pushMode} lexer action by calling
//// {@link Lexer//pushMode} with the assigned mode.
//pub struct LexerPushModeAction {
//	*BaseLexerAction
//
//	mode int
//}
//
//impl LexerPushModeAction {§//  pub fn new(mode int) -> *LexerPushModeAction {
//
//	l := new(LexerPushModeAction)
//	l.BaseLexerAction = NewBaseLexerAction(LexerActionTypePushMode)
//
//	l.mode = mode
//	return l
//}
//
//// <p>This action is implemented by calling {@link Lexer//pushMode} with the
//// value provided by {@link //getMode}.</p>
//pub fn execute(lexer Lexer) -> {
//	lexer.pushMode(l.mode)
//}
//
//pub fn Hash() -> string {
//	return strconv.Itoa(l.actionType) + strconv.Itoa(l.mode)
//}
//
//pub fn equals(other LexerAction) -> bool {
//	if l == other {
//		return true
//	} else if _, ok := other.(*LexerPushModeAction); !ok {
//		return false
//	} else {
//		return l.mode == other.(*LexerPushModeAction).mode
//	}
//}
//
//pub fn String() -> string {
//	return "pushMode(" + strconv.Itoa(l.mode) + ")"
//}
//
//// Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.
////
//// <p>The {@code popMode} command does not have any parameters, so l action is
//// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
//pub struct LexerPopModeAction {
//	*BaseLexerAction
//}
//
//impl LexerPopModeAction {§//  pub fn new() -> *LexerPopModeAction {
//
//	l := new(LexerPopModeAction)
//
//	l.BaseLexerAction = NewBaseLexerAction(LexerActionTypePopMode)
//
//	return l
//}
//
//var LexerPopModeActionINSTANCE = NewLexerPopModeAction()
//
//// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
//pub fn execute(lexer Lexer) -> {
//	lexer.popMode()
//}
//
//pub fn String() -> string {
//	return "popMode"
//}
//
//// Implements the {@code more} lexer action by calling {@link Lexer//more}.
////
//// <p>The {@code more} command does not have any parameters, so l action is
//// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
//
//pub struct LexerMoreAction {
//	*BaseLexerAction
//}
//
//impl LexerMoreAction {§//  pub fn new() -> *LexerMoreAction {
//	l := new(LexerMoreAction)
//	l.BaseLexerAction = NewBaseLexerAction(LexerActionTypeMore)
//
//	return l
//}
//
//var LexerMoreActionINSTANCE = NewLexerMoreAction()
//
//// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
//pub fn execute(lexer Lexer) -> {
//	lexer.More()
//}
//
//pub fn String() -> string {
//	return "more"
//}
//
//// Implements the {@code mode} lexer action by calling {@link Lexer//mode} with
//// the assigned mode.
//pub struct LexerModeAction {
//	*BaseLexerAction
//
//	mode int
//}
//
//impl LexerModeAction {§//  pub fn new(mode int) -> *LexerModeAction {
//	l := new(LexerModeAction)
//	l.BaseLexerAction = NewBaseLexerAction(LexerActionTypeMode)
//	l.mode = mode
//	return l
//}
//
//// <p>This action is implemented by calling {@link Lexer//mode} with the
//// value provided by {@link //getMode}.</p>
//pub fn execute(lexer Lexer) -> {
//	lexer.setMode(l.mode)
//}
//
//pub fn Hash() -> string {
//	return strconv.Itoa(l.actionType) + strconv.Itoa(l.mode)
//}
//
//pub fn equals(other LexerAction) -> bool {
//	if l == other {
//		return true
//	} else if _, ok := other.(*LexerModeAction); !ok {
//		return false
//	} else {
//		return l.mode == other.(*LexerModeAction).mode
//	}
//}
//
//pub fn String() -> string {
//	return "mode(" + strconv.Itoa(l.mode) + ")"
//}
//
//// Executes a custom lexer action by calling {@link Recognizer//action} with the
//// rule and action indexes assigned to the custom action. The implementation of
//// a custom action is added to the generated code for the lexer in an override
//// of {@link Recognizer//action} when the grammar is compiled.
////
//// <p>This class may represent embedded actions created with the <code>{...}</code>
//// syntax in ANTLR 4, as well as actions created for lexer commands where the
//// command argument could not be evaluated when the grammar was compiled.</p>
//
//// Constructs a custom lexer action with the specified rule and action
//// indexes.
////
//// @param ruleIndex The rule index to use for calls to
//// {@link Recognizer//action}.
//// @param actionIndex The action index to use for calls to
//// {@link Recognizer//action}.
//
//pub struct LexerCustomAction {
//	*BaseLexerAction
//	ruleIndex, actionIndex int
//}
//
//impl LexerCustomAction {§//  pub fn new(ruleIndex, actionIndex int) -> *LexerCustomAction {
//	l := new(LexerCustomAction)
//	l.BaseLexerAction = NewBaseLexerAction(LexerActionTypeCustom)
//	l.ruleIndex = ruleIndex
//	l.actionIndex = actionIndex
//	l.isPositionDependent = true
//	return l
//}
//
//// <p>Custom actions are implemented by calling {@link Lexer//action} with the
//// appropriate rule and action indexes.</p>
//pub fn execute(lexer Lexer) -> {
//	lexer.Action(nil, l.ruleIndex, l.actionIndex)
//}
//
//pub fn Hash() -> string {
//	return strconv.Itoa(l.actionType) + strconv.Itoa(l.ruleIndex) + strconv.Itoa(l.actionIndex)
//}
//
//pub fn equals(other LexerAction) -> bool {
//	if l == other {
//		return true
//	} else if _, ok := other.(*LexerCustomAction); !ok {
//		return false
//	} else {
//		return l.ruleIndex == other.(*LexerCustomAction).ruleIndex && l.actionIndex == other.(*LexerCustomAction).actionIndex
//	}
//}
//
//// Implements the {@code channel} lexer action by calling
//// {@link Lexer//setChannel} with the assigned channel.
//// Constructs a New{@code channel} action with the specified channel value.
//// @param channel The channel value to pass to {@link Lexer//setChannel}.
//pub struct LexerChannelAction {
//	*BaseLexerAction
//
//	channel int
//}
//
//impl LexerChannelAction {§//  pub fn new(channel int) -> *LexerChannelAction {
//	l := new(LexerChannelAction)
//	l.BaseLexerAction = NewBaseLexerAction(LexerActionTypeChannel)
//	l.channel = channel
//	return l
//}
//
//// <p>This action is implemented by calling {@link Lexer//setChannel} with the
//// value provided by {@link //getChannel}.</p>
//pub fn execute(lexer Lexer) -> {
//	lexer.setChannel(l.channel)
//}
//
//pub fn Hash() -> string {
//	return strconv.Itoa(l.actionType) + strconv.Itoa(l.channel)
//}
//
//pub fn equals(other LexerAction) -> bool {
//	if l == other {
//		return true
//	} else if _, ok := other.(*LexerChannelAction); !ok {
//		return false
//	} else {
//		return l.channel == other.(*LexerChannelAction).channel
//	}
//}
//
//pub fn String() -> string {
//	return "channel(" + strconv.Itoa(l.channel) + ")"
//}
//
//// This implementation of {@link LexerAction} is used for tracking input offsets
//// for position-dependent actions within a {@link LexerActionExecutor}.
////
//// <p>This action is not serialized as part of the ATN, and is only required for
//// position-dependent lexer actions which appear at a location other than the
//// end of a rule. For more information about DFA optimizations employed for
//// lexer actions, see {@link LexerActionExecutor//append} and
//// {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>
//
//// Constructs a Newindexed custom action by associating a character offset
//// with a {@link LexerAction}.
////
//// <p>Note: This class is only required for lexer actions for which
//// {@link LexerAction//isPositionDependent} returns {@code true}.</p>
////
//// @param offset The offset into the input {@link CharStream}, relative to
//// the token start index, at which the specified lexer action should be
//// executed.
//// @param action The lexer action to execute at a particular offset in the
//// input {@link CharStream}.
//pub struct LexerIndexedCustomAction {
//	*BaseLexerAction
//
//	offset              int
//	lexerAction         LexerAction
//	isPositionDependent bool
//}
//
//impl LexerIndexedCustomAction {§//  pub fn new(offset int, lexerAction LexerAction) -> *LexerIndexedCustomAction {
//
//	l := new(LexerIndexedCustomAction)
//	l.BaseLexerAction = NewBaseLexerAction(lexerAction.getActionType())
//
//	l.offset = offset
//	l.lexerAction = lexerAction
//	l.isPositionDependent = true
//
//	return l
//}
//
//// <p>This method calls {@link //execute} on the result of {@link //getAction}
//// using the provided {@code lexer}.</p>
//pub fn execute(lexer Lexer) -> {
//	// assume the input stream position was properly set by the calling code
//	l.lexerAction.execute(lexer)
//}
//
//pub fn Hash() -> string {
//	return strconv.Itoa(l.actionType) + strconv.Itoa(l.offset) + l.lexerAction.Hash()
//}
//
//pub fn equals(other LexerAction) -> bool {
//	if l == other {
//		return true
//	} else if _, ok := other.(*LexerIndexedCustomAction); !ok {
//		return false
//	} else {
//		return l.offset == other.(*LexerIndexedCustomAction).offset && l.lexerAction == other.(*LexerIndexedCustomAction).lexerAction
//	}
//}
