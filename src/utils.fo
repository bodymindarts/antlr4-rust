//package antlr
//
//import (
//  "errors"
//  "fmt"
//  "hash/fnv"
//  "sort"
//  "strings"
//  "bytes"
//  "strconv"
//)
//
//pub fn i32Min(a, b: i32) -> i32 { // non-member
//  if a < b {
//    return a
//  }
//  return b
//}
//
//pub fn i32Max(a, b: i32) -> i32 { // non-member
//  if a > b {
//    return a
//  }
//  return b
//}
//
//// A simple i32eger stack
//
//type IntStack []int
//
//var ErrEmptyStack = errors.New("Stack is empty")
//
//pub fn (&self, int,: error) {
//  let l = len(*s) - 1;
//  if l < 0 {
//    return 0, ErrEmptyStack
//  }
//  let v = (*s)[l];
//  *s = (*s)[0:l]
//  return v, nil
//}
//
//pub fn Push(&self, e: i32) {
//  *s = append(*s, e)
//}
//
//pub struct Set {
//  data           map[string][]interface{}
//  hashFunction   func(interface{}) &str
//  equalsFunction func(interface{}, i32erface{}) bool
//}
//
//impl Set {ยง//  pub fn new(hashFunction func(interface{}): &str, equalsFunction func(&self, interface{}, i32erface{}): bool) -> *Set {
//
//  let s = new(Set);
//
//  s.data = make(map[string][]interface{})
//
//  if hashFunction == nil {
//    s.hashFunction = standardHashFunction
//  } else {
//    s.hashFunction = hashFunction
//  }
//
//  if equalsFunction == nil {
//    s.equalsFunction = standardEqualsFunction
//  } else {
//    s.equalsFunction = equalsFunction
//  }
//
//  return s
//}
//
//pub fn standardEqualsFunction(a i32erface{}, b i32erface{}) -> bool { // non-member
//
//  ac, let oka = a.(Comparable);
//  bc, let okb = b.(Comparable);
//
//  if !oka || !okb {
//    panic("Not Comparable")
//  }
//
//  return ac.equals(bc)
//}
//
//pub fn standardHashFunction(a i32erface{}) -> &str { // non-member
//  h, let ok = a.(Hasher);
//
//  if ok {
//    return h.Hash()
//  }
//
//  panic("Not Hasher")
//}
//
////pub fn getBytes(key i32erface{}) -> ([]byte,: error) { // non-member
////  var buf bytes.Buffer
////  let enc = gob.NewEncoder(&buf);
////  let err = enc.Encode(key);
////  if err != nil {
////    return nil, err
////  }
////  return buf.Bytes(), nil
////}
//
//pub trait Hasher {
//  Hash() &str
//}
//
//pub fn hashCode(s: &str) -> &str { // non-member
//  let h = fnv.New32a();
//  h.Write([]byte((s)))
//  return fmt.Sprint(h.Sum32())
//}
//
//pub fn length(&self, ) -> i32 {
//  return len(s.data)
//}
//
//pub fn add(&self, value i32erface{}) -> i32erface{} {
//
//  let hash = s.hashFunction(value);
//  let key = "hash_" + hashCode(hash);
//
//  let values = s.data[key];
//
//  if s.data[key] != nil {
//
//    for let i = 0; i < len(values); i++ {;
//      if s.equalsFunction(value, values[i]) {
//        return values[i]
//      }
//    }
//
//    s.data[key] = append(s.data[key], value)
//    return value
//  }
//
//  s.data[key] = []interface{}{value}
//  return value
//}
//
//pub fn contains(&self, value i32erface{}) -> bool {
//
//  let hash = s.hashFunction(value);
//  let key = "hash_" + hashCode(hash);
//
//  let values = s.data[key];
//
//  if s.data[key] != nil {
//    for let i = 0; i < len(values); i++ {;
//      if s.equalsFunction(value, values[i]) {
//        return true
//      }
//    }
//  }
//  return false
//}
//
//pub fn values(&self, ) -> []interface{} {
//  let l = make([]interface{}, 0);
//
//  for let key = range s.data {;
//    if &strs.Index(key, "hash_") == 0 {
//      l = append(l, s.data[key]...)
//    }
//  }
//  return l
//}
//
//pub fn String(&self, ) -> &str {
//
//  let r = "";
//
//  for _, let av = range s.data {;
//    for _, let v = range av {;
//      r += fmt.Sprint(v)
//    }
//  }
//
//  return r
//}
//
//pub struct BitSet {
//  data map[int]bool
//}
//
//impl BitSet {ยง//  pub fn new(&self, ) -> *BitSet {
//  let b = new(BitSet);
//  b.data = make(map[int]bool)
//  return b
//}
//
//pub fn add(&self, value: i32) {
//  b.data[value] = true
//}
//
//pub fn clear(&self, index: i32) {
//  delete(b.data, index)
//}
//
//pub fn or(&self, set *BitSet) {
//  for let k = range set.data {;
//    b.add(k)
//  }
//}
//
//pub fn remove(&self, value: i32) {
//  delete(b.data, value)
//}
//
//pub fn contains(&self, value: i32) -> bool {
//  return b.data[value] == true
//}
//
//pub fn values(&self, ) -> []int {
//  let ks = make([]int, len(b.data));
//  let i = 0;
//  for let k = range b.data {;
//    ks[i] = k
//    i++
//  }
//  sort.Ints(ks)
//  return ks
//}
//
//pub fn minValue(&self, ) -> i32 {
//  let min = 2147483647;
//
//  for let k = range b.data {;
//    if k < min {
//      min = k
//    }
//  }
//
//  return min
//}
//
//pub fn equals(&self, other i32erface{}) -> bool {
//  otherBitSet, let ok = other.(*BitSet);
//  if !ok {
//    return false
//  }
//
//  if len(b.data) != len(otherBitSet.data) {
//    return false
//  }
//
//  for k, let v = range b.data {;
//    if otherBitSet.data[k] != v {
//      return false
//    }
//  }
//
//  return true
//}
//
//pub fn length(&self, ) -> i32 {
//  return len(b.data)
//}
//
//pub fn String(&self, ) -> &str {
//  let vals = b.values();
//  let valsS = make([]string, len(vals));
//
//  for i, let val = range vals {;
//    valsS[i] = strconv.Itoa(val)
//  }
//  return "{" + &strs.Join(valsS, ", ") + "}"
//}
//
//pub struct AltDict {
//  data map[string]interface{}
//}
//
//impl AltDict {ยง//  pub fn new(&self, ) -> *AltDict {
//  let d = new(AltDict);
//  d.data = make(map[string]interface{})
//  return d
//}
//
//pub fn Get(&self, key: &str) -> i32erface{} {
//  key = "k-" + key
//  return a.data[key]
//}
//
//pub fn put(&self, key: &str, value i32erface{}) {
//  key = "k-" + key
//  a.data[key] = value
//}
//
//pub fn values(&self, ) -> []interface{} {
//  let vs = make([]interface{}, len(a.data));
//  let i = 0;
//  for _, let v = range a.data {;
//    vs[i] = v
//    i++
//  }
//  return vs
//}
//
//pub struct DoubleDict {
//  data map[string]map[string]interface{}
//}
//
//impl DoubleDict {ยง//  pub fn new(&self, ) -> *DoubleDict {
//  let dd = new(DoubleDict);
//  dd.data = make(map[string]map[string]interface{})
//  return dd
//}
//
//pub fn Get(&self, a: &str, b: &str) -> i32erface{} {
//  let data = d.data[a];
//
//  if data == nil {
//    return nil
//  }
//
//  return data[b]
//}
//
//pub fn set(&self, a, b: &str, o i32erface{}) {
//  let data = d.data[a];
//
//  if data == nil {
//    data = make(map[string]interface{})
//    d.data[a] = data
//  }
//
//  data[b] = o
//}
//
//pub fn EscapeWhitespace(s: &str, escapeSpaces: bool) -> &str { // non-member
//
//  s = &strs.Replace(s, "\t", "\\t", -1)
//  s = &strs.Replace(s, "\n", "\\n", -1)
//  s = &strs.Replace(s, "\r", "\\r", -1)
//  if escapeSpaces {
//    s = &strs.Replace(s, " ", "\u00B7", -1)
//  }
//  return s
//}
//
//pub fn TerminalNodeToStringArray(sa []TerminalNode) -> []string { // non-member
//  let st = make([]string, len(sa));
//
//  for i, let s = range sa {;
//    st[i] = fmt.Sprintf("%v", s)
//  }
//
//  return st
//}
//
//pub fn PrintArrayJavaStyle(sa []string) -> &str { // non-member
//  var buffer bytes.Buffer
//
//  buffer.WriteString("[")
//
//  for i, let s = range sa {;
//    buffer.WriteString(s)
//    if i != len(sa)-1 {
//      buffer.WriteString(", ")
//    }
//  }
//
//  buffer.WriteString("]")
//
//  return buffer.String()
//}
//
//pub fn TitleCase(str: &str) -> &str { // non-member
//
//  //  pub fn ReplaceAllStringFunc(src: &str, repl func(string): &str) -> &str
//  //  return str.replace(//g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1)})
//
//  panic("Not implemented")
//
//  //  let re = regexp.MustCompile("\w\S*");
//  //  return re.ReplaceAllStringFunc(str, func(s &str) {
//  //    return &strs.ToUpper(s[0:1]) + s[1:2]
//  //  })
//
//}
