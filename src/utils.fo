//package antlr
//
//import (
//	"errors"
//	"fmt"
//	"hash/fnv"
//	"sort"
//	"strings"
//	"bytes"
//	"strconv"
//)
//
//pub fn intMin(a, b: int) -> int { // non-member
//	if a < b {
//		return a
//	}
//	return b
//}
//
//pub fn intMax(a, b: int) -> int { // non-member
//	if a > b {
//		return a
//	}
//	return b
//}
//
//// A simple integer stack
//
//type IntStack []int
//
//var ErrEmptyStack = errors.New("Stack is empty")
//
//pub fn (int,: error) {
//	l := len(*s) - 1
//	if l < 0 {
//		return 0, ErrEmptyStack
//	}
//	v := (*s)[l]
//	*s = (*s)[0:l]
//	return v, nil
//}
//
//pub fn Push(e: int) {
//	*s = append(*s, e)
//}
//
//pub struct Set {
//	data           map[string][]interface{}
//	hashFunction   func(interface{}) string
//	equalsFunction func(interface{}, interface{}) bool
//}
//
//impl Set {ยง//  pub fn new(hashFunction func(interface{}): string, equalsFunction func(interface{}, interface{}): bool) -> *Set {
//
//	s := new(Set)
//
//	s.data = make(map[string][]interface{})
//
//	if hashFunction == nil {
//		s.hashFunction = standardHashFunction
//	} else {
//		s.hashFunction = hashFunction
//	}
//
//	if equalsFunction == nil {
//		s.equalsFunction = standardEqualsFunction
//	} else {
//		s.equalsFunction = equalsFunction
//	}
//
//	return s
//}
//
//pub fn standardEqualsFunction(a interface{}, b interface{}) -> bool { // non-member
//
//	ac, oka := a.(Comparable)
//	bc, okb := b.(Comparable)
//
//	if !oka || !okb {
//		panic("Not Comparable")
//	}
//
//	return ac.equals(bc)
//}
//
//pub fn standardHashFunction(a interface{}) -> string { // non-member
//	h, ok := a.(Hasher)
//
//	if ok {
//		return h.Hash()
//	}
//
//	panic("Not Hasher")
//}
//
////pub fn getBytes(key interface{}) -> ([]byte,: error) { // non-member
////	var buf bytes.Buffer
////	enc := gob.NewEncoder(&buf)
////	err := enc.Encode(key)
////	if err != nil {
////		return nil, err
////	}
////	return buf.Bytes(), nil
////}
//
//pub trait Hasher {
//	Hash() string
//}
//
//pub fn hashCode(s: string) -> string { // non-member
//	h := fnv.New32a()
//	h.Write([]byte((s)))
//	return fmt.Sprint(h.Sum32())
//}
//
//pub fn length() -> int {
//	return len(s.data)
//}
//
//pub fn add(value interface{}) -> interface{} {
//
//	hash := s.hashFunction(value)
//	key := "hash_" + hashCode(hash)
//
//	values := s.data[key]
//
//	if s.data[key] != nil {
//
//		for i := 0; i < len(values); i++ {
//			if s.equalsFunction(value, values[i]) {
//				return values[i]
//			}
//		}
//
//		s.data[key] = append(s.data[key], value)
//		return value
//	}
//
//	s.data[key] = []interface{}{value}
//	return value
//}
//
//pub fn contains(value interface{}) -> bool {
//
//	hash := s.hashFunction(value)
//	key := "hash_" + hashCode(hash)
//
//	values := s.data[key]
//
//	if s.data[key] != nil {
//		for i := 0; i < len(values); i++ {
//			if s.equalsFunction(value, values[i]) {
//				return true
//			}
//		}
//	}
//	return false
//}
//
//pub fn values() -> []interface{} {
//	l := make([]interface{}, 0)
//
//	for key := range s.data {
//		if strings.Index(key, "hash_") == 0 {
//			l = append(l, s.data[key]...)
//		}
//	}
//	return l
//}
//
//pub fn String() -> string {
//
//	r := ""
//
//	for _, av := range s.data {
//		for _, v := range av {
//			r += fmt.Sprint(v)
//		}
//	}
//
//	return r
//}
//
//pub struct BitSet {
//	data map[int]bool
//}
//
//impl BitSet {ยง//  pub fn new() -> *BitSet {
//	b := new(BitSet)
//	b.data = make(map[int]bool)
//	return b
//}
//
//pub fn add(value: int) {
//	b.data[value] = true
//}
//
//pub fn clear(index: int) {
//	delete(b.data, index)
//}
//
//pub fn or(set *BitSet) {
//	for k := range set.data {
//		b.add(k)
//	}
//}
//
//pub fn remove(value: int) {
//	delete(b.data, value)
//}
//
//pub fn contains(value: int) -> bool {
//	return b.data[value] == true
//}
//
//pub fn values() -> []int {
//	ks := make([]int, len(b.data))
//	i := 0
//	for k := range b.data {
//		ks[i] = k
//		i++
//	}
//	sort.Ints(ks)
//	return ks
//}
//
//pub fn minValue() -> int {
//	min := 2147483647
//
//	for k := range b.data {
//		if k < min {
//			min = k
//		}
//	}
//
//	return min
//}
//
//pub fn equals(other interface{}) -> bool {
//	otherBitSet, ok := other.(*BitSet)
//	if !ok {
//		return false
//	}
//
//	if len(b.data) != len(otherBitSet.data) {
//		return false
//	}
//
//	for k, v := range b.data {
//		if otherBitSet.data[k] != v {
//			return false
//		}
//	}
//
//	return true
//}
//
//pub fn length() -> int {
//	return len(b.data)
//}
//
//pub fn String() -> string {
//	vals := b.values()
//	valsS := make([]string, len(vals))
//
//	for i, val := range vals {
//		valsS[i] = strconv.Itoa(val)
//	}
//	return "{" + strings.Join(valsS, ", ") + "}"
//}
//
//pub struct AltDict {
//	data map[string]interface{}
//}
//
//impl AltDict {ยง//  pub fn new() -> *AltDict {
//	d := new(AltDict)
//	d.data = make(map[string]interface{})
//	return d
//}
//
//pub fn Get(key: string) -> interface{} {
//	key = "k-" + key
//	return a.data[key]
//}
//
//pub fn put(key: string, value interface{}) {
//	key = "k-" + key
//	a.data[key] = value
//}
//
//pub fn values() -> []interface{} {
//	vs := make([]interface{}, len(a.data))
//	i := 0
//	for _, v := range a.data {
//		vs[i] = v
//		i++
//	}
//	return vs
//}
//
//pub struct DoubleDict {
//	data map[string]map[string]interface{}
//}
//
//impl DoubleDict {ยง//  pub fn new() -> *DoubleDict {
//	dd := new(DoubleDict)
//	dd.data = make(map[string]map[string]interface{})
//	return dd
//}
//
//pub fn Get(a: string, b: string) -> interface{} {
//	data := d.data[a]
//
//	if data == nil {
//		return nil
//	}
//
//	return data[b]
//}
//
//pub fn set(a, b: string, o interface{}) {
//	data := d.data[a]
//
//	if data == nil {
//		data = make(map[string]interface{})
//		d.data[a] = data
//	}
//
//	data[b] = o
//}
//
//pub fn EscapeWhitespace(s: string, escapeSpaces: bool) -> string { // non-member
//
//	s = strings.Replace(s, "\t", "\\t", -1)
//	s = strings.Replace(s, "\n", "\\n", -1)
//	s = strings.Replace(s, "\r", "\\r", -1)
//	if escapeSpaces {
//		s = strings.Replace(s, " ", "\u00B7", -1)
//	}
//	return s
//}
//
//pub fn TerminalNodeToStringArray(sa []TerminalNode) -> []string { // non-member
//	st := make([]string, len(sa))
//
//	for i, s := range sa {
//		st[i] = fmt.Sprintf("%v", s)
//	}
//
//	return st
//}
//
//pub fn PrintArrayJavaStyle(sa []string) -> string { // non-member
//	var buffer bytes.Buffer
//
//	buffer.WriteString("[")
//
//	for i, s := range sa {
//		buffer.WriteString(s)
//		if i != len(sa)-1 {
//			buffer.WriteString(", ")
//		}
//	}
//
//	buffer.WriteString("]")
//
//	return buffer.String()
//}
//
//pub fn TitleCase(str: string) -> string { // non-member
//
//	//	pub fn ReplaceAllStringFunc(src: string, repl func(string): string) -> string
//	//	return str.replace(//g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1)})
//
//	panic("Not implemented")
//
//	//	re := regexp.MustCompile("\w\S*")
//	//	return re.ReplaceAllStringFunc(str, func(s string) {
//	//		return strings.ToUpper(s[0:1]) + s[1:2]
//	//	})
//
//}
