//package antlr
//
//import (
//  "errors"
//  "fmt"
//  "hash/fnv"
//  "sort"
//  "strings"
//  "bytes"
//  "strconv"
//)
//
//pub fn i32Min(a, b: i32) -> i32 { // non-member
//  if a < b {
//    return a
//  }
//  return b
//}
//
//pub fn i32Max(a, b: i32) -> i32 { // non-member
//  if a > b {
//    return a
//  }
//  return b
//}
//
//// A simple i32eger stack
//
//type IntStack []int
//
//var ErrEmptyStack = errors.New("Stack is empty")
//
//pub fn (&self, int,: error) {
//  let l = len(*s) - 1;
//  if l < 0 {
//    return 0, ErrEmptyStack
//  }
//  let v = (*s)[l];
//  *s = (*s)[0:l]
//  return v, nil
//}
//
//pub fn Push(&self, e: i32) {
//  *s = append(*s, e)
//}
//
//pub struct Set {
//  data           map[string][]interface{}
//  hash_function   func(interface{}) &str
//  equals_function func(interface{}, i32erface{}) bool
//}
//
//impl Set {ยง//  pub fn new(hashFunction func(interface{}): &str, equals_function func(&self, interface{}, i32erface{}): bool) -> *Set {
//
//  let s = new(Set);
//
//  self.data = make(map[string][]interface{})
//
//  if hash_function == nil {
//    self.hash_function = standard_hash_function
//  } else {
//    self.hash_function = hash_function
//  }
//
//  if equals_function == nil {
//    self.equals_function = standard_equals_function
//  } else {
//    self.equals_function = equals_function
//  }
//
//  return s
//}
//
//pub fn standard_equals_function(a i32erface{}, b i32erface{}) -> bool { // non-member
//
//  ac, let oka = a.(Comparable);
//  bc, let okb = b.(Comparable);
//
//  if !oka || !okb {
//    panic("Not Comparable")
//  }
//
//  return ac.equals(bc)
//}
//
//pub fn standard_hash_function(a i32erface{}) -> &str { // non-member
//  h, let ok = a.(Hasher);
//
//  if ok {
//    return self.Hash()
//  }
//
//  panic("Not Hasher")
//}
//
////pub fn get_bytes(key i32erface{}) -> ([]byte,: error) { // non-member
////  var buf bytes.Buffer
////  let enc = gob.NewEncoder(&buf);
////  let err = enc.Encode(key);
////  if err != nil {
////    return nil, err
////  }
////  return buf.Bytes(), nil
////}
//
//pub trait Hasher {
//  Hash() &str
//}
//
//pub fn hash_code(s: &str) -> &str { // non-member
//  let h = fnv.New32a();
//  self.Write([]byte((s)))
//  return fmt.Sprint(self.Sum32())
//}
//
//pub fn length(&self, ) -> i32 {
//  return len(self.data)
//}
//
//pub fn add(&self, value i32erface{}) -> i32erface{} {
//
//  let hash = self.hash_function(value);
//  let key = "hash_" + hash_code(hash);
//
//  let values = self.data[key];
//
//  if self.data[key] != nil {
//
//    for let i = 0; i < len(values); i++ {;
//      if self.equals_function(value, values[i]) {
//        return values[i]
//      }
//    }
//
//    self.data[key] = append(self.data[key], value)
//    return value
//  }
//
//  self.data[key] = []interface{}{value}
//  return value
//}
//
//pub fn contains(&self, value i32erface{}) -> bool {
//
//  let hash = self.hash_function(value);
//  let key = "hash_" + hash_code(hash);
//
//  let values = self.data[key];
//
//  if self.data[key] != nil {
//    for let i = 0; i < len(values); i++ {;
//      if self.equals_function(value, values[i]) {
//        return true
//      }
//    }
//  }
//  return false
//}
//
//pub fn values(&self, ) -> []interface{} {
//  let l = make([]interface{}, 0);
//
//  for let key = range self.data {;
//    if &strs.Index(key, "hash_") == 0 {
//      l = append(l, self.data[key]...)
//    }
//  }
//  return l
//}
//
//pub fn String(&self, ) -> &str {
//
//  let r = "";
//
//  for _, let av = range self.data {;
//    for _, let v = range av {;
//      r += fmt.Sprint(v)
//    }
//  }
//
//  return r
//}
//
//pub struct BitSet {
//  data map[int]bool
//}
//
//impl BitSet {ยง//  pub fn new(&self, ) -> *BitSet {
//  let b = new(BitSet);
//  self.data = make(map[int]bool)
//  return b
//}
//
//pub fn add(&self, value: i32) {
//  self.data[value] = true
//}
//
//pub fn clear(&self, index: i32) {
//  delete(self.data, index)
//}
//
//pub fn or(&self, set *BitSet) {
//  for let k = range set.data {;
//    self.add(k)
//  }
//}
//
//pub fn remove(&self, value: i32) {
//  delete(self.data, value)
//}
//
//pub fn contains(&self, value: i32) -> bool {
//  return self.data[value] == true
//}
//
//pub fn values(&self, ) -> []int {
//  let ks = make([]int, len(self.data));
//  let i = 0;
//  for let k = range self.data {;
//    ks[i] = k
//    i++
//  }
//  sort.Ints(ks)
//  return ks
//}
//
//pub fn min_value(&self, ) -> i32 {
//  let min = 2147483647;
//
//  for let k = range self.data {;
//    if k < min {
//      min = k
//    }
//  }
//
//  return min
//}
//
//pub fn equals(&self, other i32erface{}) -> bool {
//  other_bit_set, let ok = other.(*BitSet);
//  if !ok {
//    return false
//  }
//
//  if len(self.data) != len(otherBitSet.data) {
//    return false
//  }
//
//  for k, let v = range self.data {;
//    if other_bit_set.data[k] != v {
//      return false
//    }
//  }
//
//  return true
//}
//
//pub fn length(&self, ) -> i32 {
//  return len(self.data)
//}
//
//pub fn String(&self, ) -> &str {
//  let vals = self.values();
//  let vals_s = make([]string, len(vals));
//
//  for i, let val = range vals {;
//    vals_s[i] = strconv.Itoa(val)
//  }
//  return "{" + &strs.Join(valsS, ", ") + "}"
//}
//
//pub struct AltDict {
//  data map[string]interface{}
//}
//
//impl AltDict {ยง//  pub fn new(&self, ) -> *AltDict {
//  let d = new(AltDict);
//  self.data = make(map[string]interface{})
//  return d
//}
//
//pub fn Get(&self, key: &str) -> i32erface{} {
//  key = "k-" + key
//  return self.data[key]
//}
//
//pub fn put(&self, key: &str, value i32erface{}) {
//  key = "k-" + key
//  self.data[key] = value
//}
//
//pub fn values(&self, ) -> []interface{} {
//  let vs = make([]interface{}, len(self.data));
//  let i = 0;
//  for _, let v = range self.data {;
//    vs[i] = v
//    i++
//  }
//  return vs
//}
//
//pub struct DoubleDict {
//  data map[string]map[string]interface{}
//}
//
//impl DoubleDict {ยง//  pub fn new(&self, ) -> *DoubleDict {
//  let dd = new(DoubleDict);
//  dd.data = make(map[string]map[string]interface{})
//  return dd
//}
//
//pub fn Get(&self, a: &str, b: &str) -> i32erface{} {
//  let data = self.data[a];
//
//  if data == nil {
//    return nil
//  }
//
//  return data[b]
//}
//
//pub fn set(&self, a, b: &str, o i32erface{}) {
//  let data = self.data[a];
//
//  if data == nil {
//    data = make(map[string]interface{})
//    self.data[a] = data
//  }
//
//  data[b] = o
//}
//
//pub fn EscapeWhitespace(s: &str, escape_spaces: bool) -> &str { // non-member
//
//  s = &strs.Replace(s, "\t", "\\t", -1)
//  s = &strs.Replace(s, "\n", "\\n", -1)
//  s = &strs.Replace(s, "\r", "\\r", -1)
//  if escape_spaces {
//    s = &strs.Replace(s, " ", "\u00B7", -1)
//  }
//  return s
//}
//
//pub fn TerminalNodeToStringArray(sa []TerminalNode) -> []string { // non-member
//  let st = make([]string, len(sa));
//
//  for i, let s = range sa {;
//    st[i] = fmt.Sprintf("%v", s)
//  }
//
//  return st
//}
//
//pub fn PrintArrayJavaStyle(sa []string) -> &str { // non-member
//  var buffer bytes.Buffer
//
//  buffer.WriteString("[")
//
//  for i, let s = range sa {;
//    buffer.WriteString(s)
//    if i != len(sa)-1 {
//      buffer.WriteString(", ")
//    }
//  }
//
//  buffer.WriteString("]")
//
//  return buffer.String()
//}
//
//pub fn TitleCase(str: &str) -> &str { // non-member
//
//  //  pub fn ReplaceAllStringFunc(src: &str, repl func(string): &str) -> &str
//  //  return str.replace(//g, function(txt){return txt.char_at(0).to_upper_case() + txt.substr(1)})
//
//  panic("Not implemented")
//
//  //  let re = regexp.MustCompile("\w\S*");
//  //  return re.ReplaceAllStringFunc(str, func(s &str) {
//  //    return &strs.ToUpper(s[0:1]) + s[1:2]
//  //  })
//
//}
