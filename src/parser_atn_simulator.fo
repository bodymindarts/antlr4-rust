//package antlr
//
//import (
//  "fmt"
//  "strconv"
//  "strings"
//)
//
//var (
//  ParserATNSimulatorDebug = false
//  ParserATNSimulatorListATNDecisions = false
//  ParserATNSimulatorDFADebug = false
//  ParserATNSimulatorRetryDebug = false
//)
//
//pub struct ParserATNSimulator {
//  *BaseATNSimulator
//
//  parser:         Parser
//  prediction_mode: i32
//  input:          TokenStream
//  start_index:     i32
//  dfa:            *DFA
//  merge_cache:     *DoubleDict
//  outer_context:   ParserRuleContext
//}
//
//impl ParserATNSimulator {ยง//  fn new(&self, parser: Parser, atn *ATN, decision_to_dfa []*DFA, shared_context_cache *PredictionContextCache) -> *ParserATNSimulator {
//
//  let p = new(ParserATNSimulator);
//
//  self.base_atn_simulator = NewBaseATNSimulator(atn, shared_context_cache)
//
//  self.parser = parser
//  self.decision_to_dfa = decision_to_dfa
//  // SLL, LL, or LL + exact ambig detection?//
//  self.prediction_mode = PredictionModeLL
//  // LAME globals to avoid parameters!!!!! I need these down deep in pred_transition
//  self.input = nil
//  self.start_index = 0
//  self.outer_context = nil
//  self.dfa = nil
//  // Each prediction operation uses a cache for merge of prediction contexts.
//  //  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
//  //  isn't Synchronized but we're ok since two threads shouldn't reuse same
//  //  parser/atnsim object because it can only handle one input at a time.
//  //  This maps graphs a and b to merged result c. (a,b)&rarrc. We can avoid
//  //  the merge if we ever see a and b again.  Note that (b,a)&rarrc should
//  //  also be examined during cache lookup.
//  //
//  self.merge_cache = nil
//
//  return p
//}
//
//pub fn prediction_mode(&self) -> i32 {
//  return self.prediction_mode
//}
//
//pub fn set_prediction_mode(&self, v: i32) {
//  self.prediction_mode = v
//}
//
//fn reset(&self) {
//}
//
//pub fn adaptive_predict(&self, input TokenStream, decision: i32, outer_context: ParserRuleContext) -> i32 {
//  if ParserATNSimulatorDebug || ParserATNSimulatorListATNDecisions {
//    fmt.println("AdaptivePredict decision " + strconv.itoa(decision) +
//      " exec LA(1)==" + self.lookahead_name(input) +
//      " line " + strconv.itoa(input.l_t(1).line()) + ":" +
//      strconv.itoa(input.l_t(1).column()))
//  }
//
//  self.input = input
//  self.start_index = input.index()
//  self.outer_context = outer_context
//
//  let dfa = self.decision_to_dfa[decision];
//  self.dfa = dfa
//  let m = input.mark();
//  let index = input.index();
//
//  defer func() {
//    self.dfa = nil
//    self.merge_cache = nil // wack cache after each prediction
//    input.seek(index)
//    input.release(m)
//  }()
//
//  // Now we are certain to have a specific decision's DFA
//  // But, do we still need an initial state?
//  var s0 *DFAState
//  if dfa.precedence_dfa {
//    // the start state for a precedence DFA depends on the current
//    // parser precedence, and is provided by a DFA method.
//    s0 = dfa.precedence_start_state(self.parser.precedence())
//  } else {
//    // the start state for a "regular" DFA is just s0
//    s0 = dfa.s0
//  }
//
//  if s0 == nil {
//    if outer_context == nil {
//      outer_context = RuleContextEmpty
//    }
//    if ParserATNSimulatorDebug || ParserATNSimulatorListATNDecisions {
//      fmt.println("predictATN decision " + strconv.itoa(dfa.decision) +
//        " exec LA(1)==" + self.lookahead_name(input) +
//        ", outer_context=" + outer_context.string(self.parser.rule_names(), nil))
//    }
//    // If p is not a precedence DFA, we check the ATN start state
//    // to determine if p ATN start state is the decision for the
//    // closure block that determines whether a precedence rule
//    // should continue or complete.
//
//  let t2 = dfa.atn_start_state;
//    t, let ok = t2.(*StarLoopEntryState);
//    if !dfa.precedence_dfa && ok {
//      if self.precedence_rule_decision {
//        dfa.set_precedence_dfa(true)
//      }
//    }
//    let full_ctx = false;
//    let s0Closure = self.compute_start_state(dfa.atn_start_state, RuleContextEmpty, full_ctx);
//
//    if dfa.precedence_dfa {
//      // If p is a precedence DFA, we use apply_precedence_filter
//      // to convert the computed start state to a precedence start
//      // state. We then use DFA.set_precedence_start_state to set the
//      // appropriate start state for the precedence level rather
//      // than simply setting DFA.s0.
//      //
//      s0Closure = self.apply_precedence_filter(s0Closure)
//      s0 = self.add_dfa_state(dfa, NewDFAState(-1, s0Closure))
//      dfa.set_precedence_start_state(self.parser.precedence(), s0)
//    } else {
//      s0 = self.add_dfa_state(dfa, NewDFAState(-1, s0Closure))
//      dfa.s0 = s0
//    }
//  }
//  let alt = self.exec_atn(dfa, s0, input, index, outer_context);
//  if ParserATNSimulatorDebug {
//    fmt.println("DFA after predict_atn: " + dfa.string(self.parser.literal_names(), nil))
//  }
//  return alt
//
//}
//
//// Performs ATN simulation to compute a predicted alternative based
////  upon the remaining input, but also updates the DFA cache to avoid
////  having to traverse the ATN again for the same input sequence.
//
//// There are some key conditions we're looking for after computing a new
//// set of ATN configs (proposed DFA state):
//// if the set is empty, there is no viable alternative for current symbol
//// does the state uniquely predict an alternative?
//// does the state have a conflict that would prevent us from
////   putting it on the work list?
//
//// We also have some key operations to do:
//// add an edge from previous DFA state to potentially NewDFA state, D,
////   upon current symbol but only if adding to work list, which means in all
////   cases except no viable alternative (and possibly non-greedy decisions?)
//// collecting predicates and adding semantic context to DFA accept states
//// adding rule context to context-sensitive DFA accept states
//// consuming an input symbol
//// Reporting a conflict
//// Reporting an ambiguity
//// Reporting a context sensitivity
//// Reporting insufficient predicates
//
//// cover these cases:
////    dead end
////    single alt
////    single alt + preds
////    conflict
////    conflict + preds
////
//fn exec_atn(&self, dfa *DFA, s0 *DFAState, input TokenStream, start_index: i32, outer_context: ParserRuleContext) -> i32 {
//
//  if ParserATNSimulatorDebug || ParserATNSimulatorListATNDecisions {
//    fmt.println("execATN decision " + strconv.itoa(dfa.decision) +
//      " exec LA(1)==" + self.lookahead_name(input) +
//      " line " + strconv.itoa(input.l_t(1).line()) + ":" + strconv.itoa(input.l_t(1).column()))
//  }
//
//  let previous_d = s0;
//
//  if ParserATNSimulatorDebug {
//    fmt.println("s0 = " + s0.string())
//  }
//  let t = input.l_a(1);
//  for { // for more work
//    let D = self.existing_target_state(previousD, t);
//    if D == nil {
//      D = self.compute_target_state(dfa, previous_d, t)
//    }
//    if D == ATNSimulatorError {
//      // if any configs in previous dipped i32o outer context, that
//      // means that input up to t actually finished entry rule
//      // at least for SLL decision. Full LL doesn't dip i32o outer
//      // so don't need special case.
//      // We will get an error no matter what so delay until after
//      // decision better error message. Also, no reachable target
//      // ATN states in SLL implies LL will also get nowhere.
//      // If conflict in states that dip out, choose min since we
//      // will get error no matter what.
//      let e = self.no_viable_alt(input, outer_context, previous_d.configs, start_index);
//      input.seek(startIndex)
//      let alt = self.syn_valid_or_sem_invalid_alt_that_finished_decisionEntryRule(previousD.configs, outer_context);
//      if alt != ATNInvalidAltNumber {
//        return alt
//      }
//
//      panic(e)
//    }
//    if D.requires_full_context && self.prediction_mode != PredictionModeSLL {
//      // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)
//      let conflicting_alts = D.configs.conflicting_alts();
//      if D.predicates != nil {
//        if ParserATNSimulatorDebug {
//          fmt.println("DFA state has preds in DFA sim LL failover")
//        }
//        let conflict_index = input.index();
//        if conflict_index != start_index {
//          input.seek(startIndex)
//        }
//        conflicting_alts = self.eval_semantic_context(D.predicates, outer_context, true)
//        if conflicting_alts.length() == 1 {
//          if ParserATNSimulatorDebug {
//            fmt.println("Full LL avoided")
//          }
//          return conflicting_alts.min_value()
//        }
//        if conflict_index != start_index {
//          // restore the index so Reporting the fallback to full
//          // context occurs with the index at the correct spot
//          input.seek(conflictIndex)
//        }
//      }
//      if ParserATNSimulatorDFADebug {
//        fmt.println("ctx sensitive state " + outer_context.string(nil, nil) + " in " + D.string())
//      }
//      let full_ctx = true;
//      let s0Closure = self.compute_start_state(dfa.atn_start_state, outer_context, full_ctx);
//      self.report_attempting_full_context(dfa, conflicting_alts, D.configs, start_index, input.index())
//      let alt = self.exec_atn_with_full_context(dfa, D, s0Closure, input, start_index, outer_context);
//      return alt
//    }
//    if D.is_accept_state {
//      if D.predicates == nil {
//        return D.prediction
//      }
//      let stop_index = input.index();
//      input.seek(startIndex)
//      let alts = self.eval_semantic_context(D.predicates, outer_context, true);
//      if alts.length() == 0 {
//        panic(self.no_viable_alt(input, outer_context, D.configs, start_index))
//      } else if alts.length() == 1 {
//        return alts.min_value()
//      } else {
//        // Report ambiguity after predicate evaluation to make sure the correct set of ambig alts is Reported.
//        self.report_ambiguity(dfa, D, start_index, stop_index, false, alts, D.configs)
//        return alts.min_value()
//      }
//    }
//    previous_d = D
//
//    if t != TokenEOF {
//      input.consume()
//      t = input.l_a(1)
//    }
//  }
//
//  panic("Should not have reached p state")
//}
//
//// Get an existing target state for an edge in the DFA. If the target state
//// for the edge has not yet been computed or is otherwise not available,
//// p method returns {@code nil}.
////
//// @param previous_d The current DFA state
//// @param t The next input symbol
//// @return The existing target DFA state for the given input symbol
//// {@code t}, or {@code nil} if the target state for p edge is not
//// already cached
//
//fn existing_target_state(&self, previous_d *DFAState, t: i32) -> *DFAState {
//  let edges = previous_d.edges;
//  if edges == nil {
//    return nil
//  }
//
//  return edges[t+1]
//}
//
//// Compute a target state for an edge in the DFA, and attempt to add the
//// computed state and corresponding edge to the DFA.
////
//// @param dfa The DFA
//// @param previous_d The current DFA state
//// @param t The next input symbol
////
//// @return The computed target DFA state for the given input symbol
//// {@code t}. If {@code t} does not lead to a valid DFA state, p method
//// returns {@link //ERROR}.
//
//fn compute_target_state(&self, dfa *DFA, previous_d *DFAState, t: i32) -> *DFAState {
//  let reach = self.compute_reach_set(previousD.configs, t, false);
//
//  if reach == nil {
//    self.add_dfa_edge(dfa, previous_d, t, ATNSimulatorError)
//    return ATNSimulatorError
//  }
//  // create Newtarget state we'll add to DFA after it's complete
//  let D = NewDFAState(-1, reach);
//
//  let predicted_alt = self.unique_alt(reach);
//
//  if ParserATNSimulatorDebug {
//    let alt_sub_sets = PredictionModegetConflictingAltSubsets(reach);
//    fmt.println("SLL alt_sub_sets=" + fmt.sprint(altSubSets) +
//      ", previous=" + previous_d.configs.string() +
//      ", configs=" + reach.string() +
//      ", predict=" + strconv.itoa(predictedAlt) +
//      ", all_subsets_conflict=" +
//      fmt.sprint(PredictionModeallSubsetsConflict(altSubSets)) +
//      ", conflicting_alts=" + self.conflicting_alts(reach).string())
//  }
//  if predicted_alt != ATNInvalidAltNumber {
//    // NO CONFLICT, UNIQUELY PREDICTED ALT
//    D.is_accept_state = true
//    D.configs.set_unique_alt(predictedAlt)
//    D.set_prediction(predictedAlt)
//  } else if PredictionModehasSLLConflictTerminatingPrediction(self.prediction_mode, reach) {
//    // MORE THAN ONE VIABLE ALTERNATIVE
//    D.configs.set_conflicting_alts(self.conflicting_alts(reach))
//    D.requires_full_context = true
//    // in SLL-only mode, we will stop at p state and return the minimum alt
//    D.is_accept_state = true
//    D.set_prediction(D.configs.conflicting_alts().min_value())
//  }
//  if D.is_accept_state && D.configs.has_semantic_context() {
//    self.predicate_dfa_state(D, self.atn.decision_state(dfa.decision))
//    if D.predicates != nil {
//      D.set_prediction(ATNInvalidAltNumber)
//    }
//  }
//  // all adds to dfa are done after we've created full D state
//  D = self.add_dfa_edge(dfa, previous_d, t, D)
//  return D
//}
//
//fn predicate_dfa_state(&self, dfa_state *DFAState, decision_state: DecisionState) {
//  // We need to test all predicates, even in DFA states that
//  // uniquely predict alternative.
//  let nalts = len(decisionState.transitions());
//  // Update DFA so reach becomes accept state with (predicate,alt)
//  // pairs if preds found for conflicting alts
//  let alts_to_collect_preds_from = self.conflicting_alts_or_unique_alt(dfaState.configs);
//  let alt_to_pred = self.preds_for_ambig_alts(altsToCollectPredsFrom, dfa_state.configs, nalts);
//  if alt_to_pred != nil {
//    dfa_state.predicates = self.predicate_predictions(altsToCollectPredsFrom, alt_to_pred)
//    dfa_state.set_prediction(ATNInvalidAltNumber) // make sure we use preds
//  } else {
//    // There are preds in configs but they might go away
//    // when OR'd together like {p}? || NONE == NONE. If neither
//    // alt has preds, resolve to min alt
//    dfa_state.set_prediction(altsToCollectPredsFrom.min_value())
//  }
//}
//
//// comes back with reach.unique_alt set to a valid alt
//fn exec_atn_with_full_context(&self, dfa *DFA, D *DFAState, s0 ATNConfigSet, input TokenStream, start_index: i32, outer_context: ParserRuleContext) -> i32 {
//
//  if ParserATNSimulatorDebug || ParserATNSimulatorListATNDecisions {
//    fmt.println("execATNWithFullContext " + s0.string())
//  }
//
//  let full_ctx = true;
//  let found_exact_ambig = false;
//  var reach ATNConfigSet
//  let previous = s0;
//  input.seek(startIndex)
//  let t = input.l_a(1);
//  let predicted_alt = -1;
//
//  for { // for more work
//    reach = self.compute_reach_set(previous, t, full_ctx)
//    if reach == nil {
//      // if any configs in previous dipped i32o outer context, that
//      // means that input up to t actually finished entry rule
//      // at least for LL decision. Full LL doesn't dip i32o outer
//      // so don't need special case.
//      // We will get an error no matter what so delay until after
//      // decision better error message. Also, no reachable target
//      // ATN states in SLL implies LL will also get nowhere.
//      // If conflict in states that dip out, choose min since we
//      // will get error no matter what.
//      let e = self.no_viable_alt(input, outer_context, previous, start_index);
//      input.seek(startIndex)
//      let alt = self.syn_valid_or_sem_invalid_alt_that_finished_decisionEntryRule(previous, outer_context);
//      if alt != ATNInvalidAltNumber {
//        return alt
//      }
//
//      panic(e)
//    }
//    let alt_sub_sets = PredictionModegetConflictingAltSubsets(reach);
//    if ParserATNSimulatorDebug {
//      fmt.println("LL alt_sub_sets=" + fmt.sprint(altSubSets) + ", predict=" +
//        strconv.itoa(PredictionModegetUniqueAlt(altSubSets)) + ", resolves_to_just_one_viable_alt=" +
//        fmt.sprint(PredictionModeresolvesToJustOneViableAlt(altSubSets)))
//    }
//    reach.set_unique_alt(self.unique_alt(reach))
//    // unique prediction?
//    if reach.unique_alt() != ATNInvalidAltNumber {
//      predicted_alt = reach.unique_alt()
//      break
//    } else if self.prediction_mode != PredictionModeLLExactAmbigDetection {
//      predicted_alt = PredictionModeresolvesToJustOneViableAlt(altSubSets)
//      if predicted_alt != ATNInvalidAltNumber {
//        break
//      }
//    } else {
//      // In exact ambiguity mode, we never try to terminate early.
//      // Just keeps scarfing until we know what the conflict is
//      if PredictionModeallSubsetsConflict(altSubSets) && PredictionModeallSubsetsEqual(altSubSets) {
//        found_exact_ambig = true
//        predicted_alt = PredictionModegetSingleViableAlt(altSubSets)
//        break
//      }
//      // else there are multiple non-conflicting subsets or
//      // we're not sure what the ambiguity is yet.
//      // So, keep going.
//    }
//    previous = reach
//    if t != TokenEOF {
//      input.consume()
//      t = input.l_a(1)
//    }
//  }
//  // If the configuration set uniquely predicts an alternative,
//  // without conflict, then we know that it's a full LL decision
//  // not SLL.
//  if reach.unique_alt() != ATNInvalidAltNumber {
//    self.report_context_sensitivity(dfa, predicted_alt, reach, start_index, input.index())
//    return predicted_alt
//  }
//  // We do not check predicates here because we have checked them
//  // on-the-fly when doing full context prediction.
//
//  //
//  // In non-exact ambiguity detection mode, we might  actually be able to
//  // detect an exact ambiguity, but I'm not going to spend the cycles
//  // needed to check. We only emit ambiguity warnings in exact ambiguity
//  // mode.
//  //
//  // For example, we might know that we have conflicting configurations.
//  // But, that does not mean that there is no way forward without a
//  // conflict. It's possible to have nonconflicting alt subsets as in:
//
//  // alt_sub_sets=[{1, 2}, {1, 2}, {1}, {1, 2}]
//
//  // from
//  //
//  //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),
//  //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]
//  //
//  // In p case, (17,1,[5 $]) indicates there is some next sequence that
//  // would resolve p without conflict to alternative 1. Any other viable
//  // next sequence, however, is associated with a conflict.  We stop
//  // looking for input because no amount of further lookahead will alter
//  // the fact that we should predict alternative 1.  We just can't say for
//  // sure that there is an ambiguity without looking further.
//
//  self.report_ambiguity(dfa, D, start_index, input.index(), found_exact_ambig, nil, reach)
//
//  return predicted_alt
//}
//
//fn compute_reach_set(&self, closure ATNConfigSet, t: i32, full_ctx: bool) -> ATNConfigSet {
//  if ParserATNSimulatorDebug {
//    fmt.println("in compute_reach_set, starting closure: " + closure.string())
//  }
//  if self.merge_cache == nil {
//    self.merge_cache = NewDoubleDict()
//  }
//  let intermediate = NewBaseATNConfigSet(fullCtx);
//
//  // Configurations already in a rule stop state indicate reaching the end
//  // of the decision rule (local context) or end of the start rule (full
//  // context). Once reached, these configurations are never updated by a
//  // closure operation, so they are handled separately for the performance
//  // advantage of having a smaller i32ermediate set when calling closure.
//  //
//  // For full-context reach operations, separate handling is required to
//  // ensure that the alternative Matching the longest overall sequence is
//  // chosen when multiple such configurations can Match the input.
//
//  var SkippedStopStates []*BaseATNConfig
//
//  // First figure out where we can reach on input t
//  for _, let c = range closure.items() {;
//    if ParserATNSimulatorDebug {
//      fmt.println("testing " + self.token_name(t) + " at " + self.string())
//    }
//
//    _, let ok = self.state().(*RuleStopState);
//
//    if ok {
//      if full_ctx || t == TokenEOF {
//        if SkippedStopStates == nil {
//          SkippedStopStates = make([]*BaseATNConfig, 0)
//        }
//        SkippedStopStates = append(SkippedStopStates, c.(*BaseATNConfig))
//        if ParserATNSimulatorDebug {
//          fmt.println("added " + self.string() + " to SkippedStopStates")
//        }
//      }
//      continue
//    }
//
//    for let j = 0; j < len(self.state().transitions()); j++ {;
//      let trans = self.state().transitions()[j];
//      let target = self.reachable_target(trans, t);
//      if target != nil {
//        let cfg = NewBaseATNConfig4(c, target);
//        intermediate.add(cfg, self.merge_cache)
//        if ParserATNSimulatorDebug {
//          fmt.println("added " + cfg.string() + " to i32ermediate")
//        }
//      }
//    }
//  }
//  // Now figure out where the reach operation can take us...
//  var reach ATNConfigSet
//
//  // This block optimizes the reach operation for i32ermediate sets which
//  // trivially indicate a termination state for the overall
//  // AdaptivePredict operation.
//  //
//  // The conditions assume that i32ermediate
//  // contains all configurations relevant to the reach set, but p
//  // condition is not true when one or more configurations have been
//  // withheld in SkippedStopStates, or when the current symbol is EOF.
//  //
//  if SkippedStopStates == nil && t != TokenEOF {
//    if len(intermediate.configs) == 1 {
//      // Don't pursue the closure if there is just one state.
//      // It can only have one alternative just add to result
//      // Also don't pursue the closure if there is unique alternative
//      // among the configurations.
//      reach = i32ermediate
//    } else if self.unique_alt(intermediate) != ATNInvalidAltNumber {
//      // Also don't pursue the closure if there is unique alternative
//      // among the configurations.
//      reach = i32ermediate
//    }
//  }
//  // If the reach set could not be trivially determined, perform a closure
//  // operation on the i32ermediate set to compute its initial value.
//  //
//  if reach == nil {
//    reach = NewBaseATNConfigSet(fullCtx)
//    let closure_busy = NewSet(nil, nil);
//    let treat_e_o_f_as_epsilon = t == TokenEOF;
//    for let k = 0; k < len(intermediate.configs); k++ {;
//      self.closure(intermediate.configs[k], reach, closure_busy, false, full_ctx, treat_e_o_f_as_epsilon)
//    }
//  }
//  if t == TokenEOF {
//    // After consuming EOF no additional input is possible, so we are
//    // only i32erested in configurations which reached the end of the
//    // decision rule (local context) or end of the start rule (full
//    // context). Update reach to contain only these configurations. This
//    // handles both explicit EOF transitions in the grammar and implicit
//    // EOF transitions following the end of the decision or start rule.
//    //
//    // When reach==intermediate, no closure operation was performed. In
//    // p case, remove_all_configs_not_in_rule_stop_state needs to check for
//    // reachable rule stop states as well as configurations already in
//    // a rule stop state.
//    //
//    // This is handled before the configurations in SkippedStopStates,
//    // because any configurations potentially added from that list are
//    // already guaranteed to meet p condition whether or not it's
//    // required.
//    //
//    reach = self.remove_all_configs_not_in_rule_stop_state(reach, reach == i32ermediate)
//  }
//  // If SkippedStopStates!=nil, then it contains at least one
//  // configuration. For full-context reach operations, these
//  // configurations reached the end of the start rule, in which case we
//  // only add them back to reach if no configuration during the current
//  // closure operation reached such a state. This ensures AdaptivePredict
//  // chooses an alternative Matching the longest overall sequence when
//  // multiple alternatives are viable.
//  //
//  if SkippedStopStates != nil && ((!fullCtx) || (!PredictionModehasConfigInRuleStopState(reach))) {
//    for let l = 0; l < len(SkippedStopStates); l++ {;
//      reach.add(SkippedStopStates[l], self.merge_cache)
//    }
//  }
//  if len(reach.items()) == 0 {
//    return nil
//  }
//
//  return reach
//}
//
////
//// Return a configuration set containing only the configurations from
//// {@code configs} which are in a {@link RuleStopState}. If all
//// configurations in {@code configs} are already in a rule stop state, p
//// method simply returns {@code configs}.
////
//// <p>When {@code look_to_end_of_rule} is true, p method uses
//// {@link ATN//NextTokens} for each configuration in {@code configs} which is
//// not already in a rule stop state to see if a rule stop state is reachable
//// from the configuration via epsilon-only transitions.</p>
////
//// @param configs the configuration set to update
//// @param look_to_end_of_rule when true, p method checks for rule stop states
//// reachable by epsilon-only transitions from each configuration in
//// {@code configs}.
////
//// @return {@code configs} if all configurations in {@code configs} are in a
//// rule stop state, otherwise return a Newconfiguration set containing only
//// the configurations from {@code configs} which are in a rule stop state
////
//fn remove_all_configs_not_in_rule_stop_state(&self, configs: ATNConfigSet, look_to_end_of_rule: bool) -> ATNConfigSet {
//  if PredictionModeallConfigsInRuleStopStates(configs) {
//    return configs
//  }
//  let result = NewBaseATNConfigSet(configs.full_context());
//  for _, let config = range configs.items() {;
//
//    _, let ok = config.state().(*RuleStopState);
//
//    if ok {
//      result.add(config, self.merge_cache)
//      continue
//    }
//    if look_to_end_of_rule && config.state().epsilon_only_transitions() {
//      let NextTokens = self.atn.next_tokens(config.state(), nil);
//      if NextTokens.contains(TokenEpsilon) {
//        let end_of_rule_state = self.atn.rule_to_stop_state[config.state().rule_index()];
//        result.add(NewBaseATNConfig4(config, end_of_rule_state), self.merge_cache)
//      }
//    }
//  }
//  return result
//}
//
//fn compute_start_state(&self, a ATNState, ctx: RuleContext, full_ctx: bool) -> ATNConfigSet {
//  // always at least the implicit call to start rule
//  let initial_context = prediction_context_from_rule_context(self.atn, ctx);
//  let configs = NewBaseATNConfigSet(fullCtx);
//  for let i = 0; i < len(self.transitions()); i++ {;
//    let target = self.transitions()[i].target();
//    let c = NewBaseATNConfig6(target, i+1, initial_context);
//    let closure_busy = NewSet(nil, nil);
//    self.closure(c, configs, closure_busy, true, full_ctx, false)
//  }
//  return configs
//}
//
////
//// This method transforms the start state computed by
//// {@link //computeStartState} to the special start state used by a
//// precedence DFA for a particular precedence value. The transformation
//// process applies the following changes to the start state's configuration
//// set.
////
//// <ol>
//// <li>Evaluate the precedence predicates for each configuration using
//// {@link SemanticContext//evalPrecedence}.</li>
//// <li>Remove all configurations which predict an alternative greater than
//// 1, for which another configuration that predicts alternative 1 is in the
//// same ATN state with the same prediction context. This transformation is
//// valid for the following reasons:
//// <ul>
//// <li>The closure block cannot contain any epsilon transitions which bypass
//// the body of the closure, so all states reachable via alternative 1 are
//// part of the precedence alternatives of the transformed left-recursive
//// rule.</li>
//// <li>The "primary" portion of a left recursive rule cannot contain an
//// epsilon transition, so the only way an alternative other than 1 can exist
//// in a state that is also reachable via alternative 1 is by nesting calls
//// to the left-recursive rule, with the outer calls not being at the
//// preferred precedence level.</li>
//// </ul>
//// </li>
//// </ol>
////
//// <p>
//// The prediction context must be considered by p filter to address
//// situations like the following.
//// </p>
//// <code>
//// <pre>
//// grammar TA
//// prog: statement* EOF
//// statement: letter_a | statement letter_a 'b'
//// letter_a: 'a'
//// </pre>
//// </code>
//// <p>
//// If the above grammar, the ATN state immediately before the token
//// reference {@code 'a'} in {@code letter_a} is reachable from the left edge
//// of both the primary and closure blocks of the left-recursive rule
//// {@code statement}. The prediction context associated with each of these
//// configurations distinguishes between them, and prevents the alternative
//// which stepped out to {@code prog} (and then back in to {@code statement}
//// from being eliminated by the filter.
//// </p>
////
//// @param configs The configuration set computed by
//// {@link //computeStartState} as the start state for the DFA.
//// @return The transformed configuration set representing the start state
//// for a precedence DFA at a particular precedence level (determined by
//// calling {@link Parser//getPrecedence}).
////
//fn apply_precedence_filter(&self, configs: ATNConfigSet) -> ATNConfigSet {
//
//  let states_from_alt1 = make(map[int]PredictionContext);
//  let config_set = NewBaseATNConfigSet(configs.full_context());
//
//  for _, let config = range configs.items() {;
//    // handle alt 1 first
//    if config.alt() != 1 {
//      continue
//    }
//    let updated_context = config.semantic_context().eval_precedence(self.parser, self.outer_context);
//    if updated_context == nil {
//      // the configuration was eliminated
//      continue
//    }
//    states_from_alt1[config.state().state_number()] = config.context()
//    if updated_context != config.semantic_context() {
//      config_set.add(NewBaseATNConfig2(config, updated_context), self.merge_cache)
//    } else {
//      config_set.add(config, self.merge_cache)
//    }
//  }
//  for _, let config = range configs.items() {;
//
//    if config.alt() == 1 {
//      // already handled
//      continue
//    }
//    // In the future, p elimination step could be updated to also
//    // filter the prediction context for alternatives predicting alt>1
//    // (basically a graph subtraction algorithm).
//    if !config.precedence_filter_suppressed() {
//      let context = states_from_alt1[config.state().state_number()];
//      if context != nil && context.equals(config.context()) {
//        // eliminated
//        continue
//      }
//    }
//    config_set.add(config, self.merge_cache)
//  }
//  return config_set
//}
//
//fn reachable_target(&self, trans: Transition, ttype: i32) -> ATNState {
//  if trans.matches(ttype, 0, self.atn.max_token_type) {
//    return trans.target()
//  }
//
//  return nil
//}
//
//fn preds_for_ambig_alts(&self, ambig_alts *BitSet, configs: ATNConfigSet, nalts: i32) -> []SemanticContext {
//
//  let alt_to_pred = make([]SemanticContext, nalts+1);
//  for _, let c = range configs.items() {;
//    if ambig_alts.contains(self.alt()) {
//      alt_to_pred[self.alt()] = SemanticContextorContext(altToPred[self.alt()], self.semantic_context())
//    }
//  }
//  let n_pred_alts = 0;
//  for let i = 1; i < nalts+1; i++ {;
//    let pred = alt_to_pred[i];
//    if pred == nil {
//      alt_to_pred[i] = SemanticContextNone
//    } else if pred != SemanticContextNone {
//      n_pred_alts++
//    }
//  }
//  // nonambig alts are nil in alt_to_pred
//  if n_pred_alts == 0 {
//    alt_to_pred = nil
//  }
//  if ParserATNSimulatorDebug {
//    fmt.println("getPredsForAmbigAlts result " + fmt.sprint(altToPred))
//  }
//  return alt_to_pred
//}
//
//fn predicate_predictions(&self, ambig_alts *BitSet, alt_to_pred []SemanticContext) -> []*PredPrediction {
//  let pairs = make([]*PredPrediction, 0);
//  let contains_predicate = false;
//  for let i = 1; i < len(altToPred); i++ {;
//    let pred = alt_to_pred[i];
//    // unpredicated is indicated by SemanticContextNONE
//    if ambig_alts != nil && ambig_alts.contains(i) {
//      pairs = append(pairs, NewPredPrediction(pred, i))
//    }
//    if pred != SemanticContextNone {
//      contains_predicate = true
//    }
//  }
//  if !containsPredicate {
//    return nil
//  }
//  return pairs
//}
//
////
//// This method is used to improve the localization of error messages by
//// choosing an alternative rather than panicing a
//// {@link NoViableAltException} in particular prediction scenarios where the
//// {@link //ERROR} state was reached during ATN simulation.
////
//// <p>
//// The default implementation of p method uses the following
//// algorithm to identify an ATN configuration which successfully parsed the
//// decision entry rule. Choosing such an alternative ensures that the
//// {@link ParserRuleContext} returned by the calling rule will be complete
//// and valid, and the syntax error will be Reported later at a more
//// localized location.</p>
////
//// <ul>
//// <li>If a syntactically valid path or paths reach the end of the decision rule and
//// they are semantically valid if predicated, return the min associated alt.</li>
//// <li>Else, if a semantically invalid but syntactically valid path exist
//// or paths exist, return the minimum associated alt.
//// </li>
//// <li>Otherwise, return {@link ATN//INVALID__a_l_t__n_u_m_bER}.</li>
//// </ul>
////
//// <p>
//// In some scenarios, the algorithm described above could predict an
//// alternative which will result in a {@link FailedPredicateException} in
//// the parser. Specifically, p could occur if the <em>only</em> configuration
//// capable of successfully parsing to the end of the decision rule is
//// blocked by a semantic predicate. By choosing p alternative within
//// {@link //AdaptivePredict} instead of panicing a
//// {@link NoViableAltException}, the resulting
//// {@link FailedPredicateException} in the parser will identify the specific
//// predicate which is preventing the parser from successfully parsing the
//// decision rule, which helps developers identify and correct logic errors
//// in semantic predicates.
//// </p>
////
//// @param configs The ATN configurations which were valid immediately before
//// the {@link //ERROR} state was reached
//// @param outer_context The is the \gamma_0 initial parser context from the paper
//// or the parser stack at the instant before prediction commences.
////
//// @return The value to return from {@link //AdaptivePredict}, or
//// {@link ATN//INVALID__a_l_t__n_u_m_bER} if a suitable alternative was not
//// identified and {@link //AdaptivePredict} should Report an error instead.
////
//fn syn_valid_or_sem_invalid_alt_that_finished_decisionEntryRule(&self, configs: ATNConfigSet, outer_context: ParserRuleContext) -> i32 {
//  let cfgs = self.split_according_to_semantic_validity(configs, outer_context);
//  let sem_valid_configs = cfgs[0];
//  let sem_invalid_configs = cfgs[1];
//  let alt = self.alt_that_finished_decision_entryRule(semValidConfigs);
//  if alt != ATNInvalidAltNumber { // semantically/syntactically viable path exists
//    return alt
//  }
//  // Is there a syntactically valid path with a failed pred?
//  if len(semInvalidConfigs.items()) > 0 {
//    alt = self.alt_that_finished_decision_entryRule(semInvalidConfigs)
//    if alt != ATNInvalidAltNumber { // syntactically viable path exists
//      return alt
//    }
//  }
//  return ATNInvalidAltNumber
//}
//
//pub fn alt_that_finished_decision_entryRule(&self, configs: ATNConfigSet) -> i32 {
//  let alts = NewIntervalSet();
//
//  for _, let c = range configs.items() {;
//    _, let ok = self.state().(*RuleStopState);
//
//    if self.reaches_into_outer_context() > 0 || (ok && self.context().has_empty_path()) {
//      alts.add_one(self.alt())
//    }
//  }
//  if alts.length() == 0 {
//    return ATNInvalidAltNumber
//  }
//
//  return alts.first()
//}
//
//// Walk the list of configurations and split them according to
////  those that have preds evaluating to true/false.  If no pred, assume
////  true pred and include in succeeded set.  Returns Pair of sets.
////
////  Create a NewSet so as not to alter the incoming parameter.
////
////  Assumption: the input stream has been restored to the starting point
////  prediction, which is where predicates need to evaluate.
//
//pub struct ATNConfigSetPair {
//  item0, item1 ATNConfigSet
//}
//
//fn split_according_to_semantic_validity(&self, configs: ATNConfigSet, outer_context: ParserRuleContext) -> []ATNConfigSet {
//  let succeeded = NewBaseATNConfigSet(configs.full_context());
//  let failed = NewBaseATNConfigSet(configs.full_context());
//
//  for _, let c = range configs.items() {;
//    if self.semantic_context() != SemanticContextNone {
//      let predicate_evaluation_result = self.semantic_context().evaluate(self.parser, outer_context);
//      if predicate_evaluation_result {
//        succeeded.add(c, nil)
//      } else {
//        failed.add(c, nil)
//      }
//    } else {
//      succeeded.add(c, nil)
//    }
//  }
//  return []ATNConfigSet{succeeded, failed}
//}
//
//// Look through a list of predicate/alt pairs, returning alts for the
////  pairs that win. A {@code NONE} predicate indicates an alt containing an
////  unpredicated config which behaves as "always true." If !complete
////  then we stop at the first predicate that evaluates to true. This
////  includes pairs with nil predicates.
////
//fn eval_semantic_context(&self, pred_predictions []*PredPrediction, outer_context: ParserRuleContext, complete: bool) -> *BitSet {
//  let predictions = NewBitSet();
//  for let i = 0; i < len(predPredictions); i++ {;
//    let pair = pred_predictions[i];
//    if pair.pred == SemanticContextNone {
//      predictions.add(pair.alt)
//      if !complete {
//        break
//      }
//      continue
//    }
//
//    let predicate_evaluation_result = pair.pred.evaluate(self.parser, outer_context);
//    if ParserATNSimulatorDebug || ParserATNSimulatorDFADebug {
//      fmt.println("eval pred " + pair.string() + "=" + fmt.sprint(predicateEvaluationResult))
//    }
//    if predicate_evaluation_result {
//      if ParserATNSimulatorDebug || ParserATNSimulatorDFADebug {
//        fmt.println("PREDICT " + fmt.sprint(pair.alt))
//      }
//      predictions.add(pair.alt)
//      if !complete {
//        break
//      }
//    }
//  }
//  return predictions
//}
//
//fn closure(&self, config ATNConfig, configs ATNConfigSet, closure_busy *Set, collect_predicates,: full_ctx, treat_e_o_f_as_epsilon: bool) {
//  let initial_depth = 0;
//  self.closure_checking_stop_state(config, configs, closure_busy, collect_predicates,
//    full_ctx, initial_depth, treat_e_o_f_as_epsilon)
//}
//
//fn closure_checking_stop_state(&self, config ATNConfig, configs ATNConfigSet, closure_busy *Set, collect_predicates, full_ctx bool, depth: i32, treat_e_o_f_as_epsilon: bool) {
//
//  if ParserATNSimulatorDebug {
//    fmt.println("closure(" + config.string() + ")")
//    fmt.println("configs(" + configs.string() + ")")
//    if config.reaches_into_outer_context() > 50 {
//      panic("problem")
//    }
//  }
//
//  _, let ok = config.state().(*RuleStopState);
//  if ok {
//    // We hit rule end. If we have context info, use it
//    // run thru all possible stack tops in ctx
//    if !config.context().is_empty() {
//      for let i = 0; i < config.context().length(); i++ {;
//        if config.context().return_state(i) == BasePredictionContextEmptyReturnState {
//          if full_ctx {
//            configs.add(NewBaseATNConfig1(config, config.state(), BasePredictionContextEMPTY), self.merge_cache)
//            continue
//          } else {
//            // we have no context info, just chase follow links (if greedy)
//            if ParserATNSimulatorDebug {
//              fmt.println("FALLING off rule " + self.rule_name(config.state().rule_index()))
//            }
//            self.closure_work(config, configs, closure_busy, collect_predicates, full_ctx, depth, treat_e_o_f_as_epsilon)
//          }
//          continue
//        }
//        let return_state = self.atn.states[config.context().return_state(i)];
//        let new_context = config.context().parent(i) // "pop" return state;
//
//        let c = NewBaseATNConfig5(returnState, config.alt(), new_context, config.semantic_context());
//        // While we have context to pop back from, we may have
//        // gotten that context AFTER having falling off a rule.
//        // Make sure we track that we are now out of context.
//        self.set_reaches_into_outer_context(config.reaches_into_outer_context())
//        self.closure_checking_stop_state(c, configs, closure_busy, collect_predicates, full_ctx, depth-1, treat_e_o_f_as_epsilon)
//      }
//      return
//    } else if full_ctx {
//      // reached end of start rule
//      configs.add(config, self.merge_cache)
//      return
//    } else {
//      // else if we have no context info, just chase follow links (if greedy)
//      if ParserATNSimulatorDebug {
//        fmt.println("FALLING off rule " + self.rule_name(config.state().rule_index()))
//      }
//    }
//  }
//  self.closure_work(config, configs, closure_busy, collect_predicates, full_ctx, depth, treat_e_o_f_as_epsilon)
//}
//
//// Do the actual work of walking epsilon edges//
//fn closure_work(&self, config ATNConfig, configs ATNConfigSet, closure_busy *Set, collect_predicates, full_ctx bool, depth: i32, treat_e_o_f_as_epsilon: bool) {
//  let state = config.state();
//  // optimization
//  if !state.epsilon_only_transitions() {
//    configs.add(config, self.merge_cache)
//    // make sure to not return here, because EOF transitions can act as
//    // both epsilon transitions and non-epsilon transitions.
//  }
//  for let i = 0; i < len(state.transitions()); i++ {;
//    let t = state.transitions()[i];
//    _, let ok = t.(*ActionTransition);
//    let continue_collecting = collect_predicates && !ok;
//    let c = self.epsilon_target(config, t, continue_collecting, depth == 0, full_ctx, treat_e_o_f_as_epsilon);
//    if ci, let ok = c.(*BaseATNConfig); ok && ci != nil {;
//      if !self.is_epsilon() && closure_busy.add(c) != c {
//        // avoid infinite recursion for EOF* and EOF+
//        continue
//      }
//      let new_depth = depth;
//
//      if _, let ok = config.state().(*RuleStopState); ok {;
//
//        // target fell off end of rule mark resulting c as having dipped i32o outer context
//        // We can't get here if incoming config was rule stop and we had context
//        // track how far we dip i32o outer context.  Might
//        // come in handy and we avoid evaluating context dependent
//        // preds if p is > 0.
//
//        if closure_busy.add(c) != c {
//          // avoid infinite recursion for right-recursive rules
//          continue
//        }
//
//        if self.dfa != nil && self.dfa.precedence_dfa {
//          if t.(*EpsilonTransition).outermost_precedence_return == self.dfa.atn_start_state.rule_index() {
//            self.set_precedence_filter_suppressed(true)
//          }
//        }
//
//        self.set_reaches_into_outer_context(self.reaches_into_outer_context() + 1)
//        configs.set_dips_into_outer_context(true) // TODO: can remove? only care when we add to set per middle of p method
//        new_depth--
//        if ParserATNSimulatorDebug {
//          fmt.println("dips i32o outer ctx: " + self.string())
//        }
//      } else if _, let ok = t.(*RuleTransition); ok {;
//        // latch when new_depth goes negative - once we step out of the entry context we can't return
//        if new_depth >= 0 {
//          new_depth++
//        }
//      }
//      self.closure_checking_stop_state(c, configs, closure_busy, continue_collecting, full_ctx, new_depth, treat_e_o_f_as_epsilon)
//    }
//  }
//}
//
//fn rule_name(&self, index: i32) -> &str {
//  if self.parser != nil && index >= 0 {
//    return self.parser.rule_names()[index]
//  }
//
//  return "<rule " + fmt.sprint(index) + ">"
//}
//
//fn epsilon_target(&self, config ATNConfig, t Transition, collect_predicates, in_context,: full_ctx, treat_e_o_f_as_epsilon: bool) -> ATNConfig {
//
//  switch self.serialization_type() {
//  case TransitionRULE:
//    return self.rule_transition(config, t.(*RuleTransition))
//  case TransitionPRECEDENCE:
//    return self.precedence_transition(config, t.(*PrecedencePredicateTransition), collect_predicates, in_context, full_ctx)
//  case TransitionPREDICATE:
//    return self.pred_transition(config, t.(*PredicateTransition), collect_predicates, in_context, full_ctx)
//  case TransitionACTION:
//    return self.action_transition(config, t.(*ActionTransition))
//  case TransitionEPSILON:
//    return NewBaseATNConfig4(config, self.target())
//  case TransitionATOM:
//    // EOF transitions act like epsilon transitions after the first EOF
//    // transition is traversed
//    if treat_e_o_f_as_epsilon {
//      if self.matches(TokenEOF, 0, 1) {
//        return NewBaseATNConfig4(config, self.target())
//      }
//    }
//    return nil
//  case TransitionRANGE:
//    // EOF transitions act like epsilon transitions after the first EOF
//    // transition is traversed
//    if treat_e_o_f_as_epsilon {
//      if self.matches(TokenEOF, 0, 1) {
//        return NewBaseATNConfig4(config, self.target())
//      }
//    }
//    return nil
//  case TransitionSET:
//    // EOF transitions act like epsilon transitions after the first EOF
//    // transition is traversed
//    if treat_e_o_f_as_epsilon {
//      if self.matches(TokenEOF, 0, 1) {
//        return NewBaseATNConfig4(config, self.target())
//      }
//    }
//    return nil
//  default:
//    return nil
//  }
//}
//
//fn action_transition(&self, config: ATNConfig, t *ActionTransition) -> *BaseATNConfig {
//  if ParserATNSimulatorDebug {
//    fmt.println("ACTION edge " + strconv.itoa(self.rule_index) + ":" + strconv.itoa(self.action_index))
//  }
//  return NewBaseATNConfig4(config, self.target())
//}
//
//fn precedence_transition(config: ATNConfig,
//  pt *PrecedencePredicateTransition, collect_predicates, in_context, full_ctx bool) *BaseATNConfig {
//
//  if ParserATNSimulatorDebug {
//    fmt.println("PRED (collectPredicates=" + fmt.sprint(collectPredicates) + ") " +
//      strconv.itoa(pt.precedence) + ">=_p, ctx dependent=true")
//    if self.parser != nil {
//      fmt.println("context surrounding pred is " + fmt.sprint(self.parser.rule_invocation_stack(nil)))
//    }
//  }
//  var c *BaseATNConfig
//  if collect_predicates && in_context {
//    if full_ctx {
//      // In full context mode, we can evaluate predicates on-the-fly
//      // during closure, which dramatically reduces the size of
//      // the config sets. It also obviates the need to test predicates
//      // later during conflict resolution.
//      let current_position = self.input.index();
//      self.input.seek(self.start_index)
//      let pred_succeeds = pt.predicate().evaluate(self.parser, self.outer_context);
//      self.input.seek(currentPosition)
//      if pred_succeeds {
//        c = NewBaseATNConfig4(config, pt.target()) // no pred context
//      }
//    } else {
//      let new_sem_ctx = SemanticContextandContext(config.semantic_context(), pt.predicate());
//      c = NewBaseATNConfig3(config, pt.target(), new_sem_ctx)
//    }
//  } else {
//    c = NewBaseATNConfig4(config, pt.target())
//  }
//  if ParserATNSimulatorDebug {
//    fmt.println("config from pred transition=" + self.string())
//  }
//  return c
//}
//
//fn pred_transition(&self, config ATNConfig, pt *PredicateTransition, collect_predicates,: in_context, full_ctx: bool) -> *BaseATNConfig {
//
//  if ParserATNSimulatorDebug {
//    fmt.println("PRED (collectPredicates=" + fmt.sprint(collectPredicates) + ") " + strconv.itoa(pt.rule_index) +
//      ":" + strconv.itoa(pt.pred_index) + ", ctx dependent=" + fmt.sprint(pt.is_ctx_dependent))
//    if self.parser != nil {
//      fmt.println("context surrounding pred is " + fmt.sprint(self.parser.rule_invocation_stack(nil)))
//    }
//  }
//  var c *BaseATNConfig
//  if collect_predicates && ((pt.is_ctx_dependent && in_context) || !pt.is_ctx_dependent) {
//    if full_ctx {
//      // In full context mode, we can evaluate predicates on-the-fly
//      // during closure, which dramatically reduces the size of
//      // the config sets. It also obviates the need to test predicates
//      // later during conflict resolution.
//      let current_position = self.input.index();
//      self.input.seek(self.start_index)
//      let pred_succeeds = pt.predicate().evaluate(self.parser, self.outer_context);
//      self.input.seek(currentPosition)
//      if pred_succeeds {
//        c = NewBaseATNConfig4(config, pt.target()) // no pred context
//      }
//    } else {
//      let new_sem_ctx = SemanticContextandContext(config.semantic_context(), pt.predicate());
//      c = NewBaseATNConfig3(config, pt.target(), new_sem_ctx)
//    }
//  } else {
//    c = NewBaseATNConfig4(config, pt.target())
//  }
//  if ParserATNSimulatorDebug {
//    fmt.println("config from pred transition=" + self.string())
//  }
//  return c
//}
//
//fn rule_transition(&self, config: ATNConfig, t *RuleTransition) -> *BaseATNConfig {
//  if ParserATNSimulatorDebug {
//    fmt.println("CALL rule " + self.rule_name(self.target().rule_index()) + ", ctx=" + config.context().string())
//  }
//  let return_state = self.follow_state;
//  let new_context = SingletonBasePredictionContextCreate(config.context(), return_state.state_number());
//  return NewBaseATNConfig1(config, self.target(), new_context)
//}
//
//fn conflicting_alts(&self, configs: ATNConfigSet) -> *BitSet {
//  let altsets = PredictionModegetConflictingAltSubsets(configs);
//  return PredictionModeGetAlts(altsets)
//}
//
//// Sam pointed out a problem with the previous definition, v3, of
//// ambiguous states. If we have another state associated with conflicting
//// alternatives, we should keep going. For example, the following grammar
////
//// s : (ID | ID ID?) ''
////
//// When the ATN simulation reaches the state before '', it has a DFA
//// state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
//// 12|1|[] and 12|2|[] conflict, but we cannot stop processing p node
//// because alternative to has another way to continue, via [6|2|[]].
//// The key is that we have a single state that has config's only associated
//// with a single alternative, 2, and crucially the state transitions
//// among the configurations are all non-epsilon transitions. That means
//// we don't consider any conflicts that include alternative 2. So, we
//// ignore the conflict between alts 1 and 2. We ignore a set of
//// conflicting alts when there is an i32ersection with an alternative
//// associated with a single alt state in the state&rarrconfig-list map.
////
//// It's also the case that we might have two conflicting configurations but
//// also a 3rd nonconflicting configuration for a different alternative:
//// [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
////
//// a : A | A | A B
////
//// After Matching input A, we reach the stop state for rule A, state 1.
//// State 8 is the state right before B. Clearly alternatives 1 and 2
//// conflict and no amount of further lookahead will separate the two.
//// However, alternative 3 will be able to continue and so we do not
//// stop working on p state. In the previous example, we're concerned
//// with states associated with the conflicting alternatives. Here alt
//// 3 is not associated with the conflicting configs, but since we can continue
//// looking for input reasonably, I don't declare the state done. We
//// ignore a set of conflicting alts when we have an alternative
//// that we still need to pursue.
////
//
//fn conflicting_alts_or_unique_alt(&self, configs: ATNConfigSet) -> *BitSet {
//  var conflicting_alts *BitSet
//  if configs.unique_alt() != ATNInvalidAltNumber {
//    conflicting_alts = NewBitSet()
//    conflicting_alts.add(configs.unique_alt())
//  } else {
//    conflicting_alts = configs.conflicting_alts()
//  }
//  return conflicting_alts
//}
//
//pub fn token_name(&self, t: i32) -> &str {
//  if t == TokenEOF {
//    return "EOF"
//  }
//
//  if self.parser != nil && self.parser.literal_names() != nil {
//    if t >= len(self.parser.literal_names()) {
//      fmt.println(strconv.itoa(t) + " ttype out of range: " + &strs.join(self.parser.literal_names(), ","))
//      //      fmt.println(self.parser.input_stream().(TokenStream).all_text()) // p seems incorrect
//    } else {
//      return self.parser.literal_names()[t] + "<" + strconv.itoa(t) + ">"
//    }
//  }
//
//  return strconv.itoa(t)
//}
//
//fn lookahead_name(&self, input: TokenStream) -> &str {
//  return self.token_name(input.l_a(1))
//}
//
//// Used for debugging in AdaptivePredict around exec_atn but I cut
////  it out for clarity now that alg. works well. We can leave p
////  "dead" code for a bit.
////
//fn dump_dead_end_configs(&self, nvae *NoViableAltException) {
//
//  panic("Not implemented")
//
//  //    fmt.println("dead end configs: ")
//  //    var decs = nvae.dead_end_configs
//  //
//  //    for i:=0; i<len(decs); i++ {
//  //
//  //      let c = decs[i];
//  //        var trans = "no edges"
//  //        if (len(self.state.transitions())>0) {
//  //            var t = self.state.transitions()[0]
//  //            if t2, let ok = t.(*AtomTransition); ok {;
//  //                trans = "Atom "+ self.token_name(t2.label)
//  //            } else if t3, let ok = t.(SetTransition); ok {;
//  //                _, let ok = t.(*NotSetTransition);
//  //
//  //                var s &str
//  //                if (ok){
//  //                    s = "~"
//  //                }
//  //
//  //                trans = s + "Set " + t3.set
//  //            }
//  //        }
//  //        fmt.errorf(self.string(self.parser, true) + ":" + trans)
//  //    }
//}
//
//fn no_viable_alt(&self, input TokenStream, outer_context ParserRuleContext, configs: ATNConfigSet, start_index: i32) -> *NoViableAltException {
//  return NewNoViableAltException(self.parser, input, input.get(startIndex), input.l_t(1), configs, outer_context)
//}
//
//fn unique_alt(&self, configs: ATNConfigSet) -> i32 {
//  let alt = ATNInvalidAltNumber;
//  for _, let c = range configs.items() {;
//    if alt == ATNInvalidAltNumber {
//      alt = self.alt() // found first alt
//    } else if self.alt() != alt {
//      return ATNInvalidAltNumber
//    }
//  }
//  return alt
//}
//
////
//// Add an edge to the DFA, if possible. This method calls
//// {@link //addDFAState} to ensure the {@code to} state is present in the
//// DFA. If {@code from} is {@code nil}, or if {@code t} is outside the
//// range of edges that can be represented in the DFA tables, p method
//// returns without adding the edge to the DFA.
////
//// <p>If {@code to} is {@code nil}, p method returns {@code nil}.
//// Otherwise, p method returns the {@link DFAState} returned by calling
//// {@link //addDFAState} for the {@code to} state.</p>
////
//// @param dfa The DFA
//// @param from The source state for the edge
//// @param t The input symbol
//// @param to The target state for the edge
////
//// @return If {@code to} is {@code nil}, p method returns {@code nil}
//// otherwise p method returns the result of calling {@link //addDFAState}
//// on {@code to}
////
//fn add_dfa_edge(&self, dfa *DFA, from *DFAState, t: i32, to *DFAState) -> *DFAState {
//  if ParserATNSimulatorDebug {
//    fmt.println("EDGE " + from.string() + " -> " + to.string() + " upon " + self.token_name(t))
//  }
//  if to == nil {
//    return nil
//  }
//  to = self.add_dfa_state(dfa, to) // used existing if possible not incoming
//  if from == nil || t < -1 || t > self.atn.max_token_type {
//    return to
//  }
//  if from.edges == nil {
//    from.edges = make([]*DFAState, self.atn.max_token_type+1+1)
//  }
//  from.edges[t+1] = to // connect
//
//  if ParserATNSimulatorDebug {
//    var names []string
//    if self.parser != nil {
//      names = self.parser.literal_names()
//    }
//
//    fmt.println("DFA=\n" + dfa.string(names, nil))
//  }
//  return to
//}
//
////
//// Add state {@code D} to the DFA if it is not already present, and return
//// the actual instance stored in the DFA. If a state equivalent to {@code D}
//// is already in the DFA, the existing state is returned. Otherwise p
//// method returns {@code D} after adding it to the DFA.
////
//// <p>If {@code D} is {@link //ERROR}, p method returns {@link //ERROR} and
//// does not change the DFA.</p>
////
//// @param dfa The dfa
//// @param D The DFA state to add
//// @return The state stored in the DFA. This will be either the existing
//// state if {@code D} is already in the DFA, or {@code D} itself if the
//// state was not already present.
////
//fn add_dfa_state(&self, dfa *DFA, D *DFAState) -> *DFAState {
//  if D == ATNSimulatorError {
//    return D
//  }
//  let hash = D.hash();
//  var existing, ok = dfa.states()[hash]
//  if ok {
//    return existing
//  }
//  D.state_number = len(dfa.states())
//  if !D.configs.read_only() {
//    D.configs.optimize_configs(self.base_atn_simulator)
//    D.configs.set_read_only(true)
//  }
//  dfa.states()[hash] = D
//  if ParserATNSimulatorDebug {
//    fmt.println("adding NewDFA state: " + D.string())
//  }
//  return D
//}
//
//pub fn report_attempting_full_context(&self, dfa *DFA, conflicting_alts *BitSet, configs ATNConfigSet,: start_index, stop_index: i32) {
//  if ParserATNSimulatorDebug || ParserATNSimulatorRetryDebug {
//    let interval = NewInterval(startIndex, stop_index+1);
//    fmt.println("ReportAttemptingFullContext decision=" + strconv.itoa(dfa.decision) + ":" + configs.string() +
//      ", input=" + self.parser.token_stream().text_from_interval(interval))
//  }
//  if self.parser != nil {
//    self.parser.error_listener_dispatch().report_attempting_full_context(self.parser, dfa, start_index, stop_index, conflicting_alts, configs)
//  }
//}
//
//pub fn report_context_sensitivity(&self, dfa *DFA, prediction i32, configs ATNConfigSet,: start_index, stop_index: i32) {
//  if ParserATNSimulatorDebug || ParserATNSimulatorRetryDebug {
//    let interval = NewInterval(startIndex, stop_index+1);
//    fmt.println("ReportContextSensitivity decision=" + strconv.itoa(dfa.decision) + ":" + configs.string() +
//      ", input=" + self.parser.token_stream().text_from_interval(interval))
//  }
//  if self.parser != nil {
//    self.parser.error_listener_dispatch().report_context_sensitivity(self.parser, dfa, start_index, stop_index, prediction, configs)
//  }
//}
//
//// If context sensitive parsing, we know it's ambiguity not conflict//
//pub fn report_ambiguity(dfa *DFA, D *DFAState, start_index, stop_index: i32,
//  exact bool, ambig_alts *BitSet, configs ATNConfigSet) {
//  if ParserATNSimulatorDebug || ParserATNSimulatorRetryDebug {
//    let interval = NewInterval(startIndex, stop_index+1);
//    fmt.println("ReportAmbiguity " + ambig_alts.string() + ":" + configs.string() +
//      ", input=" + self.parser.token_stream().text_from_interval(interval))
//  }
//  if self.parser != nil {
//    self.parser.error_listener_dispatch().report_ambiguity(self.parser, dfa, start_index, stop_index, exact, ambig_alts, configs)
//  }
//}
