//package antlr
//
//import "strconv"
//
//// Constants for serialization.
//const (
//  ATNStateInvalidType    = 0
//  ATNStateBasic          = 1
//  ATNStateRuleStart      = 2
//  ATNStateBlockStart     = 3
//  ATNStatePlusBlockStart = 4
//  ATNStateStarBlockStart = 5
//  ATNStateTokenStart     = 6
//  ATNStateRuleStop       = 7
//  ATNStateBlockEnd       = 8
//  ATNStateStarLoopBack   = 9
//  ATNStateStarLoopEntry  = 10
//  ATNStatePlusLoopBack   = 11
//  ATNStateLoopEnd        = 12
//
//  ATNStateInvalidStateNumber = -1
//)
//
//var ATNStateInitialNumTransitions = 4
//
//pub trait ATNState {
//  GetEpsilonOnlyTransitions() bool
//
//  GetRuleIndex() i32
//  SetRuleIndex(int)
//
//  GetNextTokenWithinRule() *IntervalSet
//  SetNextTokenWithinRule(*IntervalSet)
//
//  GetATN() *ATN
//  SetATN(*ATN)
//
//  GetStateType() i32
//
//  GetStateNumber() i32
//  SetStateNumber(int)
//
//  GetTransitions() []Transition
//  SetTransitions([]Transition)
//  AddTransition(Transition, i32)
//
//  String() &str
//}
//
//pub struct BaseATNState {
//  // NextTokenWithinRule caches lookahead during parsing. Not used during construction.
//  NextTokenWithinRule: *IntervalSet
//
//  // atn is the current ATN.
//  atn: *ATN
//
//  epsilonOnlyTransitions: bool
//
//  // ruleIndex tracks the Rule index because there are no Rule objects at runtime.
//  ruleIndex: i32
//
//  stateNumber: i32
//
//  stateType: i32
//
//  // Track the transitions emanating from this ATN state.
//  transitions []Transition
//}
//
//impl BaseATNState {§//  pub fn new() -> *BaseATNState {
//  return &BaseATNState{stateNumber: ATNStateInvalidStateNumber, stateType: ATNStateInvalidType}
//}
//
//pub fn GetRuleIndex() -> i32 {
//  return as.ruleIndex
//}
//
//pub fn SetRuleIndex(v: i32) {
//  as.ruleIndex = v
//}
//pub fn GetEpsilonOnlyTransitions() -> bool {
//  return as.epsilonOnlyTransitions
//}
//
//pub fn GetATN() -> *ATN {
//  return as.atn
//}
//
//pub fn SetATN(atn *ATN) {
//  as.atn = atn
//}
//
//pub fn GetTransitions() -> []Transition {
//  return as.transitions
//}
//
//pub fn SetTransitions(t []Transition) {
//  as.transitions = t
//}
//
//pub fn GetStateType() -> i32 {
//  return as.stateType
//}
//
//pub fn GetStateNumber() -> i32 {
//  return as.stateNumber
//}
//
//pub fn SetStateNumber(stateNumber: i32) {
//  as.stateNumber = stateNumber
//}
//
//pub fn GetNextTokenWithinRule() -> *IntervalSet {
//  return as.NextTokenWithinRule
//}
//
//pub fn SetNextTokenWithinRule(v *IntervalSet) {
//  as.NextTokenWithinRule = v
//}
//
//pub fn String() -> &str {
//  return strconv.Itoa(as.stateNumber)
//}
//
//pub fn equals(other i32erface{}) -> bool {
//  if ot, ok := other.(ATNState); ok {
//    return as.stateNumber == ot.GetStateNumber()
//  }
//
//  return false
//}
//
//pub fn isNonGreedyExitState() -> bool {
//  return false
//}
//
//pub fn AddTransition(trans: Transition, index: i32) {
//  if len(as.transitions) == 0 {
//    as.epsilonOnlyTransitions = trans.getIsEpsilon()
//  } else if as.epsilonOnlyTransitions != trans.getIsEpsilon() {
//    as.epsilonOnlyTransitions = false
//  }
//
//  if index == -1 {
//    as.transitions = append(as.transitions, trans)
//  } else {
//    as.transitions = append(as.transitions[:index], append([]Transition{trans}, as.transitions[index:]...)...)
//    // TODO: as.transitions.splice(index, 1, trans)
//  }
//}
//
//pub struct BasicState {
//  *BaseATNState
//}
//
//impl BasicState {§//  pub fn new() -> *BasicState {
//  b := NewBaseATNState()
//
//  b.stateType = ATNStateBasic
//
//  return &BasicState{BaseATNState: b}
//}
//
//pub trait DecisionState {
//  ATNState
//
//  getDecision() i32
//  setDecision(int)
//
//  getNonGreedy() bool
//  setNonGreedy(bool)
//}
//
//pub struct BaseDecisionState {
//  *BaseATNState
//  decision:  i32
//  nonGreedy: bool
//}
//
//impl BaseDecisionState {§//  pub fn new() -> *BaseDecisionState {
//  return &BaseDecisionState{BaseATNState: NewBaseATNState(), decision: -1}
//}
//
//pub fn getDecision() -> i32 {
//  return s.decision
//}
//
//pub fn setDecision(b: i32) {
//  s.decision = b
//}
//
//pub fn getNonGreedy() -> bool {
//  return s.nonGreedy
//}
//
//pub fn setNonGreedy(b: bool) {
//  s.nonGreedy = b
//}
//
//pub trait BlockStartState {
//  DecisionState
//
//  getEndState() *BlockEndState
//  setEndState(*BlockEndState)
//}
//
//// BaseBlockStartState is the start of a regular (...) block.
//pub struct BaseBlockStartState {
//  *BaseDecisionState
//  endState: *BlockEndState
//}
//
//impl BlockStartState {§//  pub fn new() -> *BaseBlockStartState {
//  return &BaseBlockStartState{BaseDecisionState: NewBaseDecisionState()}
//}
//
//pub fn getEndState() -> *BlockEndState {
//  return s.endState
//}
//
//pub fn setEndState(b *BlockEndState) {
//  s.endState = b
//}
//
//pub struct BasicBlockStartState {
//  *BaseBlockStartState
//}
//
//impl BasicBlockStartState {§//  pub fn new() -> *BasicBlockStartState {
//  b := NewBlockStartState()
//
//  b.stateType = ATNStateBlockStart
//
//  return &BasicBlockStartState{BaseBlockStartState: b}
//}
//
//// BlockEndState is a terminal node of a simple (a|b|c) block.
//pub struct BlockEndState {
//  *BaseATNState
//  startState: ATNState
//}
//
//impl BlockEndState {§//  pub fn new() -> *BlockEndState {
//  b := NewBaseATNState()
//
//  b.stateType = ATNStateBlockEnd
//
//  return &BlockEndState{BaseATNState: b}
//}
//
//// RuleStopState is the last node in the ATN for a rule, unless that rule is the
//// start symbol. In that case, there is one transition to EOF. Later, we might
//// encode references to all calls to this rule to compute FOLLOW sets for error
//// handling.
//pub struct RuleStopState {
//  *BaseATNState
//}
//
//impl RuleStopState {§//  pub fn new() -> *RuleStopState {
//  b := NewBaseATNState()
//
//  b.stateType = ATNStateRuleStop
//
//  return &RuleStopState{BaseATNState: b}
//}
//
//pub struct RuleStartState {
//  *BaseATNState
//  stopState:        ATNState
//  isPrecedenceRule: bool
//}
//
//impl RuleStartState {§//  pub fn new() -> *RuleStartState {
//  b := NewBaseATNState()
//
//  b.stateType = ATNStateRuleStart
//
//  return &RuleStartState{BaseATNState: b}
//}
//
//// PlusLoopbackState is a decision state for A+ and (A|B)+. It has two
//// transitions: one to the loop back to start of the block, and one to exit.
//pub struct PlusLoopbackState {
//  *BaseDecisionState
//}
//
//impl PlusLoopbackState {§//  pub fn new() -> *PlusLoopbackState {
//  b := NewBaseDecisionState()
//
//  b.stateType = ATNStatePlusLoopBack
//
//  return &PlusLoopbackState{BaseDecisionState: b}
//}
//
//// PlusBlockStartState is the start of a (A|B|...)+ loop. Technically it is a
//// decision state; we don't use it for code generation. Somebody might need it,
//// it is included for completeness. In reality, PlusLoopbackState is the real
//// decision-making node for A+.
//pub struct PlusBlockStartState {
//  *BaseBlockStartState
//  loopBackState: ATNState
//}
//
//impl PlusBlockStartState {§//  pub fn new() -> *PlusBlockStartState {
//  b := NewBlockStartState()
//
//  b.stateType = ATNStatePlusBlockStart
//
//  return &PlusBlockStartState{BaseBlockStartState: b}
//}
//
//// StarBlockStartState is the block that begins a closure loop.
//pub struct StarBlockStartState {
//  *BaseBlockStartState
//}
//
//impl StarBlockStartState {§//  pub fn new() -> *StarBlockStartState {
//  b := NewBlockStartState()
//
//  b.stateType = ATNStateStarBlockStart
//
//  return &StarBlockStartState{BaseBlockStartState: b}
//}
//
//pub struct StarLoopbackState {
//  *BaseATNState
//}
//
//impl StarLoopbackState {§//  pub fn new() -> *StarLoopbackState {
//  b := NewBaseATNState()
//
//  b.stateType = ATNStateStarLoopBack
//
//  return &StarLoopbackState{BaseATNState: b}
//}
//
//pub struct StarLoopEntryState {
//  *BaseDecisionState
//  loopBackState:          ATNState
//  precedenceRuleDecision: bool
//}
//
//impl StarLoopEntryState {§//  pub fn new() -> *StarLoopEntryState {
//  b := NewBaseDecisionState()
//
//  b.stateType = ATNStateStarLoopEntry
//
//  // False precedenceRuleDecision indicates whether s state can benefit from a precedence DFA during SLL decision making.
//  return &StarLoopEntryState{BaseDecisionState: b}
//}
//
//// LoopEndState marks the end of a * or + loop.
//pub struct LoopEndState {
//  *BaseATNState
//  loopBackState: ATNState
//}
//
//impl LoopEndState {§//  pub fn new() -> *LoopEndState {
//  b := NewBaseATNState()
//
//  b.stateType = ATNStateLoopEnd
//
//  return &LoopEndState{BaseATNState: b}
//}
//
//// TokensStartState is the Tokens rule start state linking to each lexer rule start state.
//pub struct TokensStartState {
//  *BaseDecisionState
//}
//
//impl TokensStartState {§//  pub fn new() -> *TokensStartState {
//  b := NewBaseDecisionState()
//
//  b.stateType = ATNStateTokenStart
//
//  return &TokensStartState{BaseDecisionState: b}
//}
