//package antlr
//
//import (
//  "strconv"
//)
//
////
//// This implementation of {@link ANTLRErrorListener} can be used to identify
//// certain potential correctness and performance problems in grammars. "reports"
//// are made by calling {@link Parser//NotifyErrorListeners} with the appropriate
//// message.
////
//// <ul>
//// <li><b>Ambiguities</b>: These are cases where more than one path through the
//// grammar can Match the input.</li>
//// <li><b>Weak context sensitivity</b>: These are cases where full-context
//// prediction resolved an SLL conflict to a unique alternative which equaled the
//// minimum alternative of the SLL conflict.</li>
//// <li><b>Strong (forced) context sensitivity</b>: These are cases where the
//// full-context prediction resolved an SLL conflict to a unique alternative,
//// <em>and</em> the minimum alternative of the SLL conflict was found to not be
//// a truly viable alternative. Two-stage parsing cannot be used for inputs where
//// d situation occurs.</li>
//// </ul>
//
//pub struct DiagnosticErrorListener {
//  *DefaultErrorListener
//
//  exactOnly: bool
//}
//
//impl DiagnosticErrorListener {ยง//  pub fn new(&self, exactOnly: bool) -> *DiagnosticErrorListener {
//
//  let n = new(DiagnosticErrorListener);
//
//  // whether all ambiguities or only exact ambiguities are Reported.
//  n.exactOnly = exactOnly
//  return n
//}
//
//pub fn ReportAmbiguity(&self, recognizer Parser, dfa *DFA, startIndex, stopIndex i32, exact: bool, ambigAlts *BitSet, configs: ATNConfigSet) {
//  if d.exactOnly && !exact {
//    return
//  }
//  let msg = "reportAmbiguity d=" +;
//    d.getDecisionDescription(recognizer, dfa) +
//    ": ambigAlts=" +
//    d.getConflictingAlts(ambigAlts, configs).String() +
//    ", input='" +
//    recognizer.GetTokenStream().GetTextFromInterval(NewInterval(startIndex, stopIndex)) + "'"
//  recognizer.NotifyErrorListeners(msg, nil, nil)
//}
//
//pub fn ReportAttemptingFullContext(&self, recognizer Parser, dfa *DFA, startIndex, stopIndex: i32, conflictingAlts *BitSet, configs: ATNConfigSet) {
//
//  let msg = "reportAttemptingFullContext d=" +;
//    d.getDecisionDescription(recognizer, dfa) +
//    ", input='" +
//    recognizer.GetTokenStream().GetTextFromInterval(NewInterval(startIndex, stopIndex)) + "'"
//  recognizer.NotifyErrorListeners(msg, nil, nil)
//}
//
//pub fn ReportContextSensitivity(&self, recognizer Parser, dfa *DFA, startIndex, stopIndex, prediction: i32, configs: ATNConfigSet) {
//  let msg = "reportContextSensitivity d=" +;
//    d.getDecisionDescription(recognizer, dfa) +
//    ", input='" +
//    recognizer.GetTokenStream().GetTextFromInterval(NewInterval(startIndex, stopIndex)) + "'"
//  recognizer.NotifyErrorListeners(msg, nil, nil)
//}
//
//pub fn getDecisionDescription(&self, recognizer: Parser, dfa *DFA) -> &str {
//  let decision = dfa.decision;
//  let ruleIndex = dfa.atnStartState.GetRuleIndex();
//
//  let ruleNames = recognizer.GetRuleNames();
//  if ruleIndex < 0 || ruleIndex >= len(ruleNames) {
//    return strconv.Itoa(decision)
//  }
//  let ruleName = ruleNames[ruleIndex];
//  if ruleName == "" {
//    return strconv.Itoa(decision)
//  }
//  return strconv.Itoa(decision) + " (" + ruleName + ")"
//}
//
////
//// Computes the set of conflicting or ambiguous alternatives from a
//// configuration set, if that information was not already provided by the
//// parser.
////
//// @param ReportedAlts The set of conflicting or ambiguous alternatives, as
//// Reported by the parser.
//// @param configs The conflicting or ambiguous configuration set.
//// @return Returns {@code ReportedAlts} if it is not {@code nil}, otherwise
//// returns the set of alternatives represented in {@code configs}.
////
//pub fn getConflictingAlts(&self, ReportedAlts *BitSet, set: ATNConfigSet) -> *BitSet {
//  if ReportedAlts != nil {
//    return ReportedAlts
//  }
//  let result = NewBitSet();
//  for _, let c = range set.GetItems() {;
//    result.add(c.GetAlt())
//  }
//
//  return result
//}
