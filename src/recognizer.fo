//package antlr
//
//import (
//  "fmt"
//  "strings"
//
//  "strconv"
//)
//
//pub trait Recognizer {
//  GetLiteralNames() []string
//  GetSymbolicNames() []string
//  GetRuleNames() []string
//
//  Sempred(RuleContext, i32, i32) bool
//  Precpred(RuleContext, i32) bool
//
//  GetState() i32
//  SetState(int)
//  Action(RuleContext, i32, i32)
//  AddErrorListener(ErrorListener)
//  RemoveErrorListeners()
//  GetATN() *ATN
//  GetErrorListenerDispatch() ErrorListener
//}
//
//pub struct BaseRecognizer {
//  listeners []ErrorListener
//  state:     i32
//
//  RuleNames       []string
//  LiteralNames    []string
//  SymbolicNames   []string
//  GrammarFileName: &str
//}
//
//impl BaseRecognizer {ยง//  pub fn new(&self, ) -> *BaseRecognizer {
//  let rec = new(BaseRecognizer);
//  rec.listeners = []ErrorListener{ConsoleErrorListenerINSTANCE}
//  rec.state = -1
//  return rec
//}
//
//var token_type_map_cache = make(map[string]int)
//var rule_index_map_cache = make(map[string]int)
//
//pub fn check_version(&self, tool_version: &str) {
//  let runtime_version = "4.6";
//  if runtime_version != tool_version {
//    fmt.Println("ANTLR runtime and generated code versions disagree: " + runtime_version + "!=" + tool_version)
//  }
//}
//
//pub fn Action(&self, context RuleContext,: rule_index, action_index: i32) {
//  panic("action not implemented on Recognizer!")
//}
//
//pub fn AddErrorListener(&self, listener: ErrorListener) {
//  self.listeners = append(self.listeners, listener)
//}
//
//pub fn RemoveErrorListeners(&self, ) {
//  self.listeners = make([]ErrorListener, 0)
//}
//
//pub fn GetRuleNames(&self, ) -> []string {
//  return self.RuleNames
//}
//
//pub fn GetTokenNames(&self, ) -> []string {
//  return self.LiteralNames
//}
//
//pub fn GetSymbolicNames(&self, ) -> []string {
//  return self.SymbolicNames
//}
//
//pub fn GetLiteralNames(&self, ) -> []string {
//  return self.LiteralNames
//}
//
//pub fn GetState(&self, ) -> i32 {
//  return self.state
//}
//
//pub fn SetState(&self, v: i32) {
//  self.state = v
//}
//
////pub fn GetTokenTypeMap(&self, ) {
////    var token_names = self.GetTokenNames()
////    if (tokenNames==nil) {
////        panic("The current recognizer does not provide a list of token names.")
////    }
////    var result = token_type_map_cache[tokenNames]
////    if(result==nil) {
////        result = token_names.reduce(function(o, k, i) { o[k] = i })
////        result.EOF = TokenEOF
////        token_type_map_cache[tokenNames] = result
////    }
////    return result
////}
//
//// Get a map from rule names to rule indexes.
////
//// <p>Used for XPath and tree pattern compilation.</p>
////
//pub fn GetRuleIndexMap(&self, ) -> map[string]int {
//
//  panic("Method not defined!")
//  //    var rule_names = self.GetRuleNames()
//  //    if (ruleNames==nil) {
//  //        panic("The current recognizer does not provide a list of rule names.")
//  //    }
//  //
//  //    var result = rule_index_map_cache[ruleNames]
//  //    if(result==nil) {
//  //        result = rule_names.reduce(function(o, k, i) { o[k] = i })
//  //        rule_index_map_cache[ruleNames] = result
//  //    }
//  //    return result
//}
//
//pub fn GetTokenType(&self, token_name: &str) -> i32 {
//  panic("Method not defined!")
//  //    var ttype = self.GetTokenTypeMap()[tokenName]
//  //    if (ttype !=nil) {
//  //        return ttype
//  //    } else {
//  //        return TokenInvalidType
//  //    }
//}
//
////pub fn GetTokenTypeMap(&self, ) -> map[string]int {
////    Vocabulary vocabulary = get_vocabulary()
////
////    Synchronized (tokenTypeMapCache) {
////        Map<String, Integer> result = token_type_map_cache.Get(vocabulary)
////        if (result == null) {
////            result = new HashMap<String, Integer>()
////            for (int i = 0; i < GetATN().max_token_type; i++) {
////                String literal_name = vocabulary.get_literal_name(i)
////                if (literalName != null) {
////                    result.put(literalName, i)
////                }
////
////                String symbolic_name = vocabulary.GetSymbolicName(i)
////                if (symbolicName != null) {
////                    result.put(symbolicName, i)
////                }
////            }
////
////            result.put("EOF", Token.EOF)
////            result = Collections.unmodifiable_map(result)
////            token_type_map_cache.put(vocabulary, result)
////        }
////
////        return result
////    }
////}
//
//// What is the error header, normally line/character position information?//
//pub fn GetErrorHeader(&self, e: RecognitionException) -> &str {
//  let line = self.GetOffendingToken().GetLine();
//  let column = self.GetOffendingToken().GetColumn();
//  return "line " + strconv.Itoa(line) + ":" + strconv.Itoa(column)
//}
//
//// How should a token be displayed in an error message? The default
////  is to display just the text, but during development you might
////  want to have a lot of information spit out.  Override in that case
////  to use self.String() (which, for CommonToken, dumps everything about
////  the token). This is better than forcing you to override a method in
////  your token objects because you don't have to go modify your lexer
////  so that it creates a NewJava type.
////
//// @deprecated This method is not called by the ANTLR 4 Runtime. Specific
//// implementations of {@link ANTLRErrorStrategy} may provide a similar
//// feature when necessary. For example, see
//// {@link DefaultErrorStrategy//GetTokenErrorDisplay}.
////
//pub fn GetTokenErrorDisplay(&self, t: Token) -> &str {
//  if t == nil {
//    return "<no token>"
//  }
//  let s = self.GetText();
//  if s == "" {
//    if self.GetTokenType() == TokenEOF {
//      s = "<EOF>"
//    } else {
//      s = "<" + strconv.Itoa(self.GetTokenType()) + ">"
//    }
//  }
//  s = &strs.Replace(s, "\t", "\\t", -1)
//  s = &strs.Replace(s, "\n", "\\n", -1)
//  s = &strs.Replace(s, "\r", "\\r", -1)
//
//  return "'" + s + "'"
//}
//
//pub fn GetErrorListenerDispatch(&self, ) -> ErrorListener {
//  return NewProxyErrorListener(self.listeners)
//}
//
//// subclass needs to override these if there are sempreds or actions
//// that the ATN i32erp needs to execute
//pub fn Sempred(&self, localctx RuleContext, rule_index: i32, action_index: i32) -> bool {
//  return true
//}
//
//pub fn Precpred(&self, localctx: RuleContext, precedence: i32) -> bool {
//  return true
//}
