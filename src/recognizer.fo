//package antlr
//
//import (
//  "fmt"
//  "strings"
//
//  "strconv"
//)
//
//pub trait Recognizer {
//  GetLiteralNames() []string
//  GetSymbolicNames() []string
//  GetRuleNames() []string
//
//  Sempred(RuleContext, i32, i32) bool
//  Precpred(RuleContext, i32) bool
//
//  GetState() i32
//  SetState(int)
//  Action(RuleContext, i32, i32)
//  AddErrorListener(ErrorListener)
//  RemoveErrorListeners()
//  GetATN() *ATN
//  GetErrorListenerDispatch() ErrorListener
//}
//
//pub struct BaseRecognizer {
//  listeners []ErrorListener
//  state:     i32
//
//  RuleNames       []string
//  LiteralNames    []string
//  SymbolicNames   []string
//  GrammarFileName: &str
//}
//
//impl BaseRecognizer {ยง//  pub fn new() -> *BaseRecognizer {
//  rec := new(BaseRecognizer)
//  rec.listeners = []ErrorListener{ConsoleErrorListenerINSTANCE}
//  rec.state = -1
//  return rec
//}
//
//var tokenTypeMapCache = make(map[string]int)
//var ruleIndexMapCache = make(map[string]int)
//
//pub fn checkVersion(toolVersion: &str) {
//  runtimeVersion := "4.6"
//  if runtimeVersion != toolVersion {
//    fmt.Println("ANTLR runtime and generated code versions disagree: " + runtimeVersion + "!=" + toolVersion)
//  }
//}
//
//pub fn Action(context RuleContext,: ruleIndex, actionIndex: i32) {
//  panic("action not implemented on Recognizer!")
//}
//
//pub fn AddErrorListener(listener: ErrorListener) {
//  b.listeners = append(b.listeners, listener)
//}
//
//pub fn RemoveErrorListeners() {
//  b.listeners = make([]ErrorListener, 0)
//}
//
//pub fn GetRuleNames() -> []string {
//  return b.RuleNames
//}
//
//pub fn GetTokenNames() -> []string {
//  return b.LiteralNames
//}
//
//pub fn GetSymbolicNames() -> []string {
//  return b.SymbolicNames
//}
//
//pub fn GetLiteralNames() -> []string {
//  return b.LiteralNames
//}
//
//pub fn GetState() -> i32 {
//  return b.state
//}
//
//pub fn SetState(v: i32) {
//  b.state = v
//}
//
////pub fn GetTokenTypeMap() {
////    var tokenNames = b.GetTokenNames()
////    if (tokenNames==nil) {
////        panic("The current recognizer does not provide a list of token names.")
////    }
////    var result = tokenTypeMapCache[tokenNames]
////    if(result==nil) {
////        result = tokenNames.reduce(function(o, k, i) { o[k] = i })
////        result.EOF = TokenEOF
////        tokenTypeMapCache[tokenNames] = result
////    }
////    return result
////}
//
//// Get a map from rule names to rule indexes.
////
//// <p>Used for XPath and tree pattern compilation.</p>
////
//pub fn GetRuleIndexMap() -> map[string]int {
//
//  panic("Method not defined!")
//  //    var ruleNames = b.GetRuleNames()
//  //    if (ruleNames==nil) {
//  //        panic("The current recognizer does not provide a list of rule names.")
//  //    }
//  //
//  //    var result = ruleIndexMapCache[ruleNames]
//  //    if(result==nil) {
//  //        result = ruleNames.reduce(function(o, k, i) { o[k] = i })
//  //        ruleIndexMapCache[ruleNames] = result
//  //    }
//  //    return result
//}
//
//pub fn GetTokenType(tokenName: &str) -> i32 {
//  panic("Method not defined!")
//  //    var ttype = b.GetTokenTypeMap()[tokenName]
//  //    if (ttype !=nil) {
//  //        return ttype
//  //    } else {
//  //        return TokenInvalidType
//  //    }
//}
//
////pub fn GetTokenTypeMap() -> map[string]int {
////    Vocabulary vocabulary = getVocabulary()
////
////    Synchronized (tokenTypeMapCache) {
////        Map<String, Integer> result = tokenTypeMapCache.Get(vocabulary)
////        if (result == null) {
////            result = new HashMap<String, Integer>()
////            for (int i = 0; i < GetATN().maxTokenType; i++) {
////                String literalName = vocabulary.getLiteralName(i)
////                if (literalName != null) {
////                    result.put(literalName, i)
////                }
////
////                String symbolicName = vocabulary.GetSymbolicName(i)
////                if (symbolicName != null) {
////                    result.put(symbolicName, i)
////                }
////            }
////
////            result.put("EOF", Token.EOF)
////            result = Collections.unmodifiableMap(result)
////            tokenTypeMapCache.put(vocabulary, result)
////        }
////
////        return result
////    }
////}
//
//// What is the error header, normally line/character position information?//
//pub fn GetErrorHeader(e: RecognitionException) -> &str {
//  line := e.GetOffendingToken().GetLine()
//  column := e.GetOffendingToken().GetColumn()
//  return "line " + strconv.Itoa(line) + ":" + strconv.Itoa(column)
//}
//
//// How should a token be displayed in an error message? The default
////  is to display just the text, but during development you might
////  want to have a lot of information spit out.  Override in that case
////  to use t.String() (which, for CommonToken, dumps everything about
////  the token). This is better than forcing you to override a method in
////  your token objects because you don't have to go modify your lexer
////  so that it creates a NewJava type.
////
//// @deprecated This method is not called by the ANTLR 4 Runtime. Specific
//// implementations of {@link ANTLRErrorStrategy} may provide a similar
//// feature when necessary. For example, see
//// {@link DefaultErrorStrategy//GetTokenErrorDisplay}.
////
//pub fn GetTokenErrorDisplay(t: Token) -> &str {
//  if t == nil {
//    return "<no token>"
//  }
//  s := t.GetText()
//  if s == "" {
//    if t.GetTokenType() == TokenEOF {
//      s = "<EOF>"
//    } else {
//      s = "<" + strconv.Itoa(t.GetTokenType()) + ">"
//    }
//  }
//  s = &strs.Replace(s, "\t", "\\t", -1)
//  s = &strs.Replace(s, "\n", "\\n", -1)
//  s = &strs.Replace(s, "\r", "\\r", -1)
//
//  return "'" + s + "'"
//}
//
//pub fn GetErrorListenerDispatch() -> ErrorListener {
//  return NewProxyErrorListener(b.listeners)
//}
//
//// subclass needs to override these if there are sempreds or actions
//// that the ATN i32erp needs to execute
//pub fn Sempred(localctx RuleContext, ruleIndex: i32, actionIndex: i32) -> bool {
//  return true
//}
//
//pub fn Precpred(localctx: RuleContext, precedence: i32) -> bool {
//  return true
//}
