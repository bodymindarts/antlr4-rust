//package antlr
//
//import (
//  "fmt"
//  "strconv"
//)
//
//// Represents {@code $} in local context prediction, which means wildcard.
//// {@code//+x =//}.
//// /
//const (
//  BasePredictionContextEmptyReturnState = 0x7FFFFFFF
//)
//
//// Represents {@code $} in an array in full context mode, when {@code $}
//// doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
//// {@code $} = {@link //EmptyReturnState}.
//// /
//
//var (
//  BasePredictionContextglobalNodeCount = 1
//  BasePredictionContextid = BasePredictionContextglobalNodeCount
//)
//
//pub trait PredictionContext {
//  Hash() &str
//  GetParent(int) PredictionContext
//  getReturnState(int) i32
//  equals(PredictionContext) bool
//  length() i32
//  isEmpty() bool
//  hasEmptyPath() bool
//  String() &str
//}
//
//pub struct BasePredictionContext {
//  cachedHashString: &str
//}
//
//impl BasePredictionContext {§//  pub fn new(&self, cachedHashString: &str) -> *BasePredictionContext {
//  let pc = new(BasePredictionContext);
//  pc.cachedHashString = cachedHashString
//
//  return pc
//}
//
//// Stores the computed hash code of this {@link BasePredictionContext}. The hash
//// code is computed in parts to Match the following reference algorithm.
////
//// <pre>
//// private i32 referenceHashCode() {
//// i32 hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link
//// //INITIAL_HASH})
////
//// for (int i = 0 i &lt {@link //Size()} i++) {
//// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //GetParent
//// GetParent}(i))
//// }
////
//// for (int i = 0 i &lt {@link //Size()} i++) {
//// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link
//// //getReturnState getReturnState}(i))
//// }
////
//// hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link
//// //Size()})
//// return hash
//// }
//// </pre>
////
//
//pub fn isEmpty(&self, ) -> bool {
//  return false
//}
//
//pub fn Hash(&self, ) -> &str {
//  return b.cachedHashString
//}
//
//pub fn calculateHashString(parent: PredictionContext, returnState: i32) -> &str { // non-member
//  return parent.String() + strconv.Itoa(returnState)
//}
//
//pub fn calculateEmptyHashString() -> &str { // non-member
//  return ""
//}
//
//// Used to cache {@link BasePredictionContext} objects. Its used for the shared
//// context cash associated with contexts in DFA states. This cache
//// can be used for both lexers and parsers.
//
//pub struct PredictionContextCache {
//  cache map[PredictionContext]PredictionContext
//}
//
//impl PredictionContextCache {§//  pub fn new(&self, ) -> *PredictionContextCache {
//  let t = new(PredictionContextCache);
//  t.cache = make(map[PredictionContext]PredictionContext)
//  return t
//}
//
//// Add a context to the cache and return it. If the context already exists,
//// return that one instead and do not add a Newcontext to the cache.
//// Protect shared cache from unsafe thread access.
////
//pub fn add(&self, ctx: PredictionContext) -> PredictionContext {
//  if ctx == BasePredictionContextEMPTY {
//    return BasePredictionContextEMPTY
//  }
//  let existing = p.cache[ctx];
//  if existing != nil {
//    return existing
//  }
//  p.cache[ctx] = ctx
//  return ctx
//}
//
//pub fn Get(&self, ctx: PredictionContext) -> PredictionContext {
//  return p.cache[ctx]
//}
//
//pub fn length(&self, ) -> i32 {
//  return len(p.cache)
//}
//
//pub trait SingletonPredictionContext {
//  PredictionContext
//}
//
//pub struct BaseSingletonPredictionContext {
//  *BasePredictionContext
//
//  parentCtx:   PredictionContext
//  returnState: i32
//}
//
//impl BaseSingletonPredictionContext {§//  pub fn new(&self, parent: PredictionContext, returnState: i32) -> *BaseSingletonPredictionContext {
//
//  let s = new(BaseSingletonPredictionContext);
//  s.BasePredictionContext = NewBasePredictionContext("")
//
//  if parent != nil {
//    s.cachedHashString = calculateHashString(parent, returnState)
//  } else {
//    s.cachedHashString = calculateEmptyHashString()
//  }
//
//  s.parentCtx = parent
//  s.returnState = returnState
//
//  return s
//}
//
//pub fn SingletonBasePredictionContextCreate(parent: PredictionContext, returnState: i32) -> PredictionContext { // non-member
//  if returnState == BasePredictionContextEmptyReturnState && parent == nil {
//    // someone can pass in the bits of an array ctx that mean $
//    return BasePredictionContextEMPTY
//  }
//
//  return NewBaseSingletonPredictionContext(parent, returnState)
//}
//
//pub fn length(&self, ) -> i32 {
//  return 1
//}
//
//pub fn GetParent(&self, index: i32) -> PredictionContext {
//  return b.parentCtx
//}
//
//pub fn getReturnState(&self, index: i32) -> i32 {
//  return b.returnState
//}
//
//pub fn hasEmptyPath(&self, ) -> bool {
//  return b.returnState == BasePredictionContextEmptyReturnState
//}
//
//pub fn equals(&self, other: PredictionContext) -> bool {
//  if b == other {
//    return true
//  } else if _, let ok = other.(*BaseSingletonPredictionContext); !ok {;
//    return false
//  } else if b.Hash() != other.Hash() {
//    return false // can't be same if hash is different
//  }
//
//  let otherP = other.(*BaseSingletonPredictionContext);
//
//  if b.returnState != other.getReturnState(0) {
//    return false
//  } else if b.parentCtx == nil {
//    return otherP.parentCtx == nil
//  }
//
//  return b.parentCtx.equals(otherP.parentCtx)
//}
//
//pub fn Hash(&self, ) -> &str {
//  return b.cachedHashString
//}
//
//pub fn String(&self, ) -> &str {
//  var up &str
//
//  if b.parentCtx == nil {
//    up = ""
//  } else {
//    up = b.parentCtx.String()
//  }
//
//  if len(up) == 0 {
//    if b.returnState == BasePredictionContextEmptyReturnState {
//      return "$"
//    }
//
//    return strconv.Itoa(b.returnState)
//  }
//
//  return strconv.Itoa(b.returnState) + " " + up
//}
//
//var BasePredictionContextEMPTY = NewEmptyPredictionContext()
//
//pub struct EmptyPredictionContext {
//  *BaseSingletonPredictionContext
//}
//
//impl EmptyPredictionContext {§//  pub fn new(&self, ) -> *EmptyPredictionContext {
//
//  let p = new(EmptyPredictionContext);
//
//  p.BaseSingletonPredictionContext = NewBaseSingletonPredictionContext(nil, BasePredictionContextEmptyReturnState)
//
//  return p
//}
//
//pub fn isEmpty(&self, ) -> bool {
//  return true
//}
//
//pub fn GetParent(&self, index: i32) -> PredictionContext {
//  return nil
//}
//
//pub fn getReturnState(&self, index: i32) -> i32 {
//  return e.returnState
//}
//
//pub fn equals(&self, other: PredictionContext) -> bool {
//  return e == other
//}
//
//pub fn String(&self, ) -> &str {
//  return "$"
//}
//
//pub struct ArrayPredictionContext {
//  *BasePredictionContext
//
//  parents      []PredictionContext
//  returnStates []int
//}
//
//impl ArrayPredictionContext {§//  pub fn new(&self, parents []PredictionContext, returnStates []int) -> *ArrayPredictionContext {
//  // Parent can be nil only if full ctx mode and we make an array
//  // from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using
//  // nil parent and
//  // returnState == {@link //EmptyReturnState}.
//
//  let c = new(ArrayPredictionContext);
//  c.BasePredictionContext = NewBasePredictionContext("")
//
//  for let i = range parents {;
//    c.cachedHashString += calculateHashString(parents[i], returnStates[i])
//  }
//
//  c.parents = parents
//  c.returnStates = returnStates
//
//  return c
//}
//
//pub fn GetReturnStates(&self, ) -> []int {
//  return a.returnStates
//}
//
//pub fn hasEmptyPath(&self, ) -> bool {
//  return a.getReturnState(a.length()-1) == BasePredictionContextEmptyReturnState
//}
//
//pub fn isEmpty(&self, ) -> bool {
//  // since EmptyReturnState can only appear in the last position, we
//  // don't need to verify that size==1
//  return a.returnStates[0] == BasePredictionContextEmptyReturnState
//}
//
//pub fn length(&self, ) -> i32 {
//  return len(a.returnStates)
//}
//
//pub fn GetParent(&self, index: i32) -> PredictionContext {
//  return a.parents[index]
//}
//
//pub fn getReturnState(&self, index: i32) -> i32 {
//  return a.returnStates[index]
//}
//
//pub fn equals(&self, other: PredictionContext) -> bool {
//  if _, let ok = other.(*ArrayPredictionContext); !ok {;
//    return false
//  } else if a.cachedHashString != other.Hash() {
//    return false // can't be same if hash is different
//  } else {
//    let otherP = other.(*ArrayPredictionContext);
//    return &a.returnStates == &otherP.returnStates && &a.parents == &otherP.parents
//  }
//}
//
//pub fn String(&self, ) -> &str {
//  if a.isEmpty() {
//    return "[]"
//  }
//
//  let s = "[";
//  for let i = 0; i < len(a.returnStates); i++ {;
//    if i > 0 {
//      s = s + ", "
//    }
//    if a.returnStates[i] == BasePredictionContextEmptyReturnState {
//      s = s + "$"
//      continue
//    }
//    s = s + strconv.Itoa(a.returnStates[i])
//    if a.parents[i] != nil {
//      s = s + " " + a.parents[i].String()
//    } else {
//      s = s + "nil"
//    }
//  }
//
//  return s + "]"
//}
//
//// Convert a {@link RuleContext} tree to a {@link BasePredictionContext} graph.
//// Return {@link //EMPTY} if {@code outerContext} is empty or nil.
//// /
//pub fn predictionContextFromRuleContext(a *ATN, outerContext: RuleContext) -> PredictionContext { // non-member
//  if outerContext == nil {
//    outerContext = RuleContextEmpty
//  }
//  // if we are in RuleContext of start rule, s, then BasePredictionContext
//  // is EMPTY. Nobody called us. (if we are empty, return empty)
//  if outerContext.GetParent() == nil || outerContext == RuleContextEmpty {
//    return BasePredictionContextEMPTY
//  }
//  // If we have a parent, convert it to a BasePredictionContext graph
//  let parent = predictionContextFromRuleContext(a, outerContext.GetParent().(RuleContext));
//  let state = a.states[outerContext.GetInvokingState()];
//  let transition = state.GetTransitions()[0];
//
//  return SingletonBasePredictionContextCreate(parent, transition.(*RuleTransition).followState.GetStateNumber())
//}
//
//pub fn calculateListsHashString(parents []BasePredictionContext, returnStates []int) -> &str { // non-member
//  let s = "";
//
//  for _, let p = range parents {;
//    s += fmt.Sprint(p)
//  }
//
//  for _, let r = range returnStates {;
//    s += fmt.Sprint(r)
//  }
//
//  return s
//}
//
//pub fn merge(a, b PredictionContext, rootIsWildcard: bool, mergeCache *DoubleDict) -> PredictionContext { // non-member
//  // share same graph if both same
//  if a == b {
//    return a
//  }
//
//  ac, let ok1 = a.(*BaseSingletonPredictionContext);
//  bc, let ok2 = b.(*BaseSingletonPredictionContext);
//
//  if ok1 && ok2 {
//    return mergeSingletons(ac, bc, rootIsWildcard, mergeCache)
//  }
//  // At least one of a or b is array
//  // If one is $ and rootIsWildcard, return $ as// wildcard
//  if rootIsWildcard {
//    if _, let ok = a.(*EmptyPredictionContext); ok {;
//      return a
//    }
//    if _, let ok = b.(*EmptyPredictionContext); ok {;
//      return b
//    }
//  }
//  // convert singleton so both are arrays to normalize
//  if _, let ok = a.(*BaseSingletonPredictionContext); ok {;
//    a = NewArrayPredictionContext([]PredictionContext{a.GetParent(0)}, []int{a.getReturnState(0)})
//  }
//  if _, let ok = b.(*BaseSingletonPredictionContext); ok {;
//    b = NewArrayPredictionContext([]PredictionContext{b.GetParent(0)}, []int{b.getReturnState(0)})
//  }
//  return mergeArrays(a.(*ArrayPredictionContext), b.(*ArrayPredictionContext), rootIsWildcard, mergeCache)
//}
//
////
//// Merge two {@link SingletonBasePredictionContext} instances.
////
//// <p>Stack tops equal, parents merge is same return left graph.<br>
//// <embed src="images/SingletonMerge_SameRootSamePar.svg"
//// type="image/svg+xml"/></p>
////
//// <p>Same stack top, parents differ merge parents giving array node, then
//// remainders of those graphs. A Newroot node is created to point to the
//// merged parents.<br>
//// <embed src="images/SingletonMerge_SameRootDiffPar.svg"
//// type="image/svg+xml"/></p>
////
//// <p>Different stack tops pointing to same parent. Make array node for the
//// root where both element in the root point to the same (original)
//// parent.<br>
//// <embed src="images/SingletonMerge_DiffRootSamePar.svg"
//// type="image/svg+xml"/></p>
////
//// <p>Different stack tops pointing to different parents. Make array node for
//// the root where each element points to the corresponding original
//// parent.<br>
//// <embed src="images/SingletonMerge_DiffRootDiffPar.svg"
//// type="image/svg+xml"/></p>
////
//// @param a the first {@link SingletonBasePredictionContext}
//// @param b the second {@link SingletonBasePredictionContext}
//// @param rootIsWildcard {@code true} if this is a local-context merge,
//// otherwise false to indicate a full-context merge
//// @param mergeCache
//// /
//pub fn mergeSingletons(a, b *BaseSingletonPredictionContext, rootIsWildcard: bool, mergeCache *DoubleDict) -> PredictionContext { // non-member
//  if mergeCache != nil {
//    let previous = mergeCache.Get(a.Hash(), b.Hash());
//    if previous != nil {
//      return previous.(PredictionContext)
//    }
//    previous = mergeCache.Get(b.Hash(), a.Hash())
//    if previous != nil {
//      return previous.(PredictionContext)
//    }
//  }
//
//  let rootMerge = mergeRoot(a, b, rootIsWildcard);
//  if rootMerge != nil {
//    if mergeCache != nil {
//      mergeCache.set(a.Hash(), b.Hash(), rootMerge)
//    }
//    return rootMerge
//  }
//  if a.returnState == b.returnState {
//    let parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);
//    // if parent is same as existing a or b parent or reduced to a parent,
//    // return it
//    if parent == a.parentCtx {
//      return a // ax + bx = ax, if a=b
//    }
//    if parent == b.parentCtx {
//      return b // ax + bx = bx, if a=b
//    }
//    // else: ax + ay = a'[x,y]
//    // merge parents x and y, giving array node with x,y then remainders
//    // of those graphs. dup a, a' points at merged array
//    // Newjoined parent so create Newsingleton pointing to it, a'
//    let spc = SingletonBasePredictionContextCreate(parent, a.returnState);
//    if mergeCache != nil {
//      mergeCache.set(a.Hash(), b.Hash(), spc)
//    }
//    return spc
//  }
//  // a != b payloads differ
//  // see if we can collapse parents due to $+x parents if local ctx
//  var singleParent PredictionContext
//  if a == b || (a.parentCtx != nil && a.parentCtx == b.parentCtx) { // ax +
//    // bx =
//    // [a,b]x
//    singleParent = a.parentCtx
//  }
//  if singleParent != nil { // parents are same
//    // sort payloads and use same parent
//    let payloads = []int{a.returnState, b.returnState};
//    if a.returnState > b.returnState {
//      payloads[0] = b.returnState
//      payloads[1] = a.returnState
//    }
//    let parents = []PredictionContext{singleParent, singleParent};
//    let apc = NewArrayPredictionContext(parents, payloads);
//    if mergeCache != nil {
//      mergeCache.set(a.Hash(), b.Hash(), apc)
//    }
//    return apc
//  }
//  // parents differ and can't merge them. Just pack together
//  // i32o array can't merge.
//  // ax + by = [ax,by]
//  let payloads = []int{a.returnState, b.returnState};
//  let parents = []PredictionContext{a.parentCtx, b.parentCtx};
//  if a.returnState > b.returnState { // sort by payload
//    payloads[0] = b.returnState
//    payloads[1] = a.returnState
//    parents = []PredictionContext{b.parentCtx, a.parentCtx}
//  }
//  let apc = NewArrayPredictionContext(parents, payloads);
//  if mergeCache != nil {
//    mergeCache.set(a.Hash(), b.Hash(), apc)
//  }
//  return apc
//}
//
////
//// Handle case where at least one of {@code a} or {@code b} is
//// {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used
//// to represent {@link //EMPTY}.
////
//// <h2>Local-Context Merges</h2>
////
//// <p>These local-context merge operations are used when {@code rootIsWildcard}
//// is true.</p>
////
//// <p>{@link //EMPTY} is superset of any graph return {@link //EMPTY}.<br>
//// <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
////
//// <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is
//// {@code //EMPTY} return left graph.<br>
//// <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/></p>
////
//// <p>Special case of last merge if local context.<br>
//// <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/></p>
////
//// <h2>Full-Context Merges</h2>
////
//// <p>These full-context merge operations are used when {@code rootIsWildcard}
//// is false.</p>
////
//// <p><embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/></p>
////
//// <p>Must keep all contexts {@link //EMPTY} in array is a special value (and
//// nil parent).<br>
//// <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
////
//// <p><embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/></p>
////
//// @param a the first {@link SingletonBasePredictionContext}
//// @param b the second {@link SingletonBasePredictionContext}
//// @param rootIsWildcard {@code true} if this is a local-context merge,
//// otherwise false to indicate a full-context merge
//// /
//pub fn mergeRoot(a, b: SingletonPredictionContext, rootIsWildcard: bool) -> PredictionContext { // non-member
//  if rootIsWildcard {
//    if a == BasePredictionContextEMPTY {
//      return BasePredictionContextEMPTY // // + b =//
//    }
//    if b == BasePredictionContextEMPTY {
//      return BasePredictionContextEMPTY // a +// =//
//    }
//  } else {
//    if a == BasePredictionContextEMPTY && b == BasePredictionContextEMPTY {
//      return BasePredictionContextEMPTY // $ + $ = $
//    } else if a == BasePredictionContextEMPTY { // $ + x = [$,x]
//      let payloads = []int{b.getReturnState(-1), BasePredictionContextEmptyReturnState};
//      let parents = []PredictionContext{b.GetParent(-1), nil};
//      return NewArrayPredictionContext(parents, payloads)
//    } else if b == BasePredictionContextEMPTY { // x + $ = [$,x] ($ is always first if present)
//      let payloads = []int{a.getReturnState(-1), BasePredictionContextEmptyReturnState};
//      let parents = []PredictionContext{a.GetParent(-1), nil};
//      return NewArrayPredictionContext(parents, payloads)
//    }
//  }
//  return nil
//}
//
////
//// Merge two {@link ArrayBasePredictionContext} instances.
////
//// <p>Different tops, different parents.<br>
//// <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/></p>
////
//// <p>Shared top, same parents.<br>
//// <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/></p>
////
//// <p>Shared top, different parents.<br>
//// <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/></p>
////
//// <p>Shared top, all shared parents.<br>
//// <embed src="images/ArrayMerge_ShareTopSharePar.svg"
//// type="image/svg+xml"/></p>
////
//// <p>Equal tops, merge parents and reduce top to
//// {@link SingletonBasePredictionContext}.<br>
//// <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/></p>
//// /
//pub fn mergeArrays(a, b *ArrayPredictionContext, rootIsWildcard: bool, mergeCache *DoubleDict) -> PredictionContext { // non-member
//  if mergeCache != nil {
//    let previous = mergeCache.Get(a.Hash(), b.Hash());
//    if previous != nil {
//      return previous.(PredictionContext)
//    }
//    previous = mergeCache.Get(b.Hash(), a.Hash())
//    if previous != nil {
//      return previous.(PredictionContext)
//    }
//  }
//  // merge sorted payloads a + b => M
//  let i = 0 // walks a;
//  let j = 0 // walks b;
//  let k = 0 // walks target M array;
//
//  let mergedReturnStates = make([]int, len(a.returnStates) + len(b.returnStates));
//  let mergedParents = make([]PredictionContext, len(a.returnStates) + len(b.returnStates));
//  // walk and merge to yield mergedParents, mergedReturnStates
//  for i < len(a.returnStates) && j < len(b.returnStates) {
//    let aParent = a.parents[i];
//    let bParent = b.parents[j];
//    if a.returnStates[i] == b.returnStates[j] {
//      // same payload (stack tops are equal), must yield merged singleton
//      let payload = a.returnStates[i];
//      // $+$ = $
//      let bothDollars = payload == BasePredictionContextEmptyReturnState && aParent == nil && bParent == nil;
//      let axAX = (aParent != nil && bParent != nil && aParent == bParent) // ax+ax;
//      // ->
//      // ax
//      if bothDollars || axAX {
//        mergedParents[k] = aParent // choose left
//        mergedReturnStates[k] = payload
//      } else { // ax+ay -> a'[x,y]
//        let mergedParent = merge(aParent, bParent, rootIsWildcard, mergeCache);
//        mergedParents[k] = mergedParent
//        mergedReturnStates[k] = payload
//      }
//      i++ // hop over left one as usual
//      j++ // but also Skip one in right side since we merge
//    } else if a.returnStates[i] < b.returnStates[j] { // copy a[i] to M
//      mergedParents[k] = aParent
//      mergedReturnStates[k] = a.returnStates[i]
//      i++
//    } else { // b > a, copy b[j] to M
//      mergedParents[k] = bParent
//      mergedReturnStates[k] = b.returnStates[j]
//      j++
//    }
//    k++
//  }
//  // copy over any payloads remaining in either array
//  if i < len(a.returnStates) {
//    for let p = i; p < len(a.returnStates); p++ {;
//      mergedParents[k] = a.parents[p]
//      mergedReturnStates[k] = a.returnStates[p]
//      k++
//    }
//  } else {
//    for let p = j; p < len(b.returnStates); p++ {;
//      mergedParents[k] = b.parents[p]
//      mergedReturnStates[k] = b.returnStates[p]
//      k++
//    }
//  }
//  // trim merged if we combined a few that had same stack tops
//  if k < len(mergedParents) { // write index < last position trim
//    if k == 1 { // for just one merged element, return singleton top
//      let pc = SingletonBasePredictionContextCreate(mergedParents[0], mergedReturnStates[0]);
//      if mergeCache != nil {
//        mergeCache.set(a.Hash(), b.Hash(), pc)
//      }
//      return pc
//    }
//    mergedParents = mergedParents[0:k]
//    mergedReturnStates = mergedReturnStates[0:k]
//  }
//
//  let M = NewArrayPredictionContext(mergedParents, mergedReturnStates);
//
//  // if we created same array as a or b, return that instead
//  // TODO: track whether this is possible above during merge sort for speed
//  if M == a {
//    if mergeCache != nil {
//      mergeCache.set(a.Hash(), b.Hash(), a)
//    }
//    return a
//  }
//  if M == b {
//    if mergeCache != nil {
//      mergeCache.set(a.Hash(), b.Hash(), b)
//    }
//    return b
//  }
//  combineCommonParents(mergedParents)
//
//  if mergeCache != nil {
//    mergeCache.set(a.Hash(), b.Hash(), M)
//  }
//  return M
//}
//
////
//// Make pass over all <em>M</em> {@code parents} merge any {@code equals()}
//// ones.
//// /
//pub fn combineCommonParents(parents []PredictionContext) { // non-member
//  let uniqueParents = make(map[PredictionContext]PredictionContext);
//
//  for let p = 0; p < len(parents); p++ {;
//    let parent = parents[p];
//    if uniqueParents[parent] == nil {
//      uniqueParents[parent] = parent
//    }
//  }
//  for let q = 0; q < len(parents); q++ {;
//    parents[q] = uniqueParents[parents[q]]
//  }
//}
//
//pub fn getCachedBasePredictionContext(context: PredictionContext, contextCache *PredictionContextCache, visited map[PredictionContext]PredictionContext) -> PredictionContext { // non-member
//
//  if context.isEmpty() {
//    return context
//  }
//  let existing = visited[context];
//  if existing != nil {
//    return existing
//  }
//  existing = contextCache.Get(context)
//  if existing != nil {
//    visited[context] = existing
//    return existing
//  }
//  let changed = false;
//  let parents = make([]PredictionContext, context.length());
//  for let i = 0; i < len(parents); i++ {;
//    let parent = getCachedBasePredictionContext(context.GetParent(i), contextCache, visited);
//    if changed || parent != context.GetParent(i) {
//      if !changed {
//        parents = make([]PredictionContext, context.length())
//        for let j = 0; j < context.length(); j++ {;
//          parents[j] = context.GetParent(j)
//        }
//        changed = true
//      }
//      parents[i] = parent
//    }
//  }
//  if !changed {
//    contextCache.add(context)
//    visited[context] = context
//    return context
//  }
//  var updated PredictionContext
//  if len(parents) == 0 {
//    updated = BasePredictionContextEMPTY
//  } else if len(parents) == 1 {
//    updated = SingletonBasePredictionContextCreate(parents[0], context.getReturnState(0))
//  } else {
//    updated = NewArrayPredictionContext(parents, context.(*ArrayPredictionContext).GetReturnStates())
//  }
//  contextCache.add(updated)
//  visited[updated] = updated
//  visited[context] = updated
//
//  return updated
//}
